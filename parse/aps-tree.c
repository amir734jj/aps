/* Generated by a program written by John Boyland */
#include <stdio.h>
#include "aps-tree.h"
#include "aps-tree.handcode.i"
#include "tree.i"

/* Automatically generated file */

/* Typecase of what phylum a node has */

enum KEYTYPE_ABSTRACT_APS_Phylum ABSTRACT_APS_tnode_phylum(void *tnode) {
  if (tnode == 0) return KEY_ABSTRACT_APS_None;
  switch (((TNODE)tnode)->operator) {
    default:
      return KEY_ABSTRACT_APS_None;
    case 10201:
    case 10302:
    case 10403:
    case 10807:
    case 10908:
      return KEYSignature;
    case 9595:
    case 9696:
    case 9797:
    case 11009:
    case 11110:
    case 11312:
      return KEYType;
    case 9898:
    case 10100:
    case 13736:
    case 13837:
    case 13938:
    case 14039:
    case 14140:
    case 14241:
    case 14342:
    case 14443:
    case 14544:
    case 14645:
    case 14746:
    case 14847:
    case 14948:
    case 15049:
    case 15150:
    case 15251:
    case 15352:
      return KEYExpression;
    case 10504:
    case 10605:
    case 10706:
    case 11413:
    case 11514:
    case 11615:
    case 11716:
    case 11817:
    case 11918:
    case 12019:
    case 12120:
    case 12221:
    case 12322:
      return KEYPattern;
    case 9494:
      return KEYModule;
    case 9393:
      return KEYClass;
    case 8383:
      return KEYDef;
    case 8484:
    case 8585:
      return KEYUse;
    case 3737:
      return KEYProgram;
    case 3838:
    case 3939:
    case 4040:
      return KEYUnit;
    case 4141:
    case 4343:
    case 4444:
    case 4545:
    case 4646:
    case 4747:
    case 4848:
    case 4949:
    case 5050:
    case 5151:
    case 5252:
    case 5353:
    case 5454:
    case 5555:
    case 5656:
    case 5757:
    case 5858:
    case 5959:
    case 6060:
    case 6161:
    case 6262:
    case 6363:
    case 6464:
    case 6565:
    case 6666:
    case 6767:
    case 6868:
    case 6969:
    case 7777:
    case 7878:
    case 8080:
    case 8181:
    case 12423:
    case 12524:
    case 12625:
    case 12928:
    case 13029:
    case 13231:
    case 13332:
    case 13433:
    case 13534:
      return KEYDeclaration;
    case 4242:
      return KEYBlock;
    case 13635:
      return KEYMatch;
    case 7373:
      return KEYDirection;
    case 7474:
    case 7575:
    case 7676:
      return KEYDefault;
    case 2626:
    case 2627:
    case 2628:
      return KEYUnits;
    case 2727:
    case 2728:
    case 2729:
      return KEYDeclarations;
    case 2828:
    case 2829:
    case 2830:
      return KEYMatches;
    case 2929:
    case 2930:
    case 2931:
      return KEYTypes;
    case 3030:
    case 3031:
    case 3032:
      return KEYExpressions;
    case 3131:
    case 3132:
    case 3133:
      return KEYPatterns;
    case 3232:
    case 3233:
    case 3234:
      return KEYActuals;
    case 3333:
    case 3334:
    case 3335:
      return KEYTypeActuals;
    case 3434:
    case 3435:
    case 3436:
      return KEYPatternActuals;
  }
}

/* Phyla, constructors and accessors */

enum KEYTYPE_Signature Signature_KEY(Signature _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Signature");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Signature",
                         _node,((TNODE)_node)->operator);
    case 10201: return KEYsig_use;
    case 10302: return KEYsig_inst;
    case 10403: return KEYno_sig;
    case 10908: return KEYmult_sig;
    case 10807: return KEYfixed_sig;
 }
}
char *Signature_constructors[] = {
  "sig_use",
  "sig_inst",
  "no_sig",
  "mult_sig",
  "fixed_sig",
  0};

Signature copy_Signature(Signature _node) {
  switch (Signature_KEY(_node)) {
    case KEYsig_use:
      return sig_use(
        copy_Use(sig_use_use(_node)));
    case KEYsig_inst:
      return sig_inst(
        copy_Boolean(sig_inst_is_input(_node)),
        copy_Boolean(sig_inst_is_var(_node)),
        copy_Class(sig_inst_class(_node)),
        copy_TypeActuals(sig_inst_actuals(_node)));
    case KEYno_sig:
      return no_sig();
    case KEYmult_sig:
      return mult_sig(
        copy_Signature(mult_sig_sig1(_node)),
        copy_Signature(mult_sig_sig2(_node)));
    case KEYfixed_sig:
      return fixed_sig(
        copy_Types(fixed_sig_types(_node)));
  }
  abort();
}

void assert_Signature(Signature _node) {
  (void)Signature_KEY(_node);
}

enum KEYTYPE_Type Type_KEY(Type _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Type");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Type",
                         _node,((TNODE)_node)->operator);
    case 9595: return KEYtype_use;
    case 9696: return KEYtype_inst;
    case 9797: return KEYno_type;
    case 11009: return KEYremote_type;
    case 11312: return KEYprivate_type;
    case 11110: return KEYfunction_type;
 }
}
char *Type_constructors[] = {
  "type_use",
  "type_inst",
  "no_type",
  "remote_type",
  "private_type",
  "function_type",
  0};

Type copy_Type(Type _node) {
  switch (Type_KEY(_node)) {
    case KEYtype_use:
      return type_use(
        copy_Use(type_use_use(_node)));
    case KEYtype_inst:
      return type_inst(
        copy_Module(type_inst_module(_node)),
        copy_TypeActuals(type_inst_type_actuals(_node)),
        copy_Actuals(type_inst_actuals(_node)));
    case KEYno_type:
      return no_type();
    case KEYremote_type:
      return remote_type(
        copy_Type(remote_type_nodetype(_node)));
    case KEYprivate_type:
      return private_type(
        copy_Type(private_type_rep(_node)));
    case KEYfunction_type:
      return function_type(
        copy_Declarations(function_type_formals(_node)),
        copy_Declarations(function_type_return_values(_node)));
  }
  abort();
}

void assert_Type(Type _node) {
  (void)Type_KEY(_node);
}

enum KEYTYPE_Expression Expression_KEY(Expression _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Expression");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Expression",
                         _node,((TNODE)_node)->operator);
    case 9898: return KEYvalue_use;
    case 10100: return KEYtyped_value;
    case 13736: return KEYinteger_const;
    case 13837: return KEYreal_const;
    case 13938: return KEYstring_const;
    case 14039: return KEYchar_const;
    case 14140: return KEYundefined;
    case 14241: return KEYno_expr;
    case 14342: return KEYfuncall;
    case 14443: return KEYappend;
    case 14544: return KEYempty;
    case 14645: return KEYclass_value;
    case 14746: return KEYmodule_value;
    case 14847: return KEYsignature_value;
    case 14948: return KEYtype_value;
    case 15049: return KEYpattern_value;
    case 15150: return KEYrepeat;
    case 15352: return KEYcontrolled;
    case 15251: return KEYguarded;
 }
}
char *Expression_constructors[] = {
  "value_use",
  "typed_value",
  "integer_const",
  "real_const",
  "string_const",
  "char_const",
  "undefined",
  "no_expr",
  "funcall",
  "append",
  "empty",
  "class_value",
  "module_value",
  "signature_value",
  "type_value",
  "pattern_value",
  "repeat",
  "controlled",
  "guarded",
  0};

Expression copy_Expression(Expression _node) {
  switch (Expression_KEY(_node)) {
    case KEYvalue_use:
      return value_use(
        copy_Use(value_use_use(_node)));
    case KEYtyped_value:
      return typed_value(
        copy_Expression(typed_value_expr(_node)),
        copy_Type(typed_value_type(_node)));
    case KEYinteger_const:
      return integer_const(
        copy_String(integer_const_token(_node)));
    case KEYreal_const:
      return real_const(
        copy_String(real_const_token(_node)));
    case KEYstring_const:
      return string_const(
        copy_String(string_const_token(_node)));
    case KEYchar_const:
      return char_const(
        copy_String(char_const_token(_node)));
    case KEYundefined:
      return undefined();
    case KEYno_expr:
      return no_expr();
    case KEYfuncall:
      return funcall(
        copy_Expression(funcall_f(_node)),
        copy_Actuals(funcall_actuals(_node)));
    case KEYappend:
      return append(
        copy_Expression(append_s1(_node)),
        copy_Expression(append_s2(_node)));
    case KEYempty:
      return empty();
    case KEYclass_value:
      return class_value(
        copy_Class(class_value_c(_node)));
    case KEYmodule_value:
      return module_value(
        copy_Module(module_value_m(_node)));
    case KEYsignature_value:
      return signature_value(
        copy_Signature(signature_value_s(_node)));
    case KEYtype_value:
      return type_value(
        copy_Type(type_value_T(_node)));
    case KEYpattern_value:
      return pattern_value(
        copy_Pattern(pattern_value_p(_node)));
    case KEYrepeat:
      return repeat(
        copy_Expression(repeat_expr(_node)));
    case KEYcontrolled:
      return controlled(
        copy_Expression(controlled_expr(_node)),
        copy_Declaration(controlled_formal(_node)),
        copy_Expression(controlled_set(_node)));
    case KEYguarded:
      return guarded(
        copy_Expression(guarded_expr(_node)),
        copy_Expression(guarded_cond(_node)));
  }
  abort();
}

void assert_Expression(Expression _node) {
  (void)Expression_KEY(_node);
}

enum KEYTYPE_Pattern Pattern_KEY(Pattern _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Pattern");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Pattern",
                         _node,((TNODE)_node)->operator);
    case 10504: return KEYpattern_use;
    case 10605: return KEYno_pattern;
    case 10706: return KEYtyped_pattern;
    case 11413: return KEYmatch_pattern;
    case 11514: return KEYpattern_call;
    case 11615: return KEYpattern_actual;
    case 11716: return KEYrest_pattern;
    case 11817: return KEYchoice_pattern;
    case 11918: return KEYand_pattern;
    case 12019: return KEYpattern_var;
    case 12120: return KEYcondition;
    case 12322: return KEYpattern_function;
    case 12221: return KEYhole;
 }
}
char *Pattern_constructors[] = {
  "pattern_use",
  "no_pattern",
  "typed_pattern",
  "match_pattern",
  "pattern_call",
  "pattern_actual",
  "rest_pattern",
  "choice_pattern",
  "and_pattern",
  "pattern_var",
  "condition",
  "pattern_function",
  "hole",
  0};

Pattern copy_Pattern(Pattern _node) {
  switch (Pattern_KEY(_node)) {
    case KEYpattern_use:
      return pattern_use(
        copy_Use(pattern_use_use(_node)));
    case KEYno_pattern:
      return no_pattern();
    case KEYtyped_pattern:
      return typed_pattern(
        copy_Pattern(typed_pattern_pat(_node)),
        copy_Type(typed_pattern_type(_node)));
    case KEYmatch_pattern:
      return match_pattern(
        copy_Pattern(match_pattern_pat(_node)),
        copy_Type(match_pattern_type(_node)));
    case KEYpattern_call:
      return pattern_call(
        copy_Pattern(pattern_call_func(_node)),
        copy_PatternActuals(pattern_call_actuals(_node)));
    case KEYpattern_actual:
      return pattern_actual(
        copy_Pattern(pattern_actual_arg(_node)),
        copy_Expression(pattern_actual_formal(_node)));
    case KEYrest_pattern:
      return rest_pattern(
        copy_Pattern(rest_pattern_constraint(_node)));
    case KEYchoice_pattern:
      return choice_pattern(
        copy_Patterns(choice_pattern_choices(_node)));
    case KEYand_pattern:
      return and_pattern(
        copy_Pattern(and_pattern_p1(_node)),
        copy_Pattern(and_pattern_p2(_node)));
    case KEYpattern_var:
      return pattern_var(
        copy_Declaration(pattern_var_formal(_node)));
    case KEYcondition:
      return condition(
        copy_Expression(condition_e(_node)));
    case KEYpattern_function:
      return pattern_function(
        copy_Declarations(pattern_function_formals(_node)),
        copy_Pattern(pattern_function_body(_node)));
    case KEYhole:
      return hole();
  }
  abort();
}

void assert_Pattern(Pattern _node) {
  (void)Pattern_KEY(_node);
}

enum KEYTYPE_Module Module_KEY(Module _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Module");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Module",
                         _node,((TNODE)_node)->operator);
    case 9494: return KEYmodule_use;
 }
}
char *Module_constructors[] = {
  "module_use",
  0};

Module copy_Module(Module _node) {
  switch (Module_KEY(_node)) {
    case KEYmodule_use:
      return module_use(
        copy_Use(module_use_use(_node)));
  }
  abort();
}

void assert_Module(Module _node) {
  (void)Module_KEY(_node);
}

enum KEYTYPE_Class Class_KEY(Class _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Class");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Class",
                         _node,((TNODE)_node)->operator);
    case 9393: return KEYclass_use;
 }
}
char *Class_constructors[] = {
  "class_use",
  0};

Class copy_Class(Class _node) {
  switch (Class_KEY(_node)) {
    case KEYclass_use:
      return class_use(
        copy_Use(class_use_use(_node)));
  }
  abort();
}

void assert_Class(Class _node) {
  (void)Class_KEY(_node);
}

enum KEYTYPE_Def Def_KEY(Def _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Def");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Def",
                         _node,((TNODE)_node)->operator);
    case 8383: return KEYdef;
 }
}
char *Def_constructors[] = {
  "def",
  0};

Def copy_Def(Def _node) {
  switch (Def_KEY(_node)) {
    case KEYdef:
      return def(
        copy_Symbol(def_name(_node)),
        copy_Boolean(def_is_constant(_node)),
        copy_Boolean(def_is_public(_node)));
  }
  abort();
}

void assert_Def(Def _node) {
  (void)Def_KEY(_node);
}

enum KEYTYPE_Use Use_KEY(Use _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Use");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Use",
                         _node,((TNODE)_node)->operator);
    case 8585: return KEYqual_use;
    case 8484: return KEYuse;
 }
}
char *Use_constructors[] = {
  "qual_use",
  "use",
  0};

Use copy_Use(Use _node) {
  switch (Use_KEY(_node)) {
    case KEYqual_use:
      return qual_use(
        copy_Type(qual_use_from(_node)),
        copy_Symbol(qual_use_name(_node)));
    case KEYuse:
      return use(
        copy_Symbol(use_name(_node)));
  }
  abort();
}

void assert_Use(Use _node) {
  (void)Use_KEY(_node);
}

enum KEYTYPE_Program Program_KEY(Program _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Program");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Program",
                         _node,((TNODE)_node)->operator);
    case 3737: return KEYprogram;
 }
}
char *Program_constructors[] = {
  "program",
  0};

Program copy_Program(Program _node) {
  switch (Program_KEY(_node)) {
    case KEYprogram:
      return program(
        copy_String(program_name(_node)),
        copy_Units(program_units(_node)));
  }
  abort();
}

void assert_Program(Program _node) {
  (void)Program_KEY(_node);
}

enum KEYTYPE_Unit Unit_KEY(Unit _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Unit");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Unit",
                         _node,((TNODE)_node)->operator);
    case 3838: return KEYno_unit;
    case 4040: return KEYdecl_unit;
    case 3939: return KEYwith_unit;
 }
}
char *Unit_constructors[] = {
  "no_unit",
  "decl_unit",
  "with_unit",
  0};

Unit copy_Unit(Unit _node) {
  switch (Unit_KEY(_node)) {
    case KEYno_unit:
      return no_unit();
    case KEYdecl_unit:
      return decl_unit(
        copy_Declaration(decl_unit_decl(_node)));
    case KEYwith_unit:
      return with_unit(
        copy_String(with_unit_name(_node)));
  }
  abort();
}

void assert_Unit(Unit _node) {
  (void)Unit_KEY(_node);
}

enum KEYTYPE_Declaration Declaration_KEY(Declaration _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Declaration");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Declaration",
                         _node,((TNODE)_node)->operator);
    case 4141: return KEYno_decl;
    case 4343: return KEYclass_decl;
    case 4444: return KEYmodule_decl;
    case 4545: return KEYsignature_decl;
    case 4646: return KEYphylum_decl;
    case 4747: return KEYtype_decl;
    case 4848: return KEYvalue_decl;
    case 4949: return KEYattribute_decl;
    case 5050: return KEYfunction_decl;
    case 5151: return KEYprocedure_decl;
    case 5252: return KEYconstructor_decl;
    case 5353: return KEYpattern_decl;
    case 5454: return KEYinheritance;
    case 5555: return KEYpolymorphic;
    case 5656: return KEYpragma_call;
    case 5757: return KEYtop_level_match;
    case 5858: return KEYclass_replacement;
    case 5959: return KEYmodule_replacement;
    case 6060: return KEYsignature_replacement;
    case 6161: return KEYtype_replacement;
    case 6262: return KEYvalue_replacement;
    case 6363: return KEYpattern_replacement;
    case 6464: return KEYclass_renaming;
    case 6565: return KEYmodule_renaming;
    case 6666: return KEYsignature_renaming;
    case 6767: return KEYtype_renaming;
    case 6868: return KEYvalue_renaming;
    case 6969: return KEYpattern_renaming;
    case 7777: return KEYnormal_formal;
    case 7878: return KEYseq_formal;
    case 8080: return KEYtype_formal;
    case 8181: return KEYphylum_formal;
    case 12423: return KEYblock_stmt;
    case 12524: return KEYeffect;
    case 12625: return KEYmulti_call;
    case 12928: return KEYnormal_assign;
    case 13029: return KEYcollect_assign;
    case 13231: return KEYif_stmt;
    case 13332: return KEYfor_in_stmt;
    case 13534: return KEYcase_stmt;
    case 13433: return KEYfor_stmt;
 }
}
char *Declaration_constructors[] = {
  "no_decl",
  "class_decl",
  "module_decl",
  "signature_decl",
  "phylum_decl",
  "type_decl",
  "value_decl",
  "attribute_decl",
  "function_decl",
  "procedure_decl",
  "constructor_decl",
  "pattern_decl",
  "inheritance",
  "polymorphic",
  "pragma_call",
  "top_level_match",
  "class_replacement",
  "module_replacement",
  "signature_replacement",
  "type_replacement",
  "value_replacement",
  "pattern_replacement",
  "class_renaming",
  "module_renaming",
  "signature_renaming",
  "type_renaming",
  "value_renaming",
  "pattern_renaming",
  "normal_formal",
  "seq_formal",
  "type_formal",
  "phylum_formal",
  "block_stmt",
  "effect",
  "multi_call",
  "normal_assign",
  "collect_assign",
  "if_stmt",
  "for_in_stmt",
  "case_stmt",
  "for_stmt",
  0};

Declaration copy_Declaration(Declaration _node) {
  switch (Declaration_KEY(_node)) {
    case KEYno_decl:
      return no_decl();
    case KEYclass_decl:
      return class_decl(
        copy_Def(class_decl_def(_node)),
        copy_Declarations(class_decl_type_formals(_node)),
        copy_Declaration(class_decl_result_type(_node)),
        copy_Signature(class_decl_parent(_node)),
        copy_Block(class_decl_contents(_node)));
    case KEYmodule_decl:
      return module_decl(
        copy_Def(module_decl_def(_node)),
        copy_Declarations(module_decl_type_formals(_node)),
        copy_Declarations(module_decl_value_formals(_node)),
        copy_Declaration(module_decl_result_type(_node)),
        copy_Signature(module_decl_parent(_node)),
        copy_Block(module_decl_contents(_node)));
    case KEYsignature_decl:
      return signature_decl(
        copy_Def(signature_decl_def(_node)),
        copy_Signature(signature_decl_sig(_node)));
    case KEYphylum_decl:
      return phylum_decl(
        copy_Def(phylum_decl_def(_node)),
        copy_Signature(phylum_decl_sig(_node)),
        copy_Type(phylum_decl_type(_node)));
    case KEYtype_decl:
      return type_decl(
        copy_Def(type_decl_def(_node)),
        copy_Signature(type_decl_sig(_node)),
        copy_Type(type_decl_type(_node)));
    case KEYvalue_decl:
      return value_decl(
        copy_Def(value_decl_def(_node)),
        copy_Type(value_decl_type(_node)),
        copy_Direction(value_decl_direction(_node)),
        copy_Default(value_decl_default(_node)));
    case KEYattribute_decl:
      return attribute_decl(
        copy_Def(attribute_decl_def(_node)),
        copy_Type(attribute_decl_type(_node)),
        copy_Direction(attribute_decl_direction(_node)),
        copy_Default(attribute_decl_default(_node)));
    case KEYfunction_decl:
      return function_decl(
        copy_Def(function_decl_def(_node)),
        copy_Type(function_decl_type(_node)),
        copy_Block(function_decl_body(_node)));
    case KEYprocedure_decl:
      return procedure_decl(
        copy_Def(procedure_decl_def(_node)),
        copy_Type(procedure_decl_type(_node)),
        copy_Block(procedure_decl_body(_node)));
    case KEYconstructor_decl:
      return constructor_decl(
        copy_Def(constructor_decl_def(_node)),
        copy_Type(constructor_decl_type(_node)));
    case KEYpattern_decl:
      return pattern_decl(
        copy_Def(pattern_decl_def(_node)),
        copy_Type(pattern_decl_type(_node)),
        copy_Pattern(pattern_decl_choices(_node)));
    case KEYinheritance:
      return inheritance(
        copy_Def(inheritance_def(_node)),
        copy_Type(inheritance_used(_node)),
        copy_Block(inheritance_body(_node)));
    case KEYpolymorphic:
      return polymorphic(
        copy_Def(polymorphic_def(_node)),
        copy_Declarations(polymorphic_type_formals(_node)),
        copy_Block(polymorphic_body(_node)));
    case KEYpragma_call:
      return pragma_call(
        copy_Symbol(pragma_call_name(_node)),
        copy_Expressions(pragma_call_parameters(_node)));
    case KEYtop_level_match:
      return top_level_match(
        copy_Match(top_level_match_m(_node)));
    case KEYclass_replacement:
      return class_replacement(
        copy_Class(class_replacement_class(_node)),
        copy_Class(class_replacement_as(_node)));
    case KEYmodule_replacement:
      return module_replacement(
        copy_Module(module_replacement_module(_node)),
        copy_Module(module_replacement_as(_node)));
    case KEYsignature_replacement:
      return signature_replacement(
        copy_Signature(signature_replacement_sig(_node)),
        copy_Signature(signature_replacement_as(_node)));
    case KEYtype_replacement:
      return type_replacement(
        copy_Type(type_replacement_type(_node)),
        copy_Type(type_replacement_as(_node)));
    case KEYvalue_replacement:
      return value_replacement(
        copy_Expression(value_replacement_value(_node)),
        copy_Expression(value_replacement_as(_node)));
    case KEYpattern_replacement:
      return pattern_replacement(
        copy_Pattern(pattern_replacement_pattern(_node)),
        copy_Pattern(pattern_replacement_as(_node)));
    case KEYclass_renaming:
      return class_renaming(
        copy_Def(class_renaming_def(_node)),
        copy_Class(class_renaming_old(_node)));
    case KEYmodule_renaming:
      return module_renaming(
        copy_Def(module_renaming_def(_node)),
        copy_Module(module_renaming_old(_node)));
    case KEYsignature_renaming:
      return signature_renaming(
        copy_Def(signature_renaming_def(_node)),
        copy_Signature(signature_renaming_old(_node)));
    case KEYtype_renaming:
      return type_renaming(
        copy_Def(type_renaming_def(_node)),
        copy_Type(type_renaming_old(_node)));
    case KEYvalue_renaming:
      return value_renaming(
        copy_Def(value_renaming_def(_node)),
        copy_Expression(value_renaming_old(_node)));
    case KEYpattern_renaming:
      return pattern_renaming(
        copy_Def(pattern_renaming_def(_node)),
        copy_Pattern(pattern_renaming_old(_node)));
    case KEYnormal_formal:
      return normal_formal(
        copy_Def(normal_formal_def(_node)),
        copy_Type(normal_formal_type(_node)));
    case KEYseq_formal:
      return seq_formal(
        copy_Def(seq_formal_def(_node)),
        copy_Type(seq_formal_type(_node)));
    case KEYtype_formal:
      return type_formal(
        copy_Def(type_formal_def(_node)),
        copy_Signature(type_formal_sig(_node)));
    case KEYphylum_formal:
      return phylum_formal(
        copy_Def(phylum_formal_def(_node)),
        copy_Signature(phylum_formal_sig(_node)));
    case KEYblock_stmt:
      return block_stmt(
        copy_Block(block_stmt_body(_node)));
    case KEYeffect:
      return effect(
        copy_Expression(effect_e(_node)));
    case KEYmulti_call:
      return multi_call(
        copy_Expression(multi_call_proc(_node)),
        copy_Actuals(multi_call_actuals(_node)),
        copy_Actuals(multi_call_results(_node)));
    case KEYnormal_assign:
      return normal_assign(
        copy_Expression(normal_assign_lhs(_node)),
        copy_Expression(normal_assign_rhs(_node)));
    case KEYcollect_assign:
      return collect_assign(
        copy_Expression(collect_assign_lhs(_node)),
        copy_Expression(collect_assign_rhs(_node)));
    case KEYif_stmt:
      return if_stmt(
        copy_Expression(if_stmt_cond(_node)),
        copy_Block(if_stmt_if_true(_node)),
        copy_Block(if_stmt_if_false(_node)));
    case KEYfor_in_stmt:
      return for_in_stmt(
        copy_Declaration(for_in_stmt_formal(_node)),
        copy_Expression(for_in_stmt_seq(_node)),
        copy_Block(for_in_stmt_body(_node)));
    case KEYcase_stmt:
      return case_stmt(
        copy_Expression(case_stmt_expr(_node)),
        copy_Matches(case_stmt_matchers(_node)),
        copy_Block(case_stmt_default(_node)));
    case KEYfor_stmt:
      return for_stmt(
        copy_Expression(for_stmt_expr(_node)),
        copy_Matches(for_stmt_matchers(_node)));
  }
  abort();
}

void assert_Declaration(Declaration _node) {
  (void)Declaration_KEY(_node);
}

enum KEYTYPE_Block Block_KEY(Block _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Block");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Block",
                         _node,((TNODE)_node)->operator);
    case 4242: return KEYblock;
 }
}
char *Block_constructors[] = {
  "block",
  0};

Block copy_Block(Block _node) {
  switch (Block_KEY(_node)) {
    case KEYblock:
      return block(
        copy_Declarations(block_body(_node)));
  }
  abort();
}

void assert_Block(Block _node) {
  (void)Block_KEY(_node);
}

enum KEYTYPE_Match Match_KEY(Match _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Match");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Match",
                         _node,((TNODE)_node)->operator);
    case 13635: return KEYmatcher;
 }
}
char *Match_constructors[] = {
  "matcher",
  0};

Match copy_Match(Match _node) {
  switch (Match_KEY(_node)) {
    case KEYmatcher:
      return matcher(
        copy_Pattern(matcher_pat(_node)),
        copy_Block(matcher_body(_node)));
  }
  abort();
}

void assert_Match(Match _node) {
  (void)Match_KEY(_node);
}

enum KEYTYPE_Direction Direction_KEY(Direction _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Direction");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Direction",
                         _node,((TNODE)_node)->operator);
    case 7373: return KEYdirection;
 }
}
char *Direction_constructors[] = {
  "direction",
  0};

Direction copy_Direction(Direction _node) {
  switch (Direction_KEY(_node)) {
    case KEYdirection:
      return direction(
        copy_Boolean(direction_is_input(_node)),
        copy_Boolean(direction_is_collection(_node)),
        copy_Boolean(direction_is_circular(_node)));
  }
  abort();
}

void assert_Direction(Direction _node) {
  (void)Direction_KEY(_node);
}

enum KEYTYPE_Default Default_KEY(Default _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Default");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Default",
                         _node,((TNODE)_node)->operator);
    case 7474: return KEYsimple;
    case 7676: return KEYno_default;
    case 7575: return KEYcomposite;
 }
}
char *Default_constructors[] = {
  "simple",
  "no_default",
  "composite",
  0};

Default copy_Default(Default _node) {
  switch (Default_KEY(_node)) {
    case KEYsimple:
      return simple(
        copy_Expression(simple_value(_node)));
    case KEYno_default:
      return no_default();
    case KEYcomposite:
      return composite(
        copy_Expression(composite_initial(_node)),
        copy_Expression(composite_combiner(_node)));
  }
  abort();
}

void assert_Default(Default _node) {
  (void)Default_KEY(_node);
}

enum KEYTYPE_Units Units_KEY(Units _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Units");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Units",
                         _node,((TNODE)_node)->operator);
    case 2626: return KEYnil_Units;
    case 2627: return KEYlist_Units;
    case 2628: return KEYappend_Units;
 }
}
char *Units_constructors[] = {
  "nil_Units",
  "list_Units",
  "append_Units",
  0};


Units copy_Units(Units _node) {
  switch (Units_KEY(_node)) {
    case KEYnil_Units:
      return nil_Units();
    case KEYlist_Units:
      return list_Units(
        copy_Unit(list_Units_elem(_node)));
    case KEYappend_Units:
      return append_Units(
        copy_Units(append_Units_l1(_node)),
        copy_Units(append_Units_l2(_node)));
  }
  abort();
}

void assert_Units(Units _node) {
  (void)Units_KEY(_node);
}

/* Constructor function */
Units nil_Units(){
  TNODE _node = create_tnode(2626,0);
  return (Units)_node;
}
/* Accessors */
/* Constructor function */
Units list_Units(Unit elem){
  TNODE _node = create_tnode(2627,1);
  assert_Unit(elem);
  _node->children[0] = (void *)elem;
  return (Units)_node;
}
/* Accessors */
Unit list_Units_elem(Units _node){
  if (Units_KEY(_node) != KEYlist_Units) {
    fatal_error("list_Units_elem: called with %s",
                Units_constructors[Units_KEY(_node)]);
  }
  return (Unit)((TNODE)_node)->children[0];
}

/* Constructor function */
Units append_Units(Units l1,Units l2){
  TNODE _node = create_tnode(2628,2);
  assert_Units(l1);
  _node->children[0] = (void *)l1;
  assert_Units(l2);
  _node->children[1] = (void *)l2;
  return (Units)_node;
}
/* Accessors */
Units append_Units_l1(Units _node){
  if (Units_KEY(_node) != KEYappend_Units) {
    fatal_error("append_Units_l1: called with %s",
                Units_constructors[Units_KEY(_node)]);
  }
  return (Units)((TNODE)_node)->children[0];
}
Units append_Units_l2(Units _node){
  if (Units_KEY(_node) != KEYappend_Units) {
    fatal_error("append_Units_l2: called with %s",
                Units_constructors[Units_KEY(_node)]);
  }
  return (Units)((TNODE)_node)->children[1];
}

enum KEYTYPE_Declarations Declarations_KEY(Declarations _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Declarations");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Declarations",
                         _node,((TNODE)_node)->operator);
    case 2727: return KEYnil_Declarations;
    case 2728: return KEYlist_Declarations;
    case 2729: return KEYappend_Declarations;
 }
}
char *Declarations_constructors[] = {
  "nil_Declarations",
  "list_Declarations",
  "append_Declarations",
  0};


Declarations copy_Declarations(Declarations _node) {
  switch (Declarations_KEY(_node)) {
    case KEYnil_Declarations:
      return nil_Declarations();
    case KEYlist_Declarations:
      return list_Declarations(
        copy_Declaration(list_Declarations_elem(_node)));
    case KEYappend_Declarations:
      return append_Declarations(
        copy_Declarations(append_Declarations_l1(_node)),
        copy_Declarations(append_Declarations_l2(_node)));
  }
  abort();
}

void assert_Declarations(Declarations _node) {
  (void)Declarations_KEY(_node);
}

/* Constructor function */
Declarations nil_Declarations(){
  TNODE _node = create_tnode(2727,0);
  return (Declarations)_node;
}
/* Accessors */
/* Constructor function */
Declarations list_Declarations(Declaration elem){
  TNODE _node = create_tnode(2728,1);
  assert_Declaration(elem);
  _node->children[0] = (void *)elem;
  return (Declarations)_node;
}
/* Accessors */
Declaration list_Declarations_elem(Declarations _node){
  if (Declarations_KEY(_node) != KEYlist_Declarations) {
    fatal_error("list_Declarations_elem: called with %s",
                Declarations_constructors[Declarations_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[0];
}

/* Constructor function */
Declarations append_Declarations(Declarations l1,Declarations l2){
  TNODE _node = create_tnode(2729,2);
  assert_Declarations(l1);
  _node->children[0] = (void *)l1;
  assert_Declarations(l2);
  _node->children[1] = (void *)l2;
  return (Declarations)_node;
}
/* Accessors */
Declarations append_Declarations_l1(Declarations _node){
  if (Declarations_KEY(_node) != KEYappend_Declarations) {
    fatal_error("append_Declarations_l1: called with %s",
                Declarations_constructors[Declarations_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[0];
}
Declarations append_Declarations_l2(Declarations _node){
  if (Declarations_KEY(_node) != KEYappend_Declarations) {
    fatal_error("append_Declarations_l2: called with %s",
                Declarations_constructors[Declarations_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[1];
}

enum KEYTYPE_Matches Matches_KEY(Matches _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Matches");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Matches",
                         _node,((TNODE)_node)->operator);
    case 2828: return KEYnil_Matches;
    case 2829: return KEYlist_Matches;
    case 2830: return KEYappend_Matches;
 }
}
char *Matches_constructors[] = {
  "nil_Matches",
  "list_Matches",
  "append_Matches",
  0};


Matches copy_Matches(Matches _node) {
  switch (Matches_KEY(_node)) {
    case KEYnil_Matches:
      return nil_Matches();
    case KEYlist_Matches:
      return list_Matches(
        copy_Match(list_Matches_elem(_node)));
    case KEYappend_Matches:
      return append_Matches(
        copy_Matches(append_Matches_l1(_node)),
        copy_Matches(append_Matches_l2(_node)));
  }
  abort();
}

void assert_Matches(Matches _node) {
  (void)Matches_KEY(_node);
}

/* Constructor function */
Matches nil_Matches(){
  TNODE _node = create_tnode(2828,0);
  return (Matches)_node;
}
/* Accessors */
/* Constructor function */
Matches list_Matches(Match elem){
  TNODE _node = create_tnode(2829,1);
  assert_Match(elem);
  _node->children[0] = (void *)elem;
  return (Matches)_node;
}
/* Accessors */
Match list_Matches_elem(Matches _node){
  if (Matches_KEY(_node) != KEYlist_Matches) {
    fatal_error("list_Matches_elem: called with %s",
                Matches_constructors[Matches_KEY(_node)]);
  }
  return (Match)((TNODE)_node)->children[0];
}

/* Constructor function */
Matches append_Matches(Matches l1,Matches l2){
  TNODE _node = create_tnode(2830,2);
  assert_Matches(l1);
  _node->children[0] = (void *)l1;
  assert_Matches(l2);
  _node->children[1] = (void *)l2;
  return (Matches)_node;
}
/* Accessors */
Matches append_Matches_l1(Matches _node){
  if (Matches_KEY(_node) != KEYappend_Matches) {
    fatal_error("append_Matches_l1: called with %s",
                Matches_constructors[Matches_KEY(_node)]);
  }
  return (Matches)((TNODE)_node)->children[0];
}
Matches append_Matches_l2(Matches _node){
  if (Matches_KEY(_node) != KEYappend_Matches) {
    fatal_error("append_Matches_l2: called with %s",
                Matches_constructors[Matches_KEY(_node)]);
  }
  return (Matches)((TNODE)_node)->children[1];
}

enum KEYTYPE_Types Types_KEY(Types _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Types");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Types",
                         _node,((TNODE)_node)->operator);
    case 2929: return KEYnil_Types;
    case 2930: return KEYlist_Types;
    case 2931: return KEYappend_Types;
 }
}
char *Types_constructors[] = {
  "nil_Types",
  "list_Types",
  "append_Types",
  0};


Types copy_Types(Types _node) {
  switch (Types_KEY(_node)) {
    case KEYnil_Types:
      return nil_Types();
    case KEYlist_Types:
      return list_Types(
        copy_Type(list_Types_elem(_node)));
    case KEYappend_Types:
      return append_Types(
        copy_Types(append_Types_l1(_node)),
        copy_Types(append_Types_l2(_node)));
  }
  abort();
}

void assert_Types(Types _node) {
  (void)Types_KEY(_node);
}

/* Constructor function */
Types nil_Types(){
  TNODE _node = create_tnode(2929,0);
  return (Types)_node;
}
/* Accessors */
/* Constructor function */
Types list_Types(Type elem){
  TNODE _node = create_tnode(2930,1);
  assert_Type(elem);
  _node->children[0] = (void *)elem;
  return (Types)_node;
}
/* Accessors */
Type list_Types_elem(Types _node){
  if (Types_KEY(_node) != KEYlist_Types) {
    fatal_error("list_Types_elem: called with %s",
                Types_constructors[Types_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}

/* Constructor function */
Types append_Types(Types l1,Types l2){
  TNODE _node = create_tnode(2931,2);
  assert_Types(l1);
  _node->children[0] = (void *)l1;
  assert_Types(l2);
  _node->children[1] = (void *)l2;
  return (Types)_node;
}
/* Accessors */
Types append_Types_l1(Types _node){
  if (Types_KEY(_node) != KEYappend_Types) {
    fatal_error("append_Types_l1: called with %s",
                Types_constructors[Types_KEY(_node)]);
  }
  return (Types)((TNODE)_node)->children[0];
}
Types append_Types_l2(Types _node){
  if (Types_KEY(_node) != KEYappend_Types) {
    fatal_error("append_Types_l2: called with %s",
                Types_constructors[Types_KEY(_node)]);
  }
  return (Types)((TNODE)_node)->children[1];
}

enum KEYTYPE_Expressions Expressions_KEY(Expressions _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Expressions");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Expressions",
                         _node,((TNODE)_node)->operator);
    case 3030: return KEYnil_Expressions;
    case 3031: return KEYlist_Expressions;
    case 3032: return KEYappend_Expressions;
 }
}
char *Expressions_constructors[] = {
  "nil_Expressions",
  "list_Expressions",
  "append_Expressions",
  0};


Expressions copy_Expressions(Expressions _node) {
  switch (Expressions_KEY(_node)) {
    case KEYnil_Expressions:
      return nil_Expressions();
    case KEYlist_Expressions:
      return list_Expressions(
        copy_Expression(list_Expressions_elem(_node)));
    case KEYappend_Expressions:
      return append_Expressions(
        copy_Expressions(append_Expressions_l1(_node)),
        copy_Expressions(append_Expressions_l2(_node)));
  }
  abort();
}

void assert_Expressions(Expressions _node) {
  (void)Expressions_KEY(_node);
}

/* Constructor function */
Expressions nil_Expressions(){
  TNODE _node = create_tnode(3030,0);
  return (Expressions)_node;
}
/* Accessors */
/* Constructor function */
Expressions list_Expressions(Expression elem){
  TNODE _node = create_tnode(3031,1);
  assert_Expression(elem);
  _node->children[0] = (void *)elem;
  return (Expressions)_node;
}
/* Accessors */
Expression list_Expressions_elem(Expressions _node){
  if (Expressions_KEY(_node) != KEYlist_Expressions) {
    fatal_error("list_Expressions_elem: called with %s",
                Expressions_constructors[Expressions_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Expressions append_Expressions(Expressions l1,Expressions l2){
  TNODE _node = create_tnode(3032,2);
  assert_Expressions(l1);
  _node->children[0] = (void *)l1;
  assert_Expressions(l2);
  _node->children[1] = (void *)l2;
  return (Expressions)_node;
}
/* Accessors */
Expressions append_Expressions_l1(Expressions _node){
  if (Expressions_KEY(_node) != KEYappend_Expressions) {
    fatal_error("append_Expressions_l1: called with %s",
                Expressions_constructors[Expressions_KEY(_node)]);
  }
  return (Expressions)((TNODE)_node)->children[0];
}
Expressions append_Expressions_l2(Expressions _node){
  if (Expressions_KEY(_node) != KEYappend_Expressions) {
    fatal_error("append_Expressions_l2: called with %s",
                Expressions_constructors[Expressions_KEY(_node)]);
  }
  return (Expressions)((TNODE)_node)->children[1];
}

enum KEYTYPE_Patterns Patterns_KEY(Patterns _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Patterns");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Patterns",
                         _node,((TNODE)_node)->operator);
    case 3131: return KEYnil_Patterns;
    case 3132: return KEYlist_Patterns;
    case 3133: return KEYappend_Patterns;
 }
}
char *Patterns_constructors[] = {
  "nil_Patterns",
  "list_Patterns",
  "append_Patterns",
  0};


Patterns copy_Patterns(Patterns _node) {
  switch (Patterns_KEY(_node)) {
    case KEYnil_Patterns:
      return nil_Patterns();
    case KEYlist_Patterns:
      return list_Patterns(
        copy_Pattern(list_Patterns_elem(_node)));
    case KEYappend_Patterns:
      return append_Patterns(
        copy_Patterns(append_Patterns_l1(_node)),
        copy_Patterns(append_Patterns_l2(_node)));
  }
  abort();
}

void assert_Patterns(Patterns _node) {
  (void)Patterns_KEY(_node);
}

/* Constructor function */
Patterns nil_Patterns(){
  TNODE _node = create_tnode(3131,0);
  return (Patterns)_node;
}
/* Accessors */
/* Constructor function */
Patterns list_Patterns(Pattern elem){
  TNODE _node = create_tnode(3132,1);
  assert_Pattern(elem);
  _node->children[0] = (void *)elem;
  return (Patterns)_node;
}
/* Accessors */
Pattern list_Patterns_elem(Patterns _node){
  if (Patterns_KEY(_node) != KEYlist_Patterns) {
    fatal_error("list_Patterns_elem: called with %s",
                Patterns_constructors[Patterns_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}

/* Constructor function */
Patterns append_Patterns(Patterns l1,Patterns l2){
  TNODE _node = create_tnode(3133,2);
  assert_Patterns(l1);
  _node->children[0] = (void *)l1;
  assert_Patterns(l2);
  _node->children[1] = (void *)l2;
  return (Patterns)_node;
}
/* Accessors */
Patterns append_Patterns_l1(Patterns _node){
  if (Patterns_KEY(_node) != KEYappend_Patterns) {
    fatal_error("append_Patterns_l1: called with %s",
                Patterns_constructors[Patterns_KEY(_node)]);
  }
  return (Patterns)((TNODE)_node)->children[0];
}
Patterns append_Patterns_l2(Patterns _node){
  if (Patterns_KEY(_node) != KEYappend_Patterns) {
    fatal_error("append_Patterns_l2: called with %s",
                Patterns_constructors[Patterns_KEY(_node)]);
  }
  return (Patterns)((TNODE)_node)->children[1];
}

enum KEYTYPE_Actuals Actuals_KEY(Actuals _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Actuals");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Actuals",
                         _node,((TNODE)_node)->operator);
    case 3232: return KEYnil_Actuals;
    case 3233: return KEYlist_Actuals;
    case 3234: return KEYappend_Actuals;
 }
}
char *Actuals_constructors[] = {
  "nil_Actuals",
  "list_Actuals",
  "append_Actuals",
  0};


Actuals copy_Actuals(Actuals _node) {
  switch (Actuals_KEY(_node)) {
    case KEYnil_Actuals:
      return nil_Actuals();
    case KEYlist_Actuals:
      return list_Actuals(
        copy_Expression(list_Actuals_elem(_node)));
    case KEYappend_Actuals:
      return append_Actuals(
        copy_Actuals(append_Actuals_l1(_node)),
        copy_Actuals(append_Actuals_l2(_node)));
  }
  abort();
}

void assert_Actuals(Actuals _node) {
  (void)Actuals_KEY(_node);
}

/* Constructor function */
Actuals nil_Actuals(){
  TNODE _node = create_tnode(3232,0);
  return (Actuals)_node;
}
/* Accessors */
/* Constructor function */
Actuals list_Actuals(Expression elem){
  TNODE _node = create_tnode(3233,1);
  assert_Expression(elem);
  _node->children[0] = (void *)elem;
  return (Actuals)_node;
}
/* Accessors */
Expression list_Actuals_elem(Actuals _node){
  if (Actuals_KEY(_node) != KEYlist_Actuals) {
    fatal_error("list_Actuals_elem: called with %s",
                Actuals_constructors[Actuals_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Actuals append_Actuals(Actuals l1,Actuals l2){
  TNODE _node = create_tnode(3234,2);
  assert_Actuals(l1);
  _node->children[0] = (void *)l1;
  assert_Actuals(l2);
  _node->children[1] = (void *)l2;
  return (Actuals)_node;
}
/* Accessors */
Actuals append_Actuals_l1(Actuals _node){
  if (Actuals_KEY(_node) != KEYappend_Actuals) {
    fatal_error("append_Actuals_l1: called with %s",
                Actuals_constructors[Actuals_KEY(_node)]);
  }
  return (Actuals)((TNODE)_node)->children[0];
}
Actuals append_Actuals_l2(Actuals _node){
  if (Actuals_KEY(_node) != KEYappend_Actuals) {
    fatal_error("append_Actuals_l2: called with %s",
                Actuals_constructors[Actuals_KEY(_node)]);
  }
  return (Actuals)((TNODE)_node)->children[1];
}

enum KEYTYPE_TypeActuals TypeActuals_KEY(TypeActuals _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type TypeActuals");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type TypeActuals",
                         _node,((TNODE)_node)->operator);
    case 3333: return KEYnil_TypeActuals;
    case 3334: return KEYlist_TypeActuals;
    case 3335: return KEYappend_TypeActuals;
 }
}
char *TypeActuals_constructors[] = {
  "nil_TypeActuals",
  "list_TypeActuals",
  "append_TypeActuals",
  0};


TypeActuals copy_TypeActuals(TypeActuals _node) {
  switch (TypeActuals_KEY(_node)) {
    case KEYnil_TypeActuals:
      return nil_TypeActuals();
    case KEYlist_TypeActuals:
      return list_TypeActuals(
        copy_Type(list_TypeActuals_elem(_node)));
    case KEYappend_TypeActuals:
      return append_TypeActuals(
        copy_TypeActuals(append_TypeActuals_l1(_node)),
        copy_TypeActuals(append_TypeActuals_l2(_node)));
  }
  abort();
}

void assert_TypeActuals(TypeActuals _node) {
  (void)TypeActuals_KEY(_node);
}

/* Constructor function */
TypeActuals nil_TypeActuals(){
  TNODE _node = create_tnode(3333,0);
  return (TypeActuals)_node;
}
/* Accessors */
/* Constructor function */
TypeActuals list_TypeActuals(Type elem){
  TNODE _node = create_tnode(3334,1);
  assert_Type(elem);
  _node->children[0] = (void *)elem;
  return (TypeActuals)_node;
}
/* Accessors */
Type list_TypeActuals_elem(TypeActuals _node){
  if (TypeActuals_KEY(_node) != KEYlist_TypeActuals) {
    fatal_error("list_TypeActuals_elem: called with %s",
                TypeActuals_constructors[TypeActuals_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}

/* Constructor function */
TypeActuals append_TypeActuals(TypeActuals l1,TypeActuals l2){
  TNODE _node = create_tnode(3335,2);
  assert_TypeActuals(l1);
  _node->children[0] = (void *)l1;
  assert_TypeActuals(l2);
  _node->children[1] = (void *)l2;
  return (TypeActuals)_node;
}
/* Accessors */
TypeActuals append_TypeActuals_l1(TypeActuals _node){
  if (TypeActuals_KEY(_node) != KEYappend_TypeActuals) {
    fatal_error("append_TypeActuals_l1: called with %s",
                TypeActuals_constructors[TypeActuals_KEY(_node)]);
  }
  return (TypeActuals)((TNODE)_node)->children[0];
}
TypeActuals append_TypeActuals_l2(TypeActuals _node){
  if (TypeActuals_KEY(_node) != KEYappend_TypeActuals) {
    fatal_error("append_TypeActuals_l2: called with %s",
                TypeActuals_constructors[TypeActuals_KEY(_node)]);
  }
  return (TypeActuals)((TNODE)_node)->children[1];
}

enum KEYTYPE_PatternActuals PatternActuals_KEY(PatternActuals _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type PatternActuals");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type PatternActuals",
                         _node,((TNODE)_node)->operator);
    case 3434: return KEYnil_PatternActuals;
    case 3435: return KEYlist_PatternActuals;
    case 3436: return KEYappend_PatternActuals;
 }
}
char *PatternActuals_constructors[] = {
  "nil_PatternActuals",
  "list_PatternActuals",
  "append_PatternActuals",
  0};


PatternActuals copy_PatternActuals(PatternActuals _node) {
  switch (PatternActuals_KEY(_node)) {
    case KEYnil_PatternActuals:
      return nil_PatternActuals();
    case KEYlist_PatternActuals:
      return list_PatternActuals(
        copy_Pattern(list_PatternActuals_elem(_node)));
    case KEYappend_PatternActuals:
      return append_PatternActuals(
        copy_PatternActuals(append_PatternActuals_l1(_node)),
        copy_PatternActuals(append_PatternActuals_l2(_node)));
  }
  abort();
}

void assert_PatternActuals(PatternActuals _node) {
  (void)PatternActuals_KEY(_node);
}

/* Constructor function */
PatternActuals nil_PatternActuals(){
  TNODE _node = create_tnode(3434,0);
  return (PatternActuals)_node;
}
/* Accessors */
/* Constructor function */
PatternActuals list_PatternActuals(Pattern elem){
  TNODE _node = create_tnode(3435,1);
  assert_Pattern(elem);
  _node->children[0] = (void *)elem;
  return (PatternActuals)_node;
}
/* Accessors */
Pattern list_PatternActuals_elem(PatternActuals _node){
  if (PatternActuals_KEY(_node) != KEYlist_PatternActuals) {
    fatal_error("list_PatternActuals_elem: called with %s",
                PatternActuals_constructors[PatternActuals_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}

/* Constructor function */
PatternActuals append_PatternActuals(PatternActuals l1,PatternActuals l2){
  TNODE _node = create_tnode(3436,2);
  assert_PatternActuals(l1);
  _node->children[0] = (void *)l1;
  assert_PatternActuals(l2);
  _node->children[1] = (void *)l2;
  return (PatternActuals)_node;
}
/* Accessors */
PatternActuals append_PatternActuals_l1(PatternActuals _node){
  if (PatternActuals_KEY(_node) != KEYappend_PatternActuals) {
    fatal_error("append_PatternActuals_l1: called with %s",
                PatternActuals_constructors[PatternActuals_KEY(_node)]);
  }
  return (PatternActuals)((TNODE)_node)->children[0];
}
PatternActuals append_PatternActuals_l2(PatternActuals _node){
  if (PatternActuals_KEY(_node) != KEYappend_PatternActuals) {
    fatal_error("append_PatternActuals_l2: called with %s",
                PatternActuals_constructors[PatternActuals_KEY(_node)]);
  }
  return (PatternActuals)((TNODE)_node)->children[1];
}

/* Constructor function */
Program program(String name,Units units){
  TNODE _node = create_tnode(3737,2);
  assert_String(name);
  _node->children[0] = (void *)name;
  assert_Units(units);
  _node->children[1] = (void *)units;
  return (Program)_node;
}
/* Accessors */
String program_name(Program _node){
  if (Program_KEY(_node) != KEYprogram) {
    fatal_error("program_name: called with %s",
                Program_constructors[Program_KEY(_node)]);
  }
  return (String)((TNODE)_node)->children[0];
}
Units program_units(Program _node){
  if (Program_KEY(_node) != KEYprogram) {
    fatal_error("program_units: called with %s",
                Program_constructors[Program_KEY(_node)]);
  }
  return (Units)((TNODE)_node)->children[1];
}

/* Constructor function */
Unit no_unit(){
  TNODE _node = create_tnode(3838,0);
  return (Unit)_node;
}
/* Accessors */

/* Constructor function */
Unit with_unit(String name){
  TNODE _node = create_tnode(3939,1);
  assert_String(name);
  _node->children[0] = (void *)name;
  return (Unit)_node;
}
/* Accessors */
String with_unit_name(Unit _node){
  if (Unit_KEY(_node) != KEYwith_unit) {
    fatal_error("with_unit_name: called with %s",
                Unit_constructors[Unit_KEY(_node)]);
  }
  return (String)((TNODE)_node)->children[0];
}

/* Constructor function */
Unit decl_unit(Declaration decl){
  TNODE _node = create_tnode(4040,1);
  assert_Declaration(decl);
  _node->children[0] = (void *)decl;
  return (Unit)_node;
}
/* Accessors */
Declaration decl_unit_decl(Unit _node){
  if (Unit_KEY(_node) != KEYdecl_unit) {
    fatal_error("decl_unit_decl: called with %s",
                Unit_constructors[Unit_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[0];
}

/* Constructor function */
Declaration no_decl(){
  TNODE _node = create_tnode(4141,0);
  return (Declaration)_node;
}
/* Accessors */

/* Constructor function */
Block block(Declarations body){
  TNODE _node = create_tnode(4242,1);
  assert_Declarations(body);
  _node->children[0] = (void *)body;
  return (Block)_node;
}
/* Accessors */
Declarations block_body(Block _node){
  if (Block_KEY(_node) != KEYblock) {
    fatal_error("block_body: called with %s",
                Block_constructors[Block_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[0];
}

/* Constructor function */
Declaration class_decl(Def def,Declarations type_formals,Declaration result_type,Signature parent,Block contents){
  TNODE _node = create_tnode(4343,5);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Declarations(type_formals);
  _node->children[1] = (void *)type_formals;
  assert_Declaration(result_type);
  _node->children[2] = (void *)result_type;
  assert_Signature(parent);
  _node->children[3] = (void *)parent;
  assert_Block(contents);
  _node->children[4] = (void *)contents;
  return (Declaration)_node;
}
/* Accessors */
Def class_decl_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYclass_decl) {
    fatal_error("class_decl_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Declarations class_decl_type_formals(Declaration _node){
  if (Declaration_KEY(_node) != KEYclass_decl) {
    fatal_error("class_decl_type_formals: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[1];
}
Declaration class_decl_result_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYclass_decl) {
    fatal_error("class_decl_result_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[2];
}
Signature class_decl_parent(Declaration _node){
  if (Declaration_KEY(_node) != KEYclass_decl) {
    fatal_error("class_decl_parent: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[3];
}
Block class_decl_contents(Declaration _node){
  if (Declaration_KEY(_node) != KEYclass_decl) {
    fatal_error("class_decl_contents: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Block)((TNODE)_node)->children[4];
}

/* Constructor function */
Declaration module_decl(Def def,Declarations type_formals,Declarations value_formals,Declaration result_type,Signature parent,Block contents){
  TNODE _node = create_tnode(4444,6);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Declarations(type_formals);
  _node->children[1] = (void *)type_formals;
  assert_Declarations(value_formals);
  _node->children[2] = (void *)value_formals;
  assert_Declaration(result_type);
  _node->children[3] = (void *)result_type;
  assert_Signature(parent);
  _node->children[4] = (void *)parent;
  assert_Block(contents);
  _node->children[5] = (void *)contents;
  return (Declaration)_node;
}
/* Accessors */
Def module_decl_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_decl) {
    fatal_error("module_decl_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Declarations module_decl_type_formals(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_decl) {
    fatal_error("module_decl_type_formals: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[1];
}
Declarations module_decl_value_formals(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_decl) {
    fatal_error("module_decl_value_formals: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[2];
}
Declaration module_decl_result_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_decl) {
    fatal_error("module_decl_result_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[3];
}
Signature module_decl_parent(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_decl) {
    fatal_error("module_decl_parent: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[4];
}
Block module_decl_contents(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_decl) {
    fatal_error("module_decl_contents: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Block)((TNODE)_node)->children[5];
}

/* Constructor function */
Declaration signature_decl(Def def,Signature sig){
  TNODE _node = create_tnode(4545,2);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Signature(sig);
  _node->children[1] = (void *)sig;
  return (Declaration)_node;
}
/* Accessors */
Def signature_decl_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYsignature_decl) {
    fatal_error("signature_decl_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Signature signature_decl_sig(Declaration _node){
  if (Declaration_KEY(_node) != KEYsignature_decl) {
    fatal_error("signature_decl_sig: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration phylum_decl(Def def,Signature sig,Type type){
  TNODE _node = create_tnode(4646,3);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Signature(sig);
  _node->children[1] = (void *)sig;
  assert_Type(type);
  _node->children[2] = (void *)type;
  return (Declaration)_node;
}
/* Accessors */
Def phylum_decl_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYphylum_decl) {
    fatal_error("phylum_decl_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Signature phylum_decl_sig(Declaration _node){
  if (Declaration_KEY(_node) != KEYphylum_decl) {
    fatal_error("phylum_decl_sig: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[1];
}
Type phylum_decl_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYphylum_decl) {
    fatal_error("phylum_decl_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration type_decl(Def def,Signature sig,Type type){
  TNODE _node = create_tnode(4747,3);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Signature(sig);
  _node->children[1] = (void *)sig;
  assert_Type(type);
  _node->children[2] = (void *)type;
  return (Declaration)_node;
}
/* Accessors */
Def type_decl_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYtype_decl) {
    fatal_error("type_decl_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Signature type_decl_sig(Declaration _node){
  if (Declaration_KEY(_node) != KEYtype_decl) {
    fatal_error("type_decl_sig: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[1];
}
Type type_decl_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYtype_decl) {
    fatal_error("type_decl_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration value_decl(Def def,Type type,Direction direction,Default default_){
  TNODE _node = create_tnode(4848,4);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Type(type);
  _node->children[1] = (void *)type;
  assert_Direction(direction);
  _node->children[2] = (void *)direction;
  assert_Default(default_);
  _node->children[3] = (void *)default_;
  return (Declaration)_node;
}
/* Accessors */
Def value_decl_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYvalue_decl) {
    fatal_error("value_decl_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Type value_decl_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYvalue_decl) {
    fatal_error("value_decl_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}
Direction value_decl_direction(Declaration _node){
  if (Declaration_KEY(_node) != KEYvalue_decl) {
    fatal_error("value_decl_direction: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Direction)((TNODE)_node)->children[2];
}
Default value_decl_default(Declaration _node){
  if (Declaration_KEY(_node) != KEYvalue_decl) {
    fatal_error("value_decl_default: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Default)((TNODE)_node)->children[3];
}

/* Constructor function */
Declaration attribute_decl(Def def,Type type,Direction direction,Default default_){
  TNODE _node = create_tnode(4949,4);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Type(type);
  _node->children[1] = (void *)type;
  assert_Direction(direction);
  _node->children[2] = (void *)direction;
  assert_Default(default_);
  _node->children[3] = (void *)default_;
  return (Declaration)_node;
}
/* Accessors */
Def attribute_decl_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYattribute_decl) {
    fatal_error("attribute_decl_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Type attribute_decl_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYattribute_decl) {
    fatal_error("attribute_decl_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}
Direction attribute_decl_direction(Declaration _node){
  if (Declaration_KEY(_node) != KEYattribute_decl) {
    fatal_error("attribute_decl_direction: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Direction)((TNODE)_node)->children[2];
}
Default attribute_decl_default(Declaration _node){
  if (Declaration_KEY(_node) != KEYattribute_decl) {
    fatal_error("attribute_decl_default: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Default)((TNODE)_node)->children[3];
}

/* Constructor function */
Declaration function_decl(Def def,Type type,Block body){
  TNODE _node = create_tnode(5050,3);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Type(type);
  _node->children[1] = (void *)type;
  assert_Block(body);
  _node->children[2] = (void *)body;
  return (Declaration)_node;
}
/* Accessors */
Def function_decl_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYfunction_decl) {
    fatal_error("function_decl_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Type function_decl_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYfunction_decl) {
    fatal_error("function_decl_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}
Block function_decl_body(Declaration _node){
  if (Declaration_KEY(_node) != KEYfunction_decl) {
    fatal_error("function_decl_body: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Block)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration procedure_decl(Def def,Type type,Block body){
  TNODE _node = create_tnode(5151,3);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Type(type);
  _node->children[1] = (void *)type;
  assert_Block(body);
  _node->children[2] = (void *)body;
  return (Declaration)_node;
}
/* Accessors */
Def procedure_decl_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYprocedure_decl) {
    fatal_error("procedure_decl_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Type procedure_decl_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYprocedure_decl) {
    fatal_error("procedure_decl_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}
Block procedure_decl_body(Declaration _node){
  if (Declaration_KEY(_node) != KEYprocedure_decl) {
    fatal_error("procedure_decl_body: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Block)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration constructor_decl(Def def,Type type){
  TNODE _node = create_tnode(5252,2);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Type(type);
  _node->children[1] = (void *)type;
  return (Declaration)_node;
}
/* Accessors */
Def constructor_decl_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYconstructor_decl) {
    fatal_error("constructor_decl_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Type constructor_decl_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYconstructor_decl) {
    fatal_error("constructor_decl_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration pattern_decl(Def def,Type type,Pattern choices){
  TNODE _node = create_tnode(5353,3);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Type(type);
  _node->children[1] = (void *)type;
  assert_Pattern(choices);
  _node->children[2] = (void *)choices;
  return (Declaration)_node;
}
/* Accessors */
Def pattern_decl_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYpattern_decl) {
    fatal_error("pattern_decl_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Type pattern_decl_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYpattern_decl) {
    fatal_error("pattern_decl_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}
Pattern pattern_decl_choices(Declaration _node){
  if (Declaration_KEY(_node) != KEYpattern_decl) {
    fatal_error("pattern_decl_choices: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration inheritance(Def def,Type used,Block body){
  TNODE _node = create_tnode(5454,3);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Type(used);
  _node->children[1] = (void *)used;
  assert_Block(body);
  _node->children[2] = (void *)body;
  return (Declaration)_node;
}
/* Accessors */
Def inheritance_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYinheritance) {
    fatal_error("inheritance_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Type inheritance_used(Declaration _node){
  if (Declaration_KEY(_node) != KEYinheritance) {
    fatal_error("inheritance_used: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}
Block inheritance_body(Declaration _node){
  if (Declaration_KEY(_node) != KEYinheritance) {
    fatal_error("inheritance_body: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Block)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration polymorphic(Def def,Declarations type_formals,Block body){
  TNODE _node = create_tnode(5555,3);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Declarations(type_formals);
  _node->children[1] = (void *)type_formals;
  assert_Block(body);
  _node->children[2] = (void *)body;
  return (Declaration)_node;
}
/* Accessors */
Def polymorphic_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYpolymorphic) {
    fatal_error("polymorphic_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Declarations polymorphic_type_formals(Declaration _node){
  if (Declaration_KEY(_node) != KEYpolymorphic) {
    fatal_error("polymorphic_type_formals: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[1];
}
Block polymorphic_body(Declaration _node){
  if (Declaration_KEY(_node) != KEYpolymorphic) {
    fatal_error("polymorphic_body: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Block)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration pragma_call(Symbol name,Expressions parameters){
  TNODE _node = create_tnode(5656,2);
  assert_Symbol(name);
  _node->children[0] = (void *)name;
  assert_Expressions(parameters);
  _node->children[1] = (void *)parameters;
  return (Declaration)_node;
}
/* Accessors */
Symbol pragma_call_name(Declaration _node){
  if (Declaration_KEY(_node) != KEYpragma_call) {
    fatal_error("pragma_call_name: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[0];
}
Expressions pragma_call_parameters(Declaration _node){
  if (Declaration_KEY(_node) != KEYpragma_call) {
    fatal_error("pragma_call_parameters: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expressions)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration top_level_match(Match m){
  TNODE _node = create_tnode(5757,1);
  assert_Match(m);
  _node->children[0] = (void *)m;
  return (Declaration)_node;
}
/* Accessors */
Match top_level_match_m(Declaration _node){
  if (Declaration_KEY(_node) != KEYtop_level_match) {
    fatal_error("top_level_match_m: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Match)((TNODE)_node)->children[0];
}

/* Constructor function */
Declaration class_replacement(Class class,Class as){
  TNODE _node = create_tnode(5858,2);
  assert_Class(class);
  _node->children[0] = (void *)class;
  assert_Class(as);
  _node->children[1] = (void *)as;
  return (Declaration)_node;
}
/* Accessors */
Class class_replacement_class(Declaration _node){
  if (Declaration_KEY(_node) != KEYclass_replacement) {
    fatal_error("class_replacement_class: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Class)((TNODE)_node)->children[0];
}
Class class_replacement_as(Declaration _node){
  if (Declaration_KEY(_node) != KEYclass_replacement) {
    fatal_error("class_replacement_as: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Class)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration module_replacement(Module module,Module as){
  TNODE _node = create_tnode(5959,2);
  assert_Module(module);
  _node->children[0] = (void *)module;
  assert_Module(as);
  _node->children[1] = (void *)as;
  return (Declaration)_node;
}
/* Accessors */
Module module_replacement_module(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_replacement) {
    fatal_error("module_replacement_module: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Module)((TNODE)_node)->children[0];
}
Module module_replacement_as(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_replacement) {
    fatal_error("module_replacement_as: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Module)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration signature_replacement(Signature sig,Signature as){
  TNODE _node = create_tnode(6060,2);
  assert_Signature(sig);
  _node->children[0] = (void *)sig;
  assert_Signature(as);
  _node->children[1] = (void *)as;
  return (Declaration)_node;
}
/* Accessors */
Signature signature_replacement_sig(Declaration _node){
  if (Declaration_KEY(_node) != KEYsignature_replacement) {
    fatal_error("signature_replacement_sig: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[0];
}
Signature signature_replacement_as(Declaration _node){
  if (Declaration_KEY(_node) != KEYsignature_replacement) {
    fatal_error("signature_replacement_as: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration type_replacement(Type type,Type as){
  TNODE _node = create_tnode(6161,2);
  assert_Type(type);
  _node->children[0] = (void *)type;
  assert_Type(as);
  _node->children[1] = (void *)as;
  return (Declaration)_node;
}
/* Accessors */
Type type_replacement_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYtype_replacement) {
    fatal_error("type_replacement_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}
Type type_replacement_as(Declaration _node){
  if (Declaration_KEY(_node) != KEYtype_replacement) {
    fatal_error("type_replacement_as: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration value_replacement(Expression value,Expression as){
  TNODE _node = create_tnode(6262,2);
  assert_Expression(value);
  _node->children[0] = (void *)value;
  assert_Expression(as);
  _node->children[1] = (void *)as;
  return (Declaration)_node;
}
/* Accessors */
Expression value_replacement_value(Declaration _node){
  if (Declaration_KEY(_node) != KEYvalue_replacement) {
    fatal_error("value_replacement_value: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Expression value_replacement_as(Declaration _node){
  if (Declaration_KEY(_node) != KEYvalue_replacement) {
    fatal_error("value_replacement_as: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration pattern_replacement(Pattern pattern,Pattern as){
  TNODE _node = create_tnode(6363,2);
  assert_Pattern(pattern);
  _node->children[0] = (void *)pattern;
  assert_Pattern(as);
  _node->children[1] = (void *)as;
  return (Declaration)_node;
}
/* Accessors */
Pattern pattern_replacement_pattern(Declaration _node){
  if (Declaration_KEY(_node) != KEYpattern_replacement) {
    fatal_error("pattern_replacement_pattern: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}
Pattern pattern_replacement_as(Declaration _node){
  if (Declaration_KEY(_node) != KEYpattern_replacement) {
    fatal_error("pattern_replacement_as: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration class_renaming(Def def,Class old){
  TNODE _node = create_tnode(6464,2);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Class(old);
  _node->children[1] = (void *)old;
  return (Declaration)_node;
}
/* Accessors */
Def class_renaming_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYclass_renaming) {
    fatal_error("class_renaming_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Class class_renaming_old(Declaration _node){
  if (Declaration_KEY(_node) != KEYclass_renaming) {
    fatal_error("class_renaming_old: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Class)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration module_renaming(Def def,Module old){
  TNODE _node = create_tnode(6565,2);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Module(old);
  _node->children[1] = (void *)old;
  return (Declaration)_node;
}
/* Accessors */
Def module_renaming_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_renaming) {
    fatal_error("module_renaming_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Module module_renaming_old(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_renaming) {
    fatal_error("module_renaming_old: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Module)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration signature_renaming(Def def,Signature old){
  TNODE _node = create_tnode(6666,2);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Signature(old);
  _node->children[1] = (void *)old;
  return (Declaration)_node;
}
/* Accessors */
Def signature_renaming_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYsignature_renaming) {
    fatal_error("signature_renaming_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Signature signature_renaming_old(Declaration _node){
  if (Declaration_KEY(_node) != KEYsignature_renaming) {
    fatal_error("signature_renaming_old: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration type_renaming(Def def,Type old){
  TNODE _node = create_tnode(6767,2);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Type(old);
  _node->children[1] = (void *)old;
  return (Declaration)_node;
}
/* Accessors */
Def type_renaming_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYtype_renaming) {
    fatal_error("type_renaming_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Type type_renaming_old(Declaration _node){
  if (Declaration_KEY(_node) != KEYtype_renaming) {
    fatal_error("type_renaming_old: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration value_renaming(Def def,Expression old){
  TNODE _node = create_tnode(6868,2);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Expression(old);
  _node->children[1] = (void *)old;
  return (Declaration)_node;
}
/* Accessors */
Def value_renaming_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYvalue_renaming) {
    fatal_error("value_renaming_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Expression value_renaming_old(Declaration _node){
  if (Declaration_KEY(_node) != KEYvalue_renaming) {
    fatal_error("value_renaming_old: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration pattern_renaming(Def def,Pattern old){
  TNODE _node = create_tnode(6969,2);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Pattern(old);
  _node->children[1] = (void *)old;
  return (Declaration)_node;
}
/* Accessors */
Def pattern_renaming_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYpattern_renaming) {
    fatal_error("pattern_renaming_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Pattern pattern_renaming_old(Declaration _node){
  if (Declaration_KEY(_node) != KEYpattern_renaming) {
    fatal_error("pattern_renaming_old: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[1];
}

/* Constructor function */
Direction direction(Boolean is_input,Boolean is_collection,Boolean is_circular){
  TNODE _node = create_tnode(7373,3);
  assert_Boolean(is_input);
  _node->children[0] = (void *)is_input;
  assert_Boolean(is_collection);
  _node->children[1] = (void *)is_collection;
  assert_Boolean(is_circular);
  _node->children[2] = (void *)is_circular;
  return (Direction)_node;
}
/* Accessors */
Boolean direction_is_input(Direction _node){
  if (Direction_KEY(_node) != KEYdirection) {
    fatal_error("direction_is_input: called with %s",
                Direction_constructors[Direction_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[0];
}
Boolean direction_is_collection(Direction _node){
  if (Direction_KEY(_node) != KEYdirection) {
    fatal_error("direction_is_collection: called with %s",
                Direction_constructors[Direction_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[1];
}
Boolean direction_is_circular(Direction _node){
  if (Direction_KEY(_node) != KEYdirection) {
    fatal_error("direction_is_circular: called with %s",
                Direction_constructors[Direction_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[2];
}

/* Constructor function */
Default simple(Expression value){
  TNODE _node = create_tnode(7474,1);
  assert_Expression(value);
  _node->children[0] = (void *)value;
  return (Default)_node;
}
/* Accessors */
Expression simple_value(Default _node){
  if (Default_KEY(_node) != KEYsimple) {
    fatal_error("simple_value: called with %s",
                Default_constructors[Default_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Default composite(Expression initial,Expression combiner){
  TNODE _node = create_tnode(7575,2);
  assert_Expression(initial);
  _node->children[0] = (void *)initial;
  assert_Expression(combiner);
  _node->children[1] = (void *)combiner;
  return (Default)_node;
}
/* Accessors */
Expression composite_initial(Default _node){
  if (Default_KEY(_node) != KEYcomposite) {
    fatal_error("composite_initial: called with %s",
                Default_constructors[Default_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Expression composite_combiner(Default _node){
  if (Default_KEY(_node) != KEYcomposite) {
    fatal_error("composite_combiner: called with %s",
                Default_constructors[Default_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Default no_default(){
  TNODE _node = create_tnode(7676,0);
  return (Default)_node;
}
/* Accessors */

/* Constructor function */
Declaration normal_formal(Def def,Type type){
  TNODE _node = create_tnode(7777,2);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Type(type);
  _node->children[1] = (void *)type;
  return (Declaration)_node;
}
/* Accessors */
Def normal_formal_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYnormal_formal) {
    fatal_error("normal_formal_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Type normal_formal_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYnormal_formal) {
    fatal_error("normal_formal_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration seq_formal(Def def,Type type){
  TNODE _node = create_tnode(7878,2);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Type(type);
  _node->children[1] = (void *)type;
  return (Declaration)_node;
}
/* Accessors */
Def seq_formal_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYseq_formal) {
    fatal_error("seq_formal_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Type seq_formal_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYseq_formal) {
    fatal_error("seq_formal_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration type_formal(Def def,Signature sig){
  TNODE _node = create_tnode(8080,2);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Signature(sig);
  _node->children[1] = (void *)sig;
  return (Declaration)_node;
}
/* Accessors */
Def type_formal_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYtype_formal) {
    fatal_error("type_formal_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Signature type_formal_sig(Declaration _node){
  if (Declaration_KEY(_node) != KEYtype_formal) {
    fatal_error("type_formal_sig: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration phylum_formal(Def def,Signature sig){
  TNODE _node = create_tnode(8181,2);
  assert_Def(def);
  _node->children[0] = (void *)def;
  assert_Signature(sig);
  _node->children[1] = (void *)sig;
  return (Declaration)_node;
}
/* Accessors */
Def phylum_formal_def(Declaration _node){
  if (Declaration_KEY(_node) != KEYphylum_formal) {
    fatal_error("phylum_formal_def: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Def)((TNODE)_node)->children[0];
}
Signature phylum_formal_sig(Declaration _node){
  if (Declaration_KEY(_node) != KEYphylum_formal) {
    fatal_error("phylum_formal_sig: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[1];
}

/* Constructor function */
Def def(Symbol name,Boolean is_constant,Boolean is_public){
  TNODE _node = create_tnode(8383,3);
  assert_Symbol(name);
  _node->children[0] = (void *)name;
  assert_Boolean(is_constant);
  _node->children[1] = (void *)is_constant;
  assert_Boolean(is_public);
  _node->children[2] = (void *)is_public;
  return (Def)_node;
}
/* Accessors */
Symbol def_name(Def _node){
  if (Def_KEY(_node) != KEYdef) {
    fatal_error("def_name: called with %s",
                Def_constructors[Def_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[0];
}
Boolean def_is_constant(Def _node){
  if (Def_KEY(_node) != KEYdef) {
    fatal_error("def_is_constant: called with %s",
                Def_constructors[Def_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[1];
}
Boolean def_is_public(Def _node){
  if (Def_KEY(_node) != KEYdef) {
    fatal_error("def_is_public: called with %s",
                Def_constructors[Def_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[2];
}

/* Constructor function */
Use use(Symbol name){
  TNODE _node = create_tnode(8484,1);
  assert_Symbol(name);
  _node->children[0] = (void *)name;
  return (Use)_node;
}
/* Accessors */
Symbol use_name(Use _node){
  if (Use_KEY(_node) != KEYuse) {
    fatal_error("use_name: called with %s",
                Use_constructors[Use_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[0];
}

/* Constructor function */
Use qual_use(Type from,Symbol name){
  TNODE _node = create_tnode(8585,2);
  assert_Type(from);
  _node->children[0] = (void *)from;
  assert_Symbol(name);
  _node->children[1] = (void *)name;
  return (Use)_node;
}
/* Accessors */
Type qual_use_from(Use _node){
  if (Use_KEY(_node) != KEYqual_use) {
    fatal_error("qual_use_from: called with %s",
                Use_constructors[Use_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}
Symbol qual_use_name(Use _node){
  if (Use_KEY(_node) != KEYqual_use) {
    fatal_error("qual_use_name: called with %s",
                Use_constructors[Use_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[1];
}

/* Constructor function */
Class class_use(Use use){
  TNODE _node = create_tnode(9393,1);
  assert_Use(use);
  _node->children[0] = (void *)use;
  return (Class)_node;
}
/* Accessors */
Use class_use_use(Class _node){
  if (Class_KEY(_node) != KEYclass_use) {
    fatal_error("class_use_use: called with %s",
                Class_constructors[Class_KEY(_node)]);
  }
  return (Use)((TNODE)_node)->children[0];
}

/* Constructor function */
Module module_use(Use use){
  TNODE _node = create_tnode(9494,1);
  assert_Use(use);
  _node->children[0] = (void *)use;
  return (Module)_node;
}
/* Accessors */
Use module_use_use(Module _node){
  if (Module_KEY(_node) != KEYmodule_use) {
    fatal_error("module_use_use: called with %s",
                Module_constructors[Module_KEY(_node)]);
  }
  return (Use)((TNODE)_node)->children[0];
}

/* Constructor function */
Type type_use(Use use){
  TNODE _node = create_tnode(9595,1);
  assert_Use(use);
  _node->children[0] = (void *)use;
  return (Type)_node;
}
/* Accessors */
Use type_use_use(Type _node){
  if (Type_KEY(_node) != KEYtype_use) {
    fatal_error("type_use_use: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Use)((TNODE)_node)->children[0];
}

/* Constructor function */
Type type_inst(Module module,TypeActuals type_actuals,Actuals actuals){
  TNODE _node = create_tnode(9696,3);
  assert_Module(module);
  _node->children[0] = (void *)module;
  assert_TypeActuals(type_actuals);
  _node->children[1] = (void *)type_actuals;
  assert_Actuals(actuals);
  _node->children[2] = (void *)actuals;
  return (Type)_node;
}
/* Accessors */
Module type_inst_module(Type _node){
  if (Type_KEY(_node) != KEYtype_inst) {
    fatal_error("type_inst_module: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Module)((TNODE)_node)->children[0];
}
TypeActuals type_inst_type_actuals(Type _node){
  if (Type_KEY(_node) != KEYtype_inst) {
    fatal_error("type_inst_type_actuals: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (TypeActuals)((TNODE)_node)->children[1];
}
Actuals type_inst_actuals(Type _node){
  if (Type_KEY(_node) != KEYtype_inst) {
    fatal_error("type_inst_actuals: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Actuals)((TNODE)_node)->children[2];
}

/* Constructor function */
Type no_type(){
  TNODE _node = create_tnode(9797,0);
  return (Type)_node;
}
/* Accessors */

/* Constructor function */
Expression value_use(Use use){
  TNODE _node = create_tnode(9898,1);
  assert_Use(use);
  _node->children[0] = (void *)use;
  return (Expression)_node;
}
/* Accessors */
Use value_use_use(Expression _node){
  if (Expression_KEY(_node) != KEYvalue_use) {
    fatal_error("value_use_use: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Use)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression typed_value(Expression expr,Type type){
  TNODE _node = create_tnode(10100,2);
  assert_Expression(expr);
  _node->children[0] = (void *)expr;
  assert_Type(type);
  _node->children[1] = (void *)type;
  return (Expression)_node;
}
/* Accessors */
Expression typed_value_expr(Expression _node){
  if (Expression_KEY(_node) != KEYtyped_value) {
    fatal_error("typed_value_expr: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Type typed_value_type(Expression _node){
  if (Expression_KEY(_node) != KEYtyped_value) {
    fatal_error("typed_value_type: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Signature sig_use(Use use){
  TNODE _node = create_tnode(10201,1);
  assert_Use(use);
  _node->children[0] = (void *)use;
  return (Signature)_node;
}
/* Accessors */
Use sig_use_use(Signature _node){
  if (Signature_KEY(_node) != KEYsig_use) {
    fatal_error("sig_use_use: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Use)((TNODE)_node)->children[0];
}

/* Constructor function */
Signature sig_inst(Boolean is_input,Boolean is_var,Class class,TypeActuals actuals){
  TNODE _node = create_tnode(10302,4);
  assert_Boolean(is_input);
  _node->children[0] = (void *)is_input;
  assert_Boolean(is_var);
  _node->children[1] = (void *)is_var;
  assert_Class(class);
  _node->children[2] = (void *)class;
  assert_TypeActuals(actuals);
  _node->children[3] = (void *)actuals;
  return (Signature)_node;
}
/* Accessors */
Boolean sig_inst_is_input(Signature _node){
  if (Signature_KEY(_node) != KEYsig_inst) {
    fatal_error("sig_inst_is_input: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[0];
}
Boolean sig_inst_is_var(Signature _node){
  if (Signature_KEY(_node) != KEYsig_inst) {
    fatal_error("sig_inst_is_var: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[1];
}
Class sig_inst_class(Signature _node){
  if (Signature_KEY(_node) != KEYsig_inst) {
    fatal_error("sig_inst_class: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Class)((TNODE)_node)->children[2];
}
TypeActuals sig_inst_actuals(Signature _node){
  if (Signature_KEY(_node) != KEYsig_inst) {
    fatal_error("sig_inst_actuals: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (TypeActuals)((TNODE)_node)->children[3];
}

/* Constructor function */
Signature no_sig(){
  TNODE _node = create_tnode(10403,0);
  return (Signature)_node;
}
/* Accessors */

/* Constructor function */
Pattern pattern_use(Use use){
  TNODE _node = create_tnode(10504,1);
  assert_Use(use);
  _node->children[0] = (void *)use;
  return (Pattern)_node;
}
/* Accessors */
Use pattern_use_use(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_use) {
    fatal_error("pattern_use_use: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Use)((TNODE)_node)->children[0];
}

/* Constructor function */
Pattern no_pattern(){
  TNODE _node = create_tnode(10605,0);
  return (Pattern)_node;
}
/* Accessors */

/* Constructor function */
Pattern typed_pattern(Pattern pat,Type type){
  TNODE _node = create_tnode(10706,2);
  assert_Pattern(pat);
  _node->children[0] = (void *)pat;
  assert_Type(type);
  _node->children[1] = (void *)type;
  return (Pattern)_node;
}
/* Accessors */
Pattern typed_pattern_pat(Pattern _node){
  if (Pattern_KEY(_node) != KEYtyped_pattern) {
    fatal_error("typed_pattern_pat: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}
Type typed_pattern_type(Pattern _node){
  if (Pattern_KEY(_node) != KEYtyped_pattern) {
    fatal_error("typed_pattern_type: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Signature fixed_sig(Types types){
  TNODE _node = create_tnode(10807,1);
  assert_Types(types);
  _node->children[0] = (void *)types;
  return (Signature)_node;
}
/* Accessors */
Types fixed_sig_types(Signature _node){
  if (Signature_KEY(_node) != KEYfixed_sig) {
    fatal_error("fixed_sig_types: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Types)((TNODE)_node)->children[0];
}

/* Constructor function */
Signature mult_sig(Signature sig1,Signature sig2){
  TNODE _node = create_tnode(10908,2);
  assert_Signature(sig1);
  _node->children[0] = (void *)sig1;
  assert_Signature(sig2);
  _node->children[1] = (void *)sig2;
  return (Signature)_node;
}
/* Accessors */
Signature mult_sig_sig1(Signature _node){
  if (Signature_KEY(_node) != KEYmult_sig) {
    fatal_error("mult_sig_sig1: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[0];
}
Signature mult_sig_sig2(Signature _node){
  if (Signature_KEY(_node) != KEYmult_sig) {
    fatal_error("mult_sig_sig2: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[1];
}

/* Constructor function */
Type remote_type(Type nodetype){
  TNODE _node = create_tnode(11009,1);
  assert_Type(nodetype);
  _node->children[0] = (void *)nodetype;
  return (Type)_node;
}
/* Accessors */
Type remote_type_nodetype(Type _node){
  if (Type_KEY(_node) != KEYremote_type) {
    fatal_error("remote_type_nodetype: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}

/* Constructor function */
Type function_type(Declarations formals,Declarations return_values){
  TNODE _node = create_tnode(11110,2);
  assert_Declarations(formals);
  _node->children[0] = (void *)formals;
  assert_Declarations(return_values);
  _node->children[1] = (void *)return_values;
  return (Type)_node;
}
/* Accessors */
Declarations function_type_formals(Type _node){
  if (Type_KEY(_node) != KEYfunction_type) {
    fatal_error("function_type_formals: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[0];
}
Declarations function_type_return_values(Type _node){
  if (Type_KEY(_node) != KEYfunction_type) {
    fatal_error("function_type_return_values: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[1];
}

/* Constructor function */
Type private_type(Type rep){
  TNODE _node = create_tnode(11312,1);
  assert_Type(rep);
  _node->children[0] = (void *)rep;
  return (Type)_node;
}
/* Accessors */
Type private_type_rep(Type _node){
  if (Type_KEY(_node) != KEYprivate_type) {
    fatal_error("private_type_rep: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}

/* Constructor function */
Pattern match_pattern(Pattern pat,Type type){
  TNODE _node = create_tnode(11413,2);
  assert_Pattern(pat);
  _node->children[0] = (void *)pat;
  assert_Type(type);
  _node->children[1] = (void *)type;
  return (Pattern)_node;
}
/* Accessors */
Pattern match_pattern_pat(Pattern _node){
  if (Pattern_KEY(_node) != KEYmatch_pattern) {
    fatal_error("match_pattern_pat: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}
Type match_pattern_type(Pattern _node){
  if (Pattern_KEY(_node) != KEYmatch_pattern) {
    fatal_error("match_pattern_type: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Pattern pattern_call(Pattern func,PatternActuals actuals){
  TNODE _node = create_tnode(11514,2);
  assert_Pattern(func);
  _node->children[0] = (void *)func;
  assert_PatternActuals(actuals);
  _node->children[1] = (void *)actuals;
  return (Pattern)_node;
}
/* Accessors */
Pattern pattern_call_func(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_call) {
    fatal_error("pattern_call_func: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}
PatternActuals pattern_call_actuals(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_call) {
    fatal_error("pattern_call_actuals: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (PatternActuals)((TNODE)_node)->children[1];
}

/* Constructor function */
Pattern pattern_actual(Pattern arg,Expression formal){
  TNODE _node = create_tnode(11615,2);
  assert_Pattern(arg);
  _node->children[0] = (void *)arg;
  assert_Expression(formal);
  _node->children[1] = (void *)formal;
  return (Pattern)_node;
}
/* Accessors */
Pattern pattern_actual_arg(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_actual) {
    fatal_error("pattern_actual_arg: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}
Expression pattern_actual_formal(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_actual) {
    fatal_error("pattern_actual_formal: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Pattern rest_pattern(Pattern constraint){
  TNODE _node = create_tnode(11716,1);
  assert_Pattern(constraint);
  _node->children[0] = (void *)constraint;
  return (Pattern)_node;
}
/* Accessors */
Pattern rest_pattern_constraint(Pattern _node){
  if (Pattern_KEY(_node) != KEYrest_pattern) {
    fatal_error("rest_pattern_constraint: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}

/* Constructor function */
Pattern choice_pattern(Patterns choices){
  TNODE _node = create_tnode(11817,1);
  assert_Patterns(choices);
  _node->children[0] = (void *)choices;
  return (Pattern)_node;
}
/* Accessors */
Patterns choice_pattern_choices(Pattern _node){
  if (Pattern_KEY(_node) != KEYchoice_pattern) {
    fatal_error("choice_pattern_choices: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Patterns)((TNODE)_node)->children[0];
}

/* Constructor function */
Pattern and_pattern(Pattern p1,Pattern p2){
  TNODE _node = create_tnode(11918,2);
  assert_Pattern(p1);
  _node->children[0] = (void *)p1;
  assert_Pattern(p2);
  _node->children[1] = (void *)p2;
  return (Pattern)_node;
}
/* Accessors */
Pattern and_pattern_p1(Pattern _node){
  if (Pattern_KEY(_node) != KEYand_pattern) {
    fatal_error("and_pattern_p1: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}
Pattern and_pattern_p2(Pattern _node){
  if (Pattern_KEY(_node) != KEYand_pattern) {
    fatal_error("and_pattern_p2: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[1];
}

/* Constructor function */
Pattern pattern_var(Declaration formal){
  TNODE _node = create_tnode(12019,1);
  assert_Declaration(formal);
  _node->children[0] = (void *)formal;
  return (Pattern)_node;
}
/* Accessors */
Declaration pattern_var_formal(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_var) {
    fatal_error("pattern_var_formal: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[0];
}

/* Constructor function */
Pattern condition(Expression e){
  TNODE _node = create_tnode(12120,1);
  assert_Expression(e);
  _node->children[0] = (void *)e;
  return (Pattern)_node;
}
/* Accessors */
Expression condition_e(Pattern _node){
  if (Pattern_KEY(_node) != KEYcondition) {
    fatal_error("condition_e: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Pattern hole(){
  TNODE _node = create_tnode(12221,0);
  return (Pattern)_node;
}
/* Accessors */

/* Constructor function */
Pattern pattern_function(Declarations formals,Pattern body){
  TNODE _node = create_tnode(12322,2);
  assert_Declarations(formals);
  _node->children[0] = (void *)formals;
  assert_Pattern(body);
  _node->children[1] = (void *)body;
  return (Pattern)_node;
}
/* Accessors */
Declarations pattern_function_formals(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_function) {
    fatal_error("pattern_function_formals: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[0];
}
Pattern pattern_function_body(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_function) {
    fatal_error("pattern_function_body: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration block_stmt(Block body){
  TNODE _node = create_tnode(12423,1);
  assert_Block(body);
  _node->children[0] = (void *)body;
  return (Declaration)_node;
}
/* Accessors */
Block block_stmt_body(Declaration _node){
  if (Declaration_KEY(_node) != KEYblock_stmt) {
    fatal_error("block_stmt_body: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Block)((TNODE)_node)->children[0];
}

/* Constructor function */
Declaration effect(Expression e){
  TNODE _node = create_tnode(12524,1);
  assert_Expression(e);
  _node->children[0] = (void *)e;
  return (Declaration)_node;
}
/* Accessors */
Expression effect_e(Declaration _node){
  if (Declaration_KEY(_node) != KEYeffect) {
    fatal_error("effect_e: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Declaration multi_call(Expression proc,Actuals actuals,Actuals results){
  TNODE _node = create_tnode(12625,3);
  assert_Expression(proc);
  _node->children[0] = (void *)proc;
  assert_Actuals(actuals);
  _node->children[1] = (void *)actuals;
  assert_Actuals(results);
  _node->children[2] = (void *)results;
  return (Declaration)_node;
}
/* Accessors */
Expression multi_call_proc(Declaration _node){
  if (Declaration_KEY(_node) != KEYmulti_call) {
    fatal_error("multi_call_proc: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Actuals multi_call_actuals(Declaration _node){
  if (Declaration_KEY(_node) != KEYmulti_call) {
    fatal_error("multi_call_actuals: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Actuals)((TNODE)_node)->children[1];
}
Actuals multi_call_results(Declaration _node){
  if (Declaration_KEY(_node) != KEYmulti_call) {
    fatal_error("multi_call_results: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Actuals)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration normal_assign(Expression lhs,Expression rhs){
  TNODE _node = create_tnode(12928,2);
  assert_Expression(lhs);
  _node->children[0] = (void *)lhs;
  assert_Expression(rhs);
  _node->children[1] = (void *)rhs;
  return (Declaration)_node;
}
/* Accessors */
Expression normal_assign_lhs(Declaration _node){
  if (Declaration_KEY(_node) != KEYnormal_assign) {
    fatal_error("normal_assign_lhs: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Expression normal_assign_rhs(Declaration _node){
  if (Declaration_KEY(_node) != KEYnormal_assign) {
    fatal_error("normal_assign_rhs: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration collect_assign(Expression lhs,Expression rhs){
  TNODE _node = create_tnode(13029,2);
  assert_Expression(lhs);
  _node->children[0] = (void *)lhs;
  assert_Expression(rhs);
  _node->children[1] = (void *)rhs;
  return (Declaration)_node;
}
/* Accessors */
Expression collect_assign_lhs(Declaration _node){
  if (Declaration_KEY(_node) != KEYcollect_assign) {
    fatal_error("collect_assign_lhs: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Expression collect_assign_rhs(Declaration _node){
  if (Declaration_KEY(_node) != KEYcollect_assign) {
    fatal_error("collect_assign_rhs: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration if_stmt(Expression cond,Block if_true,Block if_false){
  TNODE _node = create_tnode(13231,3);
  assert_Expression(cond);
  _node->children[0] = (void *)cond;
  assert_Block(if_true);
  _node->children[1] = (void *)if_true;
  assert_Block(if_false);
  _node->children[2] = (void *)if_false;
  return (Declaration)_node;
}
/* Accessors */
Expression if_stmt_cond(Declaration _node){
  if (Declaration_KEY(_node) != KEYif_stmt) {
    fatal_error("if_stmt_cond: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Block if_stmt_if_true(Declaration _node){
  if (Declaration_KEY(_node) != KEYif_stmt) {
    fatal_error("if_stmt_if_true: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Block)((TNODE)_node)->children[1];
}
Block if_stmt_if_false(Declaration _node){
  if (Declaration_KEY(_node) != KEYif_stmt) {
    fatal_error("if_stmt_if_false: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Block)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration for_in_stmt(Declaration formal,Expression seq,Block body){
  TNODE _node = create_tnode(13332,3);
  assert_Declaration(formal);
  _node->children[0] = (void *)formal;
  assert_Expression(seq);
  _node->children[1] = (void *)seq;
  assert_Block(body);
  _node->children[2] = (void *)body;
  return (Declaration)_node;
}
/* Accessors */
Declaration for_in_stmt_formal(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_in_stmt) {
    fatal_error("for_in_stmt_formal: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[0];
}
Expression for_in_stmt_seq(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_in_stmt) {
    fatal_error("for_in_stmt_seq: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}
Block for_in_stmt_body(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_in_stmt) {
    fatal_error("for_in_stmt_body: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Block)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration for_stmt(Expression expr,Matches matchers){
  TNODE _node = create_tnode(13433,2);
  assert_Expression(expr);
  _node->children[0] = (void *)expr;
  assert_Matches(matchers);
  _node->children[1] = (void *)matchers;
  return (Declaration)_node;
}
/* Accessors */
Expression for_stmt_expr(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_stmt) {
    fatal_error("for_stmt_expr: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Matches for_stmt_matchers(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_stmt) {
    fatal_error("for_stmt_matchers: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Matches)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration case_stmt(Expression expr,Matches matchers,Block default_){
  TNODE _node = create_tnode(13534,3);
  assert_Expression(expr);
  _node->children[0] = (void *)expr;
  assert_Matches(matchers);
  _node->children[1] = (void *)matchers;
  assert_Block(default_);
  _node->children[2] = (void *)default_;
  return (Declaration)_node;
}
/* Accessors */
Expression case_stmt_expr(Declaration _node){
  if (Declaration_KEY(_node) != KEYcase_stmt) {
    fatal_error("case_stmt_expr: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Matches case_stmt_matchers(Declaration _node){
  if (Declaration_KEY(_node) != KEYcase_stmt) {
    fatal_error("case_stmt_matchers: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Matches)((TNODE)_node)->children[1];
}
Block case_stmt_default(Declaration _node){
  if (Declaration_KEY(_node) != KEYcase_stmt) {
    fatal_error("case_stmt_default: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Block)((TNODE)_node)->children[2];
}

/* Constructor function */
Match matcher(Pattern pat,Block body){
  TNODE _node = create_tnode(13635,2);
  assert_Pattern(pat);
  _node->children[0] = (void *)pat;
  assert_Block(body);
  _node->children[1] = (void *)body;
  return (Match)_node;
}
/* Accessors */
Pattern matcher_pat(Match _node){
  if (Match_KEY(_node) != KEYmatcher) {
    fatal_error("matcher_pat: called with %s",
                Match_constructors[Match_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}
Block matcher_body(Match _node){
  if (Match_KEY(_node) != KEYmatcher) {
    fatal_error("matcher_body: called with %s",
                Match_constructors[Match_KEY(_node)]);
  }
  return (Block)((TNODE)_node)->children[1];
}

/* Constructor function */
Expression integer_const(String token){
  TNODE _node = create_tnode(13736,1);
  assert_String(token);
  _node->children[0] = (void *)token;
  return (Expression)_node;
}
/* Accessors */
String integer_const_token(Expression _node){
  if (Expression_KEY(_node) != KEYinteger_const) {
    fatal_error("integer_const_token: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (String)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression real_const(String token){
  TNODE _node = create_tnode(13837,1);
  assert_String(token);
  _node->children[0] = (void *)token;
  return (Expression)_node;
}
/* Accessors */
String real_const_token(Expression _node){
  if (Expression_KEY(_node) != KEYreal_const) {
    fatal_error("real_const_token: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (String)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression string_const(String token){
  TNODE _node = create_tnode(13938,1);
  assert_String(token);
  _node->children[0] = (void *)token;
  return (Expression)_node;
}
/* Accessors */
String string_const_token(Expression _node){
  if (Expression_KEY(_node) != KEYstring_const) {
    fatal_error("string_const_token: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (String)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression char_const(String token){
  TNODE _node = create_tnode(14039,1);
  assert_String(token);
  _node->children[0] = (void *)token;
  return (Expression)_node;
}
/* Accessors */
String char_const_token(Expression _node){
  if (Expression_KEY(_node) != KEYchar_const) {
    fatal_error("char_const_token: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (String)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression undefined(){
  TNODE _node = create_tnode(14140,0);
  return (Expression)_node;
}
/* Accessors */

/* Constructor function */
Expression no_expr(){
  TNODE _node = create_tnode(14241,0);
  return (Expression)_node;
}
/* Accessors */

/* Constructor function */
Expression funcall(Expression f,Actuals actuals){
  TNODE _node = create_tnode(14342,2);
  assert_Expression(f);
  _node->children[0] = (void *)f;
  assert_Actuals(actuals);
  _node->children[1] = (void *)actuals;
  return (Expression)_node;
}
/* Accessors */
Expression funcall_f(Expression _node){
  if (Expression_KEY(_node) != KEYfuncall) {
    fatal_error("funcall_f: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Actuals funcall_actuals(Expression _node){
  if (Expression_KEY(_node) != KEYfuncall) {
    fatal_error("funcall_actuals: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Actuals)((TNODE)_node)->children[1];
}

/* Constructor function */
Expression append(Expression s1,Expression s2){
  TNODE _node = create_tnode(14443,2);
  assert_Expression(s1);
  _node->children[0] = (void *)s1;
  assert_Expression(s2);
  _node->children[1] = (void *)s2;
  return (Expression)_node;
}
/* Accessors */
Expression append_s1(Expression _node){
  if (Expression_KEY(_node) != KEYappend) {
    fatal_error("append_s1: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Expression append_s2(Expression _node){
  if (Expression_KEY(_node) != KEYappend) {
    fatal_error("append_s2: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Expression empty(){
  TNODE _node = create_tnode(14544,0);
  return (Expression)_node;
}
/* Accessors */

/* Constructor function */
Expression class_value(Class c){
  TNODE _node = create_tnode(14645,1);
  assert_Class(c);
  _node->children[0] = (void *)c;
  return (Expression)_node;
}
/* Accessors */
Class class_value_c(Expression _node){
  if (Expression_KEY(_node) != KEYclass_value) {
    fatal_error("class_value_c: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Class)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression module_value(Module m){
  TNODE _node = create_tnode(14746,1);
  assert_Module(m);
  _node->children[0] = (void *)m;
  return (Expression)_node;
}
/* Accessors */
Module module_value_m(Expression _node){
  if (Expression_KEY(_node) != KEYmodule_value) {
    fatal_error("module_value_m: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Module)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression signature_value(Signature s){
  TNODE _node = create_tnode(14847,1);
  assert_Signature(s);
  _node->children[0] = (void *)s;
  return (Expression)_node;
}
/* Accessors */
Signature signature_value_s(Expression _node){
  if (Expression_KEY(_node) != KEYsignature_value) {
    fatal_error("signature_value_s: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression type_value(Type T){
  TNODE _node = create_tnode(14948,1);
  assert_Type(T);
  _node->children[0] = (void *)T;
  return (Expression)_node;
}
/* Accessors */
Type type_value_T(Expression _node){
  if (Expression_KEY(_node) != KEYtype_value) {
    fatal_error("type_value_T: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression pattern_value(Pattern p){
  TNODE _node = create_tnode(15049,1);
  assert_Pattern(p);
  _node->children[0] = (void *)p;
  return (Expression)_node;
}
/* Accessors */
Pattern pattern_value_p(Expression _node){
  if (Expression_KEY(_node) != KEYpattern_value) {
    fatal_error("pattern_value_p: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression repeat(Expression expr){
  TNODE _node = create_tnode(15150,1);
  assert_Expression(expr);
  _node->children[0] = (void *)expr;
  return (Expression)_node;
}
/* Accessors */
Expression repeat_expr(Expression _node){
  if (Expression_KEY(_node) != KEYrepeat) {
    fatal_error("repeat_expr: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression guarded(Expression expr,Expression cond){
  TNODE _node = create_tnode(15251,2);
  assert_Expression(expr);
  _node->children[0] = (void *)expr;
  assert_Expression(cond);
  _node->children[1] = (void *)cond;
  return (Expression)_node;
}
/* Accessors */
Expression guarded_expr(Expression _node){
  if (Expression_KEY(_node) != KEYguarded) {
    fatal_error("guarded_expr: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Expression guarded_cond(Expression _node){
  if (Expression_KEY(_node) != KEYguarded) {
    fatal_error("guarded_cond: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Expression controlled(Expression expr,Declaration formal,Expression set){
  TNODE _node = create_tnode(15352,3);
  assert_Expression(expr);
  _node->children[0] = (void *)expr;
  assert_Declaration(formal);
  _node->children[1] = (void *)formal;
  assert_Expression(set);
  _node->children[2] = (void *)set;
  return (Expression)_node;
}
/* Accessors */
Expression controlled_expr(Expression _node){
  if (Expression_KEY(_node) != KEYcontrolled) {
    fatal_error("controlled_expr: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Declaration controlled_formal(Expression _node){
  if (Expression_KEY(_node) != KEYcontrolled) {
    fatal_error("controlled_formal: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[1];
}
Expression controlled_set(Expression _node){
  if (Expression_KEY(_node) != KEYcontrolled) {
    fatal_error("controlled_set: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[2];
}

