/* Generated by a program written by John Boyland,
   and modified by hand. */

#include <stdio.h>
#include "aps-tree.h"
#include "aps-traverse.h"

#define traverse_Symbol(f,a,x) /*nothing*/
#define traverse_String(f,a,x) /*nothing*/
#define traverse_Boolean(f,a,x) /*nothing*/

void traverse_Signature(TRAVERSEFUNC func, void *arg, Signature _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Signature_skip(func,arg,_node);
}
void traverse_Signature_skip(TRAVERSEFUNC func, void *arg, Signature _node){
  switch (Signature_KEY(_node)) {
  default: fatal_error("traverse_Signature crashes");
  case KEYmult_sig:
    traverse_Signature(func,arg,mult_sig_sig1(_node));
    traverse_Signature(func,arg,mult_sig_sig2(_node));
    break;
  case KEYfixed_sig:
    traverse_Types(func,arg,fixed_sig_types(_node));
    break;
  case KEYno_sig:
    break;
  case KEYsig_inst:
    traverse_Boolean(func,arg,sig_inst_is_input(_node));
    traverse_Boolean(func,arg,sig_inst_is_var(_node));
    traverse_Class(func,arg,sig_inst_class(_node));
    traverse_TypeActuals(func,arg,sig_inst_actuals(_node));
    break;
  case KEYsig_use:
    traverse_Use(func,arg,sig_use_use(_node));
    break;
  }
}

void traverse_Type(TRAVERSEFUNC func, void *arg, Type _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Type_skip(func,arg,_node);
}
void traverse_Type_skip(TRAVERSEFUNC func, void *arg, Type _node){
  switch (Type_KEY(_node)) {
  default: fatal_error("traverse_Type crashes");
  case KEYprivate_type:
    traverse_Type(func,arg,private_type_rep(_node));
    break;
  case KEYfunction_type:
    traverse_Declarations(func,arg,function_type_formals(_node));
    traverse_Declarations(func,arg,function_type_return_values(_node));
    break;
  case KEYremote_type:
    traverse_Type(func,arg,remote_type_nodetype(_node));
    break;
  case KEYno_type:
    break;
  case KEYtype_inst:
    traverse_Module(func,arg,type_inst_module(_node));
    traverse_TypeActuals(func,arg,type_inst_type_actuals(_node));
    traverse_Actuals(func,arg,type_inst_actuals(_node));
    break;
  case KEYtype_use:
    traverse_Use(func,arg,type_use_use(_node));
    break;
  }
}

void traverse_Expression(TRAVERSEFUNC func, void *arg, Expression _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Expression_skip(func,arg,_node);
}
void traverse_Expression_skip(TRAVERSEFUNC func, void *arg, Expression _node){
  switch (Expression_KEY(_node)) {
  default: fatal_error("traverse_Expression crashes");
  case KEYcontrolled:
    traverse_Expression(func,arg,controlled_expr(_node));
    traverse_Declaration(func,arg,controlled_formal(_node));
    traverse_Expression(func,arg,controlled_set(_node));
    break;
  case KEYguarded:
    traverse_Expression(func,arg,guarded_expr(_node));
    traverse_Expression(func,arg,guarded_cond(_node));
    break;
  case KEYrepeat:
    traverse_Expression(func,arg,repeat_expr(_node));
    break;
  case KEYpattern_value:
    traverse_Pattern(func,arg,pattern_value_p(_node));
    break;
  case KEYtype_value:
    traverse_Type(func,arg,type_value_T(_node));
    break;
  case KEYsignature_value:
    traverse_Signature(func,arg,signature_value_s(_node));
    break;
  case KEYmodule_value:
    traverse_Module(func,arg,module_value_m(_node));
    break;
  case KEYclass_value:
    traverse_Class(func,arg,class_value_c(_node));
    break;
  case KEYempty:
    break;
  case KEYappend:
    traverse_Expression(func,arg,append_s1(_node));
    traverse_Expression(func,arg,append_s2(_node));
    break;
  case KEYfuncall:
    traverse_Expression(func,arg,funcall_f(_node));
    traverse_Actuals(func,arg,funcall_actuals(_node));
    break;
  case KEYno_expr:
    break;
  case KEYundefined:
    break;
  case KEYchar_const:
    traverse_String(func,arg,char_const_token(_node));
    break;
  case KEYstring_const:
    traverse_String(func,arg,string_const_token(_node));
    break;
  case KEYreal_const:
    traverse_String(func,arg,real_const_token(_node));
    break;
  case KEYinteger_const:
    traverse_String(func,arg,integer_const_token(_node));
    break;
  case KEYtyped_value:
    traverse_Expression(func,arg,typed_value_expr(_node));
    traverse_Type(func,arg,typed_value_type(_node));
    break;
  case KEYvalue_use:
    traverse_Use(func,arg,value_use_use(_node));
    break;
  }
}

void traverse_Pattern(TRAVERSEFUNC func, void *arg, Pattern _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Pattern_skip(func,arg,_node);
}
void traverse_Pattern_skip(TRAVERSEFUNC func, void *arg, Pattern _node){
  switch (Pattern_KEY(_node)) {
  default: fatal_error("traverse_Pattern crashes");
  case KEYpattern_function:
    traverse_Declarations(func,arg,pattern_function_formals(_node));
    traverse_Pattern(func,arg,pattern_function_body(_node));
    break;
  case KEYhole:
    break;
  case KEYcondition:
    traverse_Expression(func,arg,condition_e(_node));
    break;
  case KEYpattern_var:
    traverse_Declaration(func,arg,pattern_var_formal(_node));
    break;
  case KEYand_pattern:
    traverse_Pattern(func,arg,and_pattern_p1(_node));
    traverse_Pattern(func,arg,and_pattern_p2(_node));
    break;
  case KEYchoice_pattern:
    traverse_Patterns(func,arg,choice_pattern_choices(_node));
    break;
  case KEYrest_pattern:
    traverse_Pattern(func,arg,rest_pattern_constraint(_node));
    break;
  case KEYpattern_actual:
    traverse_Pattern(func,arg,pattern_actual_arg(_node));
    traverse_Expression(func,arg,pattern_actual_formal(_node));
    break;
  case KEYpattern_call:
    traverse_Pattern(func,arg,pattern_call_func(_node));
    traverse_PatternActuals(func,arg,pattern_call_actuals(_node));
    break;
  case KEYmatch_pattern:
    traverse_Pattern(func,arg,match_pattern_pat(_node));
    traverse_Type(func,arg,match_pattern_type(_node));
    break;
  case KEYtyped_pattern:
    traverse_Pattern(func,arg,typed_pattern_pat(_node));
    traverse_Type(func,arg,typed_pattern_type(_node));
    break;
  case KEYno_pattern:
    break;
  case KEYpattern_use:
    traverse_Use(func,arg,pattern_use_use(_node));
    break;
  }
}

void traverse_Module(TRAVERSEFUNC func, void *arg, Module _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Module_skip(func,arg,_node);
}
void traverse_Module_skip(TRAVERSEFUNC func, void *arg, Module _node){
  switch (Module_KEY(_node)) {
  default: fatal_error("traverse_Module crashes");
  case KEYmodule_use:
    traverse_Use(func,arg,module_use_use(_node));
    break;
  }
}

void traverse_Class(TRAVERSEFUNC func, void *arg, Class _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Class_skip(func,arg,_node);
}
void traverse_Class_skip(TRAVERSEFUNC func, void *arg, Class _node){
  switch (Class_KEY(_node)) {
  default: fatal_error("traverse_Class crashes");
  case KEYclass_use:
    traverse_Use(func,arg,class_use_use(_node));
    break;
  }
}

void traverse_Def(TRAVERSEFUNC func, void *arg, Def _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Def_skip(func,arg,_node);
}
void traverse_Def_skip(TRAVERSEFUNC func, void *arg, Def _node){
  switch (Def_KEY(_node)) {
  default: fatal_error("traverse_Def crashes");
  case KEYdef:
    traverse_Symbol(func,arg,def_name(_node));
    traverse_Boolean(func,arg,def_is_constant(_node));
    traverse_Boolean(func,arg,def_is_public(_node));
    break;
  }
}

void traverse_Use(TRAVERSEFUNC func, void *arg, Use _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Use_skip(func,arg,_node);
}
void traverse_Use_skip(TRAVERSEFUNC func, void *arg, Use _node){
  switch (Use_KEY(_node)) {
  default: fatal_error("traverse_Use crashes");
  case KEYqual_use:
    traverse_Type(func,arg,qual_use_from(_node));
    traverse_Symbol(func,arg,qual_use_name(_node));
    break;
  case KEYuse:
    traverse_Symbol(func,arg,use_name(_node));
    break;
  }
}

void traverse_Program(TRAVERSEFUNC func, void *arg, Program _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Program_skip(func,arg,_node);
}
void traverse_Program_skip(TRAVERSEFUNC func, void *arg, Program _node){
  switch (Program_KEY(_node)) {
  default: fatal_error("traverse_Program crashes");
  case KEYprogram:
    traverse_String(func,arg,program_name(_node));
    traverse_Units(func,arg,program_units(_node));
    break;
  }
}

void traverse_Unit(TRAVERSEFUNC func, void *arg, Unit _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Unit_skip(func,arg,_node);
}
void traverse_Unit_skip(TRAVERSEFUNC func, void *arg, Unit _node){
  switch (Unit_KEY(_node)) {
  default: fatal_error("traverse_Unit crashes");
  case KEYdecl_unit:
    traverse_Declaration(func,arg,decl_unit_decl(_node));
    break;
  case KEYwith_unit:
    traverse_String(func,arg,with_unit_name(_node));
    break;
  case KEYno_unit:
    break;
  }
}

void traverse_Declaration(TRAVERSEFUNC func, void *arg, Declaration _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Declaration_skip(func,arg,_node);
}
void traverse_Declaration_skip(TRAVERSEFUNC func, void *arg, Declaration _node){
  switch (Declaration_KEY(_node)) {
  default: fatal_error("traverse_Declaration crashes");
  case KEYcase_stmt:
    traverse_Expression(func,arg,case_stmt_expr(_node));
    traverse_Matches(func,arg,case_stmt_matchers(_node));
    traverse_Block(func,arg,case_stmt_default(_node));
    break;
  case KEYfor_stmt:
    traverse_Expression(func,arg,for_stmt_expr(_node));
    traverse_Matches(func,arg,for_stmt_matchers(_node));
    break;
  case KEYfor_in_stmt:
    traverse_Declaration(func,arg,for_in_stmt_formal(_node));
    traverse_Expression(func,arg,for_in_stmt_seq(_node));
    traverse_Block(func,arg,for_in_stmt_body(_node));
    break;
  case KEYif_stmt:
    traverse_Expression(func,arg,if_stmt_cond(_node));
    traverse_Block(func,arg,if_stmt_if_true(_node));
    traverse_Block(func,arg,if_stmt_if_false(_node));
    break;
  case KEYcollect_assign:
    traverse_Expression(func,arg,collect_assign_lhs(_node));
    traverse_Expression(func,arg,collect_assign_rhs(_node));
    break;
  case KEYnormal_assign:
    traverse_Expression(func,arg,normal_assign_lhs(_node));
    traverse_Expression(func,arg,normal_assign_rhs(_node));
    break;
  case KEYmulti_call:
    traverse_Expression(func,arg,multi_call_proc(_node));
    traverse_Actuals(func,arg,multi_call_actuals(_node));
    traverse_Actuals(func,arg,multi_call_results(_node));
    break;
  case KEYeffect:
    traverse_Expression(func,arg,effect_e(_node));
    break;
  case KEYblock_stmt:
    traverse_Block(func,arg,block_stmt_body(_node));
    break;
  case KEYphylum_formal:
    traverse_Def(func,arg,phylum_formal_def(_node));
    traverse_Signature(func,arg,phylum_formal_sig(_node));
    break;
  case KEYtype_formal:
    traverse_Def(func,arg,type_formal_def(_node));
    traverse_Signature(func,arg,type_formal_sig(_node));
    break;
  case KEYseq_formal:
    traverse_Def(func,arg,seq_formal_def(_node));
    traverse_Type(func,arg,seq_formal_type(_node));
    break;
  case KEYnormal_formal:
    traverse_Def(func,arg,normal_formal_def(_node));
    traverse_Type(func,arg,normal_formal_type(_node));
    break;
  case KEYpattern_renaming:
    traverse_Def(func,arg,pattern_renaming_def(_node));
    traverse_Pattern(func,arg,pattern_renaming_old(_node));
    break;
  case KEYvalue_renaming:
    traverse_Def(func,arg,value_renaming_def(_node));
    traverse_Expression(func,arg,value_renaming_old(_node));
    break;
  case KEYtype_renaming:
    traverse_Def(func,arg,type_renaming_def(_node));
    traverse_Type(func,arg,type_renaming_old(_node));
    break;
  case KEYsignature_renaming:
    traverse_Def(func,arg,signature_renaming_def(_node));
    traverse_Signature(func,arg,signature_renaming_old(_node));
    break;
  case KEYmodule_renaming:
    traverse_Def(func,arg,module_renaming_def(_node));
    traverse_Module(func,arg,module_renaming_old(_node));
    break;
  case KEYclass_renaming:
    traverse_Def(func,arg,class_renaming_def(_node));
    traverse_Class(func,arg,class_renaming_old(_node));
    break;
  case KEYpattern_replacement:
    traverse_Pattern(func,arg,pattern_replacement_pattern(_node));
    traverse_Pattern(func,arg,pattern_replacement_as(_node));
    break;
  case KEYvalue_replacement:
    traverse_Expression(func,arg,value_replacement_value(_node));
    traverse_Expression(func,arg,value_replacement_as(_node));
    break;
  case KEYtype_replacement:
    traverse_Type(func,arg,type_replacement_type(_node));
    traverse_Type(func,arg,type_replacement_as(_node));
    break;
  case KEYsignature_replacement:
    traverse_Signature(func,arg,signature_replacement_sig(_node));
    traverse_Signature(func,arg,signature_replacement_as(_node));
    break;
  case KEYmodule_replacement:
    traverse_Module(func,arg,module_replacement_module(_node));
    traverse_Module(func,arg,module_replacement_as(_node));
    break;
  case KEYclass_replacement:
    traverse_Class(func,arg,class_replacement_class(_node));
    traverse_Class(func,arg,class_replacement_as(_node));
    break;
  case KEYtop_level_match:
    traverse_Match(func,arg,top_level_match_m(_node));
    break;
  case KEYpragma_call:
    traverse_Symbol(func,arg,pragma_call_name(_node));
    traverse_Expressions(func,arg,pragma_call_parameters(_node));
    break;
  case KEYpolymorphic:
    traverse_Def(func,arg,polymorphic_def(_node));
    traverse_Declarations(func,arg,polymorphic_type_formals(_node));
    traverse_Block(func,arg,polymorphic_body(_node));
    break;
  case KEYinheritance:
    traverse_Def(func,arg,inheritance_def(_node));
    traverse_Type(func,arg,inheritance_used(_node));
    traverse_Block(func,arg,inheritance_body(_node));
    break;
  case KEYpattern_decl:
    traverse_Def(func,arg,pattern_decl_def(_node));
    traverse_Type(func,arg,pattern_decl_type(_node));
    traverse_Pattern(func,arg,pattern_decl_choices(_node));
    break;
  case KEYconstructor_decl:
    traverse_Def(func,arg,constructor_decl_def(_node));
    traverse_Type(func,arg,constructor_decl_type(_node));
    break;
  case KEYprocedure_decl:
    traverse_Def(func,arg,procedure_decl_def(_node));
    traverse_Type(func,arg,procedure_decl_type(_node));
    traverse_Block(func,arg,procedure_decl_body(_node));
    break;
  case KEYfunction_decl:
    traverse_Def(func,arg,function_decl_def(_node));
    traverse_Type(func,arg,function_decl_type(_node));
    traverse_Block(func,arg,function_decl_body(_node));
    break;
  case KEYattribute_decl:
    traverse_Def(func,arg,attribute_decl_def(_node));
    traverse_Type(func,arg,attribute_decl_type(_node));
    traverse_Direction(func,arg,attribute_decl_direction(_node));
    traverse_Default(func,arg,attribute_decl_default(_node));
    break;
  case KEYvalue_decl:
    traverse_Def(func,arg,value_decl_def(_node));
    traverse_Type(func,arg,value_decl_type(_node));
    traverse_Direction(func,arg,value_decl_direction(_node));
    traverse_Default(func,arg,value_decl_default(_node));
    break;
  case KEYtype_decl:
    traverse_Def(func,arg,type_decl_def(_node));
    traverse_Signature(func,arg,type_decl_sig(_node));
    traverse_Type(func,arg,type_decl_type(_node));
    break;
  case KEYphylum_decl:
    traverse_Def(func,arg,phylum_decl_def(_node));
    traverse_Signature(func,arg,phylum_decl_sig(_node));
    traverse_Type(func,arg,phylum_decl_type(_node));
    break;
  case KEYsignature_decl:
    traverse_Def(func,arg,signature_decl_def(_node));
    traverse_Signature(func,arg,signature_decl_sig(_node));
    break;
  case KEYmodule_decl:
    traverse_Def(func,arg,module_decl_def(_node));
    traverse_Declarations(func,arg,module_decl_type_formals(_node));
    traverse_Declarations(func,arg,module_decl_value_formals(_node));
    traverse_Declaration(func,arg,module_decl_result_type(_node));
    traverse_Signature(func,arg,module_decl_parent(_node));
    traverse_Block(func,arg,module_decl_contents(_node));
    break;
  case KEYclass_decl:
    traverse_Def(func,arg,class_decl_def(_node));
    traverse_Declarations(func,arg,class_decl_type_formals(_node));
    traverse_Declaration(func,arg,class_decl_result_type(_node));
    traverse_Signature(func,arg,class_decl_parent(_node));
    traverse_Block(func,arg,class_decl_contents(_node));
    break;
  case KEYno_decl:
    break;
  }
}

void traverse_Block(TRAVERSEFUNC func, void *arg, Block _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Block_skip(func,arg,_node);
}
void traverse_Block_skip(TRAVERSEFUNC func, void *arg, Block _node){
  switch (Block_KEY(_node)) {
  default: fatal_error("traverse_Block crashes");
  case KEYblock:
    traverse_Declarations(func,arg,block_body(_node));
    break;
  }
}

void traverse_Match(TRAVERSEFUNC func, void *arg, Match _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Match_skip(func,arg,_node);
}
void traverse_Match_skip(TRAVERSEFUNC func, void *arg, Match _node){
  switch (Match_KEY(_node)) {
  default: fatal_error("traverse_Match crashes");
  case KEYmatcher:
    traverse_Pattern(func,arg,matcher_pat(_node));
    traverse_Block(func,arg,matcher_body(_node));
    break;
  }
}

void traverse_Direction(TRAVERSEFUNC func, void *arg, Direction _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Direction_skip(func,arg,_node);
}
void traverse_Direction_skip(TRAVERSEFUNC func, void *arg, Direction _node){
  switch (Direction_KEY(_node)) {
  default: fatal_error("traverse_Direction crashes");
  case KEYdirection:
    traverse_Boolean(func,arg,direction_is_input(_node));
    traverse_Boolean(func,arg,direction_is_collection(_node));
    traverse_Boolean(func,arg,direction_is_circular(_node));
    break;
  }
}

void traverse_Default(TRAVERSEFUNC func, void *arg, Default _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Default_skip(func,arg,_node);
}
void traverse_Default_skip(TRAVERSEFUNC func, void *arg, Default _node){
  switch (Default_KEY(_node)) {
  default: fatal_error("traverse_Default crashes");
  case KEYno_default:
    break;
  case KEYcomposite:
    traverse_Expression(func,arg,composite_initial(_node));
    traverse_Expression(func,arg,composite_combiner(_node));
    break;
  case KEYsimple:
    traverse_Expression(func,arg,simple_value(_node));
    break;
  }
}

void traverse_Units(TRAVERSEFUNC func, void *arg, Units _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Units_skip(func,arg,_node);
}
void traverse_Units_skip(TRAVERSEFUNC func, void *arg, Units _node){
  switch (Units_KEY(_node)) {
  default: fatal_error("traverse_Units crashes");
  case KEYnil_Units:
    break;
  case KEYlist_Units:
    traverse_Unit(func,arg,list_Units_elem(_node));
    break;
  case KEYappend_Units:
    traverse_Units(func,arg,append_Units_l1(_node));
    traverse_Units(func,arg,append_Units_l2(_node));
    break;
  }
}

void traverse_Declarations(TRAVERSEFUNC func, void *arg, Declarations _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Declarations_skip(func,arg,_node);
}
void traverse_Declarations_skip(TRAVERSEFUNC func, void *arg, Declarations _node){
  switch (Declarations_KEY(_node)) {
  default: fatal_error("traverse_Declarations crashes");
  case KEYnil_Declarations:
    break;
  case KEYlist_Declarations:
    traverse_Declaration(func,arg,list_Declarations_elem(_node));
    break;
  case KEYappend_Declarations:
    traverse_Declarations(func,arg,append_Declarations_l1(_node));
    traverse_Declarations(func,arg,append_Declarations_l2(_node));
    break;
  }
}

void traverse_Matches(TRAVERSEFUNC func, void *arg, Matches _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Matches_skip(func,arg,_node);
}
void traverse_Matches_skip(TRAVERSEFUNC func, void *arg, Matches _node){
  switch (Matches_KEY(_node)) {
  default: fatal_error("traverse_Matches crashes");
  case KEYnil_Matches:
    break;
  case KEYlist_Matches:
    traverse_Match(func,arg,list_Matches_elem(_node));
    break;
  case KEYappend_Matches:
    traverse_Matches(func,arg,append_Matches_l1(_node));
    traverse_Matches(func,arg,append_Matches_l2(_node));
    break;
  }
}

void traverse_Types(TRAVERSEFUNC func, void *arg, Types _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Types_skip(func,arg,_node);
}
void traverse_Types_skip(TRAVERSEFUNC func, void *arg, Types _node){
  switch (Types_KEY(_node)) {
  default: fatal_error("traverse_Types crashes");
  case KEYnil_Types:
    break;
  case KEYlist_Types:
    traverse_Type(func,arg,list_Types_elem(_node));
    break;
  case KEYappend_Types:
    traverse_Types(func,arg,append_Types_l1(_node));
    traverse_Types(func,arg,append_Types_l2(_node));
    break;
  }
}

void traverse_Expressions(TRAVERSEFUNC func, void *arg, Expressions _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Expressions_skip(func,arg,_node);
}
void traverse_Expressions_skip(TRAVERSEFUNC func, void *arg, Expressions _node){
  switch (Expressions_KEY(_node)) {
  default: fatal_error("traverse_Expressions crashes");
  case KEYnil_Expressions:
    break;
  case KEYlist_Expressions:
    traverse_Expression(func,arg,list_Expressions_elem(_node));
    break;
  case KEYappend_Expressions:
    traverse_Expressions(func,arg,append_Expressions_l1(_node));
    traverse_Expressions(func,arg,append_Expressions_l2(_node));
    break;
  }
}

void traverse_Patterns(TRAVERSEFUNC func, void *arg, Patterns _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Patterns_skip(func,arg,_node);
}
void traverse_Patterns_skip(TRAVERSEFUNC func, void *arg, Patterns _node){
  switch (Patterns_KEY(_node)) {
  default: fatal_error("traverse_Patterns crashes");
  case KEYnil_Patterns:
    break;
  case KEYlist_Patterns:
    traverse_Pattern(func,arg,list_Patterns_elem(_node));
    break;
  case KEYappend_Patterns:
    traverse_Patterns(func,arg,append_Patterns_l1(_node));
    traverse_Patterns(func,arg,append_Patterns_l2(_node));
    break;
  }
}

void traverse_Actuals(TRAVERSEFUNC func, void *arg, Actuals _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_Actuals_skip(func,arg,_node);
}
void traverse_Actuals_skip(TRAVERSEFUNC func, void *arg, Actuals _node){
  switch (Actuals_KEY(_node)) {
  default: fatal_error("traverse_Actuals crashes");
  case KEYnil_Actuals:
    break;
  case KEYlist_Actuals:
    traverse_Expression(func,arg,list_Actuals_elem(_node));
    break;
  case KEYappend_Actuals:
    traverse_Actuals(func,arg,append_Actuals_l1(_node));
    traverse_Actuals(func,arg,append_Actuals_l2(_node));
    break;
  }
}

void traverse_TypeActuals(TRAVERSEFUNC func, void *arg, TypeActuals _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_TypeActuals_skip(func,arg,_node);
}
void traverse_TypeActuals_skip(TRAVERSEFUNC func, void *arg, TypeActuals _node){
  switch (TypeActuals_KEY(_node)) {
  default: fatal_error("traverse_TypeActuals crashes");
  case KEYnil_TypeActuals:
    break;
  case KEYlist_TypeActuals:
    traverse_Type(func,arg,list_TypeActuals_elem(_node));
    break;
  case KEYappend_TypeActuals:
    traverse_TypeActuals(func,arg,append_TypeActuals_l1(_node));
    traverse_TypeActuals(func,arg,append_TypeActuals_l2(_node));
    break;
  }
}

void traverse_PatternActuals(TRAVERSEFUNC func, void *arg, PatternActuals _node){
  if ((arg=func(arg,_node)) == NULL) return;
  traverse_PatternActuals_skip(func,arg,_node);
}
void traverse_PatternActuals_skip(TRAVERSEFUNC func, void *arg, PatternActuals _node){
  switch (PatternActuals_KEY(_node)) {
    default: fatal_error("traverse_PatternActuals crashes");
    case KEYnil_PatternActuals:
      break;
    case KEYlist_PatternActuals:
      traverse_Pattern(func,arg,list_PatternActuals_elem(_node));
      break;
    case KEYappend_PatternActuals:
      traverse_PatternActuals(func,arg,append_PatternActuals_l1(_node));
      traverse_PatternActuals(func,arg,append_PatternActuals_l2(_node));
      break;
  }
}

