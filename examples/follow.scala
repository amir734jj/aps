// Generated by aps2scala version 0.3.6
import basic_implicit._;
object follow_implicit {
  val follow_loaded = true;
import symbol_implicit._;
import table_implicit._;
import grammar_implicit._;
type T_FOLLOW[T_T] = T_T;
}
import follow_implicit._;

import symbol_implicit._;
import table_implicit._;
import grammar_implicit._;
trait C_FOLLOW[T_Result, T_T] extends C_TYPE[T_Result] with C_GRAMMAR[T_Result] {
  type T_Symbols;
  val t_Symbols : C_TYPE[T_Symbols]with C_SET[T_Symbols,T_Symbol];
  type T_SymbolLattice;
  val t_SymbolLattice : C_TYPE[T_SymbolLattice]with C_UNION_LATTICE[T_SymbolLattice,T_Symbol,T_Symbols];
  type T_DeclarationTable;
  val t_DeclarationTable : C_TYPE[T_DeclarationTable]with C_TABLE_LATTICE[T_DeclarationTable,T_Symbol,T_SymbolLattice];
  def v_predictTable : T_DeclarationTable;
  def v_followTable : T_DeclarationTable;
  val v_item_predict : (T_Item) => T_SymbolLattice;
  val v_item_follow : (T_Item) => T_SymbolLattice;
  val v_items_follow : (T_Items) => T_SymbolLattice;
  val v_items_predict : (T_Items) => T_SymbolLattice;
  val v_grammar_follow : (T_Grammar) => T_DeclarationTable;
  def v_epsilon : T_Symbol;
}

class M_FOLLOW[T_T](name : String,val t_T : C_TYPE[T_T] with C_GRAMMAR[T_T])
  extends Module(name)
  with C_FOLLOW[T_T,T_T]
{
  type T_Result = T_T;
  val v_equal = t_T.v_equal;
  val v_string = t_T.v_string;
  val v_assert = t_T.v_assert;
  val v_node_equivalent = t_T.v_node_equivalent;
  type T_Grammar = t_T.T_Grammar;
  val t_Grammar = t_T.t_Grammar;
  type T_Item = t_T.T_Item;
  val t_Item = t_T.t_Item;
  type T_Items = t_T.T_Items;
  val t_Items = t_T.t_Items;
  type T_Production = t_T.T_Production;
  val t_Production = t_T.t_Production;
  type T_Productions = t_T.T_Productions;
  val t_Productions = t_T.t_Productions;
  val p_terminal = t_T.p_terminal;
  val v_terminal = t_T.v_terminal;
  val p_nonterminal = t_T.p_nonterminal;
  val v_nonterminal = t_T.v_nonterminal;
  val p_prod = t_T.p_prod;
  val v_prod = t_T.v_prod;
  val p_grammar = t_T.p_grammar;
  val v_grammar = t_T.v_grammar;

  val t_Result : this.type = this;
  val t_Symbols = new M_SET[T_Symbol]("Symbols",t_Symbol)

  type T_Symbols = /*TI*/T_SET[T_Symbol];
  val t_SymbolLattice = new M_UNION_LATTICE[T_Symbol,T_Symbols]("SymbolLattice",t_Symbol,t_Symbols)
    /* dumping traits */
    with C_TYPE[T_Symbols]
    with C_SET[T_Symbols, T_Symbol] {
      override val v_assert = t_Symbols.v_assert;
      override val v_equal = t_Symbols.v_equal;
      override val v_node_equivalent = t_Symbols.v_node_equivalent;
      override val v_string = t_Symbols.v_string;
      override val v_less = t_Symbols.v_less;
      override val v_less_equal = t_Symbols.v_less_equal;
      override val v_none = t_Symbols.v_none;
      override val v_single = t_Symbols.v_single;
      override val v_append = t_Symbols.v_append;
      override val v__op_AC = t_Symbols.v__op_AC;
      override val p__op_AC = t_Symbols.p__op_AC;
      override val v_member = t_Symbols.v_member;
      override val v_union = t_Symbols.v_union;
      override val v_intersect = t_Symbols.v_intersect;
      override val v_difference = t_Symbols.v_difference;
      override val v_combine = t_Symbols.v_combine;
    }

  type T_SymbolLattice = /*TI*/T_UNION_LATTICE[T_Symbol,T_Symbols];
  val t_DeclarationTable = new M_TABLE_LATTICE[T_Symbol,T_SymbolLattice]("DeclarationTable",t_Symbol,t_SymbolLattice)

  type T_DeclarationTable = /*TI*/T_TABLE_LATTICE[T_Symbol,T_SymbolLattice];
  private class E_predictTable(anchor : Null) extends Evaluation[Null,T_DeclarationTable](anchor,"predictTable") with CircularEvaluation[Null,T_DeclarationTable] with CollectionEvaluation[Null,T_DeclarationTable] {
    override def initial : T_DeclarationTable = t_DeclarationTable.v_initial;
    override def combine(v1 : T_DeclarationTable, v2 : T_DeclarationTable) = t_DeclarationTable.v_combine(v1,v2);
    def lattice() : C_LATTICE[T_DeclarationTable] = t_DeclarationTable;

    override def compute : ValueType = c_predictTable();
  }
  private object a_predictTable extends E_predictTable(null) {}
  def v_predictTable:T_DeclarationTable = a_predictTable.get;

  private class E_followTable(anchor : Null) extends Evaluation[Null,T_DeclarationTable](anchor,"followTable") with CircularEvaluation[Null,T_DeclarationTable] with CollectionEvaluation[Null,T_DeclarationTable] {
    override def initial : T_DeclarationTable = t_DeclarationTable.v_initial;
    override def combine(v1 : T_DeclarationTable, v2 : T_DeclarationTable) = t_DeclarationTable.v_combine(v1,v2);
    def lattice() : C_LATTICE[T_DeclarationTable] = t_DeclarationTable;

    override def compute : ValueType = c_followTable();
  }
  private object a_followTable extends E_followTable(null) {}
  def v_followTable:T_DeclarationTable = a_followTable.get;

  private class E_item_predict(anchor : T_Item) extends Evaluation[T_Item,T_SymbolLattice](anchor,anchor.toString()+"."+"item_predict") with CircularEvaluation[T_Item,T_SymbolLattice] {
    def lattice() : C_LATTICE[T_SymbolLattice] = t_SymbolLattice;

    override def compute : ValueType = c_item_predict(anchor);
  }
  private object a_item_predict extends Attribute[T_Item,T_SymbolLattice](t_Item,t_SymbolLattice,"item_predict") {
    override def createEvaluation(anchor : T_Item) : Evaluation[T_Item,T_SymbolLattice] = new E_item_predict(anchor);
  }
  val v_item_predict : T_Item => T_SymbolLattice = a_item_predict.get _;

  private class E_item_follow(anchor : T_Item) extends Evaluation[T_Item,T_SymbolLattice](anchor,anchor.toString()+"."+"item_follow") with CircularEvaluation[T_Item,T_SymbolLattice] {
    def lattice() : C_LATTICE[T_SymbolLattice] = t_SymbolLattice;

    override def compute : ValueType = c_item_follow(anchor);
  }
  private object a_item_follow extends Attribute[T_Item,T_SymbolLattice](t_Item,t_SymbolLattice,"item_follow") {
    override def createEvaluation(anchor : T_Item) : Evaluation[T_Item,T_SymbolLattice] = new E_item_follow(anchor);
  }
  val v_item_follow : T_Item => T_SymbolLattice = a_item_follow.get _;

  private class E_items_follow(anchor : T_Items) extends Evaluation[T_Items,T_SymbolLattice](anchor,anchor.toString()+"."+"items_follow") with CircularEvaluation[T_Items,T_SymbolLattice] {
    override def getDefault = t_SymbolLattice.v_none();
    def lattice() : C_LATTICE[T_SymbolLattice] = t_SymbolLattice;

    override def compute : ValueType = c_items_follow(anchor);
  }
  private object a_items_follow extends Attribute[T_Items,T_SymbolLattice](t_Items,t_SymbolLattice,"items_follow") {
    override def createEvaluation(anchor : T_Items) : Evaluation[T_Items,T_SymbolLattice] = new E_items_follow(anchor);
  }
  val v_items_follow : T_Items => T_SymbolLattice = a_items_follow.get _;

  private class E_items_predict(anchor : T_Items) extends Evaluation[T_Items,T_SymbolLattice](anchor,anchor.toString()+"."+"items_predict") with CircularEvaluation[T_Items,T_SymbolLattice] {
    override def getDefault = t_SymbolLattice.v_none();
    def lattice() : C_LATTICE[T_SymbolLattice] = t_SymbolLattice;

    override def compute : ValueType = c_items_predict(anchor);
  }
  private object a_items_predict extends Attribute[T_Items,T_SymbolLattice](t_Items,t_SymbolLattice,"items_predict") {
    override def createEvaluation(anchor : T_Items) : Evaluation[T_Items,T_SymbolLattice] = new E_items_predict(anchor);
  }
  val v_items_predict : T_Items => T_SymbolLattice = a_items_predict.get _;

  private class E_grammar_follow(anchor : T_Grammar) extends Evaluation[T_Grammar,T_DeclarationTable](anchor,anchor.toString()+"."+"grammar_follow") with CircularEvaluation[T_Grammar,T_DeclarationTable] {
    def lattice() : C_LATTICE[T_DeclarationTable] = t_DeclarationTable;

    override def compute : ValueType = c_grammar_follow(anchor);
  }
  private object a_grammar_follow extends Attribute[T_Grammar,T_DeclarationTable](t_Grammar,t_DeclarationTable,"grammar_follow") {
    override def createEvaluation(anchor : T_Grammar) : Evaluation[T_Grammar,T_DeclarationTable] = new E_grammar_follow(anchor);
  }
  val v_grammar_follow : T_Grammar => T_DeclarationTable = a_grammar_follow.get _;

  val v_epsilon:T_Symbol = v_make_symbol("epsilon");
  def c_item_predict(anode : T_Item) : T_SymbolLattice = {
    val anchor = anode;
    anchor match {
      case p_terminal(v_self,v_s) => {
        if (anode eq v_self) return t_SymbolLattice.v_single(v_s);
      }
      case _ => {}
    }
    anchor match {
      case p_nonterminal(v_self,v_s) => {
        t_DeclarationTable.v_select(v_predictTable,v_s) match {
          case t_DeclarationTable.p_table_entry(_,v_0,v_item_predict_objs) => {
            if (anode eq v_self) return v_item_predict_objs;
          }
        }
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".item_predict");
  }
  def c_item_follow(anode : T_Item) : T_SymbolLattice = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Items.nodes) anchor match {
        case t_Items.p_single(v_self,v_item) => {
          if (anode eq v_item) return v_items_follow(v_self);
        }
        case _ => {}
      }
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".item_follow");
  }
  def c_items_follow(anode : T_Items) : T_SymbolLattice = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Production.nodes) anchor match {
        case p_prod(v_self,v_nt,v_items) => {
          t_DeclarationTable.v_select(v_followTable,v_nt) match {
            case t_DeclarationTable.p_table_entry(_,v_0,v_item_follow_objs) => {
              if (anode eq v_items) return v_item_follow_objs;
            }
          }
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Items.nodes) anchor match {
        case t_Items.p_append(v_self,v_items1,v_items2) => {
          if (anode eq v_items1) return v_items_predict(v_items2);
          if (anode eq v_items2) return v_items_follow(v_self);
        }
        case _ => {}
      }
    }
    return t_SymbolLattice.v_none();
  }
  def c_items_predict(anode : T_Items) : T_SymbolLattice = {
    val anchor = anode;
    anchor match {
      case t_Items.p_none(v_self) => {
        if (anode eq v_self) return v_items_follow(v_self);
      }
      case _ => {}
    }
    anchor match {
      case t_Items.p_single(v_self,v_item) => {
        if (anode eq v_self) return v_item_predict(v_item);
      }
      case _ => {}
    }
    anchor match {
      case t_Items.p_append(v_self,v_items1,v_items2) => {
        if (anode eq v_self) return v_items_predict(v_items1);
      }
      case _ => {}
    }
    return t_SymbolLattice.v_none();
  }
  def c_grammar_follow(anode : T_Grammar) : T_DeclarationTable = {
    val anchor = anode;
    anchor match {
      case p_grammar(v_self,v_prods) => {
        if (anode eq v_self) return v_followTable;
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".grammar_follow");
  }
  def c_predictTable() : T_DeclarationTable = {
    var collection : T_DeclarationTable = t_DeclarationTable.v_initial;
    for (anchor <- t_Result.t_Production.nodes) anchor match {
      case p_prod(v_self,v_nt,v_items) => {
        collection = t_DeclarationTable.v_combine(collection,t_DeclarationTable.v_table_entry(v_nt,v_items_predict(v_items)));
      }
      case _ => {}
    }
    return collection;
  }
  def c_followTable() : T_DeclarationTable = {
    var collection : T_DeclarationTable = t_DeclarationTable.v_initial;
    for (anchor <- t_Result.t_Item.nodes) anchor match {
      case p_nonterminal(v_self,v_s) => {
        collection = t_DeclarationTable.v_combine(collection,t_DeclarationTable.v_table_entry(v_s,v_item_follow(v_self)));
      }
      case _ => {}
    }
    return collection;
  }
  override def finish() : Unit = {
    a_predictTable.get;
    a_followTable.get;
    a_item_predict.finish;
    a_item_follow.finish;
    a_items_follow.finish;
    a_items_predict.finish;
    a_grammar_follow.finish;
    super.finish();
  }

}

