// Generated by aps2scala version 0.3.6
import basic_implicit._;
object test_cycle_implicit {
  val test_cycle_loaded = true;
import tiny_implicit._;
type T_TEST_CYCLE[T_T] = T_T;
}
import test_cycle_implicit._;

import tiny_implicit._;
trait C_TEST_CYCLE[T_Result, T_T] extends C_TYPE[T_Result] with C_TINY[T_Result] {
  type T_Integers;
  val t_Integers : C_TYPE[T_Integers]with C_SET[T_Integers,T_Integer];
  type T_IntegerLattice;
  val t_IntegerLattice : C_TYPE[T_IntegerLattice]with C_UNION_LATTICE[T_IntegerLattice,T_Integer,T_Integers];
  def v_leaves : T_IntegerLattice;
  val v_partial : (T_Wood) => T_IntegerLattice;
}

class M_TEST_CYCLE[T_T](name : String,val t_T : C_TYPE[T_T] with C_TINY[T_T])
  extends Module(name)
  with C_TEST_CYCLE[T_T,T_T]
{
  type T_Result = T_T;
  val v_equal = t_T.v_equal;
  val v_string = t_T.v_string;
  val v_assert = t_T.v_assert;
  val v_node_equivalent = t_T.v_node_equivalent;
  type T_Root = t_T.T_Root;
  val t_Root = t_T.t_Root;
  type T_Wood = t_T.T_Wood;
  val t_Wood = t_T.t_Wood;
  val p_root = t_T.p_root;
  val v_root = t_T.v_root;
  val p_branch = t_T.p_branch;
  val v_branch = t_T.v_branch;
  val p_leaf = t_T.p_leaf;
  val v_leaf = t_T.v_leaf;

  val t_Result : this.type = this;
  val t_Integers = new M_SET[T_Integer]("Integers",t_Integer);
  type T_Integers = /*TI*/T_SET[T_Integer];
  val t_IntegerLattice = new M_UNION_LATTICE[T_Integer,T_Integers]("IntegerLattice",t_Integer,t_Integers);
  type T_IntegerLattice = /*TI*/T_UNION_LATTICE[T_Integer,T_Integers];
  private class E_leaves(anchor : Null) extends Evaluation[Null,T_IntegerLattice](anchor,"leaves") with CircularEvaluation[Null,T_IntegerLattice] with CollectionEvaluation[Null,T_IntegerLattice] {
    override def initial : T_IntegerLattice = t_IntegerLattice.v_initial;
    override def combine(v1 : T_IntegerLattice, v2 : T_IntegerLattice) = t_IntegerLattice.v_combine(v1,v2);
    def lattice() : C_LATTICE[T_IntegerLattice] = t_IntegerLattice;

  }
  private object a_leaves extends E_leaves(null) {}
  def v_leaves:T_IntegerLattice = a_leaves.get;

  private class E_partial(anchor : T_Wood) extends Evaluation[T_Wood,T_IntegerLattice](anchor,anchor.toString()+"."+"partial") with CircularEvaluation[T_Wood,T_IntegerLattice] {
    def lattice() : C_LATTICE[T_IntegerLattice] = t_IntegerLattice;

  }
  private object a_partial extends Attribute[T_Wood,T_IntegerLattice](t_Wood,t_IntegerLattice,"partial") {
    override def createEvaluation(anchor : T_Wood) : Evaluation[T_Wood,T_IntegerLattice] = new E_partial(anchor);
  }
  val v_partial : T_Wood => T_IntegerLattice = a_partial.get _;

