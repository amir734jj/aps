module GEN[T :: BASIC[]] 
begin
   type A := T;
   type B := LIST[T];
   type C;
   constructor con() : C;
   function bf1(c1 : C; c2 : C) : Boolean := false;
   function bf2(c1 : C; c2 : C) : Boolean := true;
   function cf(c1 : C; c2 : C) : C := c1;
   type D := Result;
   type E := MAKE_LATTICE[C](con(),bf1,bf2,cf,cf);
   type F := Integer;

   type G := D;
   type H := G;

   type Y := F;
   type X := Y;

   type Z := EXT[T];
   type l := GEN[T];

   type F1 := function(c1 : C; c2 : C) : C;
   type F2 := function(c1 : String; c2 : String) : String;
   type F3 := function(c1 : A; c2 : A) : A;
   type F4 := function(c1 : B; c2 : C) : B;
   type F5 := function(c1 : T; c2 : Y) : D;
   type F6 := function(c1 : Integer; c2 : Y) : D;
   type F7 := function(c1 : Integer; c2 : Y) : X;
end;

module EXT[T :: BASIC[]] extends T
begin
   type N := T;
   type O := LIST[T];
   type P;  -- fresh type
   constructor con() : P;
   function bf1(c1 : P; c2 : P) : Boolean := false;
   function bf2(c1 : P; c2 : P) : Boolean := true;
   function cf(c1 : P; c2 : P) : P := c1;
   type Q := Result;
   type R := MAKE_LATTICE[P](con(),bf1,bf2,cf,cf);
   type S := Integer;
   type Interesting := MAKE_LATTICE[Boolean](con(),bf1,bf2,cf,cf);
   type A := B;
   type B := C;
   type C := Result;

   type U := GEN[T]();
   type V := U$E;
   type W := U$X;
   type X := U$A;

   -- type Z := U$Z$X;
   
   -- Use of B should be Result
  type Test2 := function(c1 : C; c2 : T) : T;


  type F1 := function(c1 : C; c2 : C) : C;
  type F2 := function(c1 : X; c2 : C) : String;
  type F3 := function(c1 : C; c2 : Q) : X;
  type F4 := function(c1 : B; c2 : C) : C;
  type F5 := function(c1 : T; c2 : Q) : Q;

  type iU := Integer;
  type orU := OrLattice;
end;

-- String
type G0 := GEN[String];
type G1 := G0;
type G2 := G0$D;
type G3 := G1$D;

-- String
type H0 := GEN[String];
type H1 := H0;
type H2 := H0$D;
type H3 := H1$D;
type H4 := H1$H;

-- String
type A0 := GEN[Integer];
type A1 := A0;
type A2 := A0$D;
type A3 := A1$D;
type A4 := A1$H;

-- G0$C
type I0 := G0$C;
type I1 := G1$E;

-- H0$C
type J0 := H0$C;
type J1 := H1$E;

-- G0$B
type K0 := G0$B;
type K1 := G1$B;

-- H0$B
type L0 := H0$B;
type L1 := H1$B;

-- EXT is not a generating modules because it extends an exsisting type but GEN creates new type
-- use of a string String
type N0 := EXT[String];
type N1 := EXT[String];
type N2 := String;
type N3 := N1$N;
type N4 := N0$Q;
type N5 := N0$W;
type N6 := N1$U;

-- Integer
type O0 := EXT[Integer];
type O1 := G0$F;
type O2 := H0$F;
type O3 := N1$S;
-- type O4 := O0$Result;
type O5 := O0$Q;
type O6 := Integer;
type O7 := O0$C;

-- N0$P
type P0 := N0$P;
type P1 := N0$R;

type P2 := N0$Interesting;

-- I think that Q0 is supposed to be different than P0:
-- N0 and N1 has the base types but different types
-- N1$P 
type Q0 := N1$P;
type Q1 := N1$R;

-- O0$P
type R0 := O0$P;
type R1 := O0$R;

-- N1$O
type S0 := N1$O;

-- N0$O
type T0 := N0$O;

-- Use of U0
type U0 := private Integer;

type G0F1 := G0$F1; -- (C,C)=>C
type G0F2 := G0$F2; -- (String,String)=>String
type G0F3 := G0$F3; -- (String,String)=>String
type G0F4 := G0$F4; -- (B,C)=>B
type G0F5 := G0$F5; -- (String,Integer)=>G0
type G0F6 := G0$F6; -- (Integer,Integer)=>G0
type G0F7 := G0$F7; -- (Integer,Integer)=>Integer

type N0F1 := N0$F1; -- (String,String)=>String
type N0F2 := N0$F2; -- (String,String)=>String
type N0F3 := N0$F3; -- (String,String)=>String
type N0F4 := N0$F4; -- (String,String)=>String
type N0F5 := N0$F5; -- (String,String)=>String

type iU := Integer;
type orU := OrLattice;