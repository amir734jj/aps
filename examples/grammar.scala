// Generated by aps2scala version 0.3.6
import basic_implicit._;
object grammar_implicit {
  val grammar_loaded = true;
import symbol_implicit._;
import table_implicit._;
  type T_I = T_Symbol;
  val t_I = t_Symbol;
}
import grammar_implicit._;

import symbol_implicit._;
import table_implicit._;
trait C_GRAMMAR[T_Result] extends C_TYPE[T_Result] {
  type T_Grammar <: Node;
  val t_Grammar : C_PHYLUM[T_Grammar];
  type T_Item <: Node;
  val t_Item : C_PHYLUM[T_Item];
  type T_Items <: Node;
  val t_Items : C_PHYLUM[T_Items]with C_SEQUENCE[T_Items,T_Item];
  type T_Production <: Node;
  val t_Production : C_PHYLUM[T_Production];
  type T_Productions <: Node;
  val t_Productions : C_PHYLUM[T_Productions]with C_SEQUENCE[T_Productions,T_Production];
  val p_terminal : PatternFunction[(T_Item,T_Symbol)];
  def v_terminal : (T_Symbol) => T_Item;
  val p_nonterminal : PatternFunction[(T_Item,T_Symbol)];
  def v_nonterminal : (T_Symbol) => T_Item;
  val p_prod : PatternFunction[(T_Production,T_Symbol,T_Items)];
  def v_prod : (T_Symbol,T_Items) => T_Production;
  val p_grammar : PatternFunction[(T_Grammar,T_Productions)];
  def v_grammar : (T_Productions) => T_Grammar;
}

abstract class T_GRAMMAR(t : C_GRAMMAR[T_GRAMMAR]) extends Value(t) { }

class M_GRAMMAR(name : String)
  extends I_TYPE[T_GRAMMAR](name)
  with C_GRAMMAR[T_GRAMMAR]
{
  val t_Result : this.type = this;
  abstract class T_Grammar(t : I_PHYLUM[T_Grammar]) extends Node(t) {
    override def isRooted : Boolean = true;
  }
  val t_Grammar = new I_PHYLUM[T_Grammar]("Grammar");

  abstract class T_Item(t : I_PHYLUM[T_Item]) extends Node(t) {}
  val t_Item = new I_PHYLUM[T_Item]("Item");

  val t_Items = new M_SEQUENCE[T_Item]("Items",t_Item)

  type T_Items = /*TI*/T_SEQUENCE[T_Item];
  abstract class T_Production(t : I_PHYLUM[T_Production]) extends Node(t) {}
  val t_Production = new I_PHYLUM[T_Production]("Production");

  val t_Productions = new M_SEQUENCE[T_Production]("Productions",t_Production)

  type T_Productions = /*TI*/T_SEQUENCE[T_Production];
  case class c_terminal(v_s : T_Symbol) extends T_Item(t_Item) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "terminal("+ v_s+ ")";
    }
  }
  def u_terminal(x:Any) : Option[(T_Item,T_Symbol)] = x match {
    case x@c_terminal(v_s) => Some((x,v_s));
    case _ => None };
  val v_terminal = f_terminal _;
  def f_terminal(v_s : T_Symbol):T_Item = c_terminal(v_s).register;
  val p_terminal = new PatternFunction[(T_Item,T_Symbol)](u_terminal);

  case class c_nonterminal(v_s : T_Symbol) extends T_Item(t_Item) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "nonterminal("+ v_s+ ")";
    }
  }
  def u_nonterminal(x:Any) : Option[(T_Item,T_Symbol)] = x match {
    case x@c_nonterminal(v_s) => Some((x,v_s));
    case _ => None };
  val v_nonterminal = f_nonterminal _;
  def f_nonterminal(v_s : T_Symbol):T_Item = c_nonterminal(v_s).register;
  val p_nonterminal = new PatternFunction[(T_Item,T_Symbol)](u_nonterminal);

  case class c_prod(v_nt : T_Symbol,v_children : T_Items) extends T_Production(t_Production) {
    override def children : List[Node] = List(v_children);
    override def toString() : String = Debug.with_level {
      "prod("+ v_nt + ","+ v_children+ ")";
    }
  }
  def u_prod(x:Any) : Option[(T_Production,T_Symbol,T_Items)] = x match {
    case x@c_prod(v_nt,v_children) => Some((x,v_nt,v_children));
    case _ => None };
  val v_prod = f_prod _;
  def f_prod(v_nt : T_Symbol, v_children : T_Items):T_Production = c_prod(v_nt,v_children).register;
  val p_prod = new PatternFunction[(T_Production,T_Symbol,T_Items)](u_prod);

  case class c_grammar(v_prods : T_Productions) extends T_Grammar(t_Grammar) {
    override def children : List[Node] = List(v_prods);
    override def toString() : String = Debug.with_level {
      "grammar("+ v_prods+ ")";
    }
  }
  def u_grammar(x:Any) : Option[(T_Grammar,T_Productions)] = x match {
    case x@c_grammar(v_prods) => Some((x,v_prods));
    case _ => None };
  val v_grammar = f_grammar _;
  def f_grammar(v_prods : T_Productions):T_Grammar = c_grammar(v_prods).register;
  val p_grammar = new PatternFunction[(T_Grammar,T_Productions)](u_grammar);

  override def finish() : Unit = {
    super.finish();
  }

}

