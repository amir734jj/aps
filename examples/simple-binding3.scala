// Generated by aps2scala version 0.3.6
import basic_implicit._;
object simple_binding3_implicit {
  val simple_binding3_loaded = true;
import simple_implicit._;
type T_NAME_RESOLUTION[T_T] = T_T;
}
import simple_binding3_implicit._;

import simple_implicit._;
trait C_NAME_RESOLUTION[T_Result, T_T] extends C_TYPE[T_Result] with C_SIMPLE[T_Result] {
  type T_ShapeStructure <: Node;
  val t_ShapeStructure : C_PHYLUM[T_ShapeStructure];
  val p_shape : PatternFunction[(T_ShapeStructure,T_String)];
  def v_shape : (T_String) => T_ShapeStructure;
  type T_Shape;
  val t_Shape : C_TYPE[T_Shape];
  type T_Contour <: Node;
  val t_Contour : C_PHYLUM[T_Contour];
  val p_contour : PatternFunction[(T_Contour)];
  def v_contour : () => T_Contour;
  type T_Scope;
  val t_Scope : C_TYPE[T_Scope];
  val v_enclosing : (T_Contour) => T_Scope;
  type T_Entity <: Node;
  val t_Entity : C_PHYLUM[T_Entity];
  type T_EntityRef;
  val t_EntityRef : C_TYPE[T_EntityRef];
  val p_entity : PatternFunction[(T_Entity)];
  def v_entity : () => T_Entity;
  val v_entity_name : (T_Entity) => T_String;
  val v_entity_shape : (T_Entity) => T_Shape;
  val v_entity_used : (T_Entity) => T_OrLattice;
  type T_Entities;
  val t_Entities : C_TYPE[T_Entities]with C_BAG[T_Entities,T_EntityRef];
  val v_entities : (T_Contour) => T_Entities;
  type T_Messages;
  val t_Messages : C_TYPE[T_Messages]with C_BAG[T_Messages,T_String];
  def v_msgs : T_Messages;
  def v_root_scope : T_Scope;
  def v_not_found : T_EntityRef;
  def v_no_shape : T_Shape;
  def v_int_shape : T_Shape;
  def v_str_shape : T_Shape;
  val v_block_scope : (T_Block) => T_Scope;
  val v_decls_scope : (T_Decls) => T_Scope;
  val v_decl_scope : (T_Decl) => T_Scope;
  val v_stmts_scope : (T_Stmts) => T_Scope;
  val v_stmt_scope : (T_Stmt) => T_Scope;
  val v_expr_scope : (T_Expr) => T_Scope;
  val v_type_shape : (T_Type) => T_Shape;
  val v_expr_shape : (T_Expr) => T_Shape;
  val v_find : (T_String,T_Entities) => T_EntityRef;
  val v_lookup : (T_String,T_Scope) => T_EntityRef;
}

class M_NAME_RESOLUTION[T_T](name : String,val t_T : C_TYPE[T_T] with C_SIMPLE[T_T])
  extends Module(name)
  with C_NAME_RESOLUTION[T_T,T_T]
{
  type T_Result = T_T;
  val v_equal = t_T.v_equal;
  val v_string = t_T.v_string;
  val v_assert = t_T.v_assert;
  val v_node_equivalent = t_T.v_node_equivalent;
  type T_Program = t_T.T_Program;
  val t_Program = t_T.t_Program;
  type T_Block = t_T.T_Block;
  val t_Block = t_T.t_Block;
  type T_Decls = t_T.T_Decls;
  val t_Decls = t_T.t_Decls;
  type T_Decl = t_T.T_Decl;
  val t_Decl = t_T.t_Decl;
  type T_Type = t_T.T_Type;
  val t_Type = t_T.t_Type;
  type T_Stmts = t_T.T_Stmts;
  val t_Stmts = t_T.t_Stmts;
  type T_Stmt = t_T.T_Stmt;
  val t_Stmt = t_T.t_Stmt;
  type T_Expr = t_T.T_Expr;
  val t_Expr = t_T.t_Expr;
  val p_program = t_T.p_program;
  val v_program = t_T.v_program;
  val p_block = t_T.p_block;
  val v_block = t_T.v_block;
  val p_no_decls = t_T.p_no_decls;
  val v_no_decls = t_T.v_no_decls;
  val p_xcons_decls = t_T.p_xcons_decls;
  val v_xcons_decls = t_T.v_xcons_decls;
  val p_decl = t_T.p_decl;
  val v_decl = t_T.v_decl;
  val p_integer_type = t_T.p_integer_type;
  val v_integer_type = t_T.v_integer_type;
  val p_string_type = t_T.p_string_type;
  val v_string_type = t_T.v_string_type;
  val p_no_stmts = t_T.p_no_stmts;
  val v_no_stmts = t_T.v_no_stmts;
  val p_xcons_stmts = t_T.p_xcons_stmts;
  val v_xcons_stmts = t_T.v_xcons_stmts;
  val p_block_stmt = t_T.p_block_stmt;
  val v_block_stmt = t_T.v_block_stmt;
  val p_assign_stmt = t_T.p_assign_stmt;
  val v_assign_stmt = t_T.v_assign_stmt;
  val p_intconstant = t_T.p_intconstant;
  val v_intconstant = t_T.v_intconstant;
  val p_strconstant = t_T.p_strconstant;
  val v_strconstant = t_T.v_strconstant;
  val p_variable = t_T.p_variable;
  val v_variable = t_T.v_variable;

  val t_Result : this.type = this;
  abstract class T_ShapeStructure(t : I_PHYLUM[T_ShapeStructure]) extends Node(t) {}
  val t_ShapeStructure = new I_PHYLUM[T_ShapeStructure]("ShapeStructure");

  case class c_shape(v_name : T_String) extends T_ShapeStructure(t_ShapeStructure) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "shape("+ v_name+ ")";
    }
  }
  def u_shape(x:Any) : Option[(T_ShapeStructure,T_String)] = x match {
    case x@c_shape(v_name) => Some((x,v_name));
    case _ => None };
  val v_shape = f_shape _;
  def f_shape(v_name : T_String):T_ShapeStructure = c_shape(v_name).register;
  val p_shape = new PatternFunction[(T_ShapeStructure,T_String)](u_shape);

  type T_Shape = T_ShapeStructure;
  val t_Shape = t_ShapeStructure;
  abstract class T_Contour(t : I_PHYLUM[T_Contour]) extends Node(t) {}
  val t_Contour = new I_PHYLUM[T_Contour]("Contour");

  case class c_contour() extends T_Contour(t_Contour) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "contour("+ ")";
    }
  }
  def u_contour(x:Any) : Option[(T_Contour)] = x match {
    case x@c_contour() => Some(x);
    case _ => None };
  val v_contour = f_contour _;
  def f_contour():T_Contour = c_contour().register;
  val p_contour = new PatternFunction[(T_Contour)](u_contour);

  type T_Scope = T_Contour;
  val t_Scope = t_Contour;
  private class E_enclosing(anchor : T_Contour) extends Evaluation[T_Contour,T_Scope](anchor,anchor.toString()+"."+"enclosing") {
  }
  private object a_enclosing extends Attribute[T_Contour,T_Scope](t_Contour,t_Scope,"enclosing") {
    override def createEvaluation(anchor : T_Contour) : Evaluation[T_Contour,T_Scope] = new E_enclosing(anchor);
  }
  val v_enclosing : T_Contour => T_Scope = a_enclosing.get _;

  abstract class T_Entity(t : I_PHYLUM[T_Entity]) extends Node(t) {}
  val t_Entity = new I_PHYLUM[T_Entity]("Entity");

  type T_EntityRef = T_Entity;
  val t_EntityRef = t_Entity;
  case class c_entity() extends T_Entity(t_Entity) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "entity("+ ")";
    }
  }
  def u_entity(x:Any) : Option[(T_Entity)] = x match {
    case x@c_entity() => Some(x);
    case _ => None };
  val v_entity = f_entity _;
  def f_entity():T_Entity = c_entity().register;
  val p_entity = new PatternFunction[(T_Entity)](u_entity);

  private class E_entity_name(anchor : T_Entity) extends Evaluation[T_Entity,T_String](anchor,anchor.toString()+"."+"entity_name") {
  }
  private object a_entity_name extends Attribute[T_Entity,T_String](t_Entity,t_String,"entity_name") {
    override def createEvaluation(anchor : T_Entity) : Evaluation[T_Entity,T_String] = new E_entity_name(anchor);
  }
  val v_entity_name : T_Entity => T_String = a_entity_name.get _;

  private class E_entity_shape(anchor : T_Entity) extends Evaluation[T_Entity,T_Shape](anchor,anchor.toString()+"."+"entity_shape") {
  }
  private object a_entity_shape extends Attribute[T_Entity,T_Shape](t_Entity,t_Shape,"entity_shape") {
    override def createEvaluation(anchor : T_Entity) : Evaluation[T_Entity,T_Shape] = new E_entity_shape(anchor);
  }
  val v_entity_shape : T_Entity => T_Shape = a_entity_shape.get _;

  private class E_entity_used(anchor : T_Entity) extends Evaluation[T_Entity,T_OrLattice](anchor,anchor.toString()+"."+"entity_used") with CollectionEvaluation[T_Entity,T_OrLattice] {
    override def initial : T_OrLattice = t_OrLattice.v_initial;
    override def combine(v1 : T_OrLattice, v2 : T_OrLattice) = t_OrLattice.v_combine(v1,v2);
  }
  private object a_entity_used extends Attribute[T_Entity,T_OrLattice](t_Entity,t_OrLattice,"entity_used") {
    override def createEvaluation(anchor : T_Entity) : Evaluation[T_Entity,T_OrLattice] = new E_entity_used(anchor);
  }
  val v_entity_used : T_Entity => T_OrLattice = a_entity_used.get _;

  val t_Entities = new M_BAG[T_EntityRef]("Entities",t_EntityRef);
  type T_Entities = /*TI*/T_BAG[T_EntityRef];
  private class E_entities(anchor : T_Contour) extends Evaluation[T_Contour,T_Entities](anchor,anchor.toString()+"."+"entities") with CollectionEvaluation[T_Contour,T_Entities] {
    override def initial : T_Entities = t_Entities.v_initial;
    override def combine(v1 : T_Entities, v2 : T_Entities) = t_Entities.v_combine(v1,v2);
  }
  private object a_entities extends Attribute[T_Contour,T_Entities](t_Contour,t_Entities,"entities") {
    override def createEvaluation(anchor : T_Contour) : Evaluation[T_Contour,T_Entities] = new E_entities(anchor);
  }
  val v_entities : T_Contour => T_Entities = a_entities.get _;

  val t_Messages = new M_BAG[T_String]("Messages",t_String);
  type T_Messages = /*TI*/T_BAG[T_String];
  private class E_msgs(anchor : Null) extends Evaluation[Null,T_Messages](anchor,"msgs") with CollectionEvaluation[Null,T_Messages] {
    override def initial : T_Messages = t_Messages.v_initial;
    override def combine(v1 : T_Messages, v2 : T_Messages) = t_Messages.v_combine(v1,v2);
  }
  private object a_msgs extends E_msgs(null) {}
  def v_msgs:T_Messages = a_msgs.get;

  val v_root_scope:T_Scope = new M__basic_8[ T_Scope](t_Scope).v_nil;
  val v_not_found:T_EntityRef = new M__basic_8[ T_EntityRef](t_EntityRef).v_nil;
  val v_no_shape:T_Shape = new M__basic_8[ T_Shape](t_Shape).v_nil;
  val v_int_shape:T_Shape = v_shape("integer");
  val v_str_shape:T_Shape = v_shape("string");
  private class E_block_scope(anchor : T_Block) extends Evaluation[T_Block,T_Scope](anchor,anchor.toString()+"."+"block_scope") {
  }
  private object a_block_scope extends Attribute[T_Block,T_Scope](t_Block,t_Scope,"block_scope") {
    override def createEvaluation(anchor : T_Block) : Evaluation[T_Block,T_Scope] = new E_block_scope(anchor);
  }
  val v_block_scope : T_Block => T_Scope = a_block_scope.get _;

  private class E_decls_scope(anchor : T_Decls) extends Evaluation[T_Decls,T_Scope](anchor,anchor.toString()+"."+"decls_scope") {
  }
  private object a_decls_scope extends Attribute[T_Decls,T_Scope](t_Decls,t_Scope,"decls_scope") {
    override def createEvaluation(anchor : T_Decls) : Evaluation[T_Decls,T_Scope] = new E_decls_scope(anchor);
  }
  val v_decls_scope : T_Decls => T_Scope = a_decls_scope.get _;

  private class E_decl_scope(anchor : T_Decl) extends Evaluation[T_Decl,T_Scope](anchor,anchor.toString()+"."+"decl_scope") {
  }
  private object a_decl_scope extends Attribute[T_Decl,T_Scope](t_Decl,t_Scope,"decl_scope") {
    override def createEvaluation(anchor : T_Decl) : Evaluation[T_Decl,T_Scope] = new E_decl_scope(anchor);
  }
  val v_decl_scope : T_Decl => T_Scope = a_decl_scope.get _;

  private class E_stmts_scope(anchor : T_Stmts) extends Evaluation[T_Stmts,T_Scope](anchor,anchor.toString()+"."+"stmts_scope") {
  }
  private object a_stmts_scope extends Attribute[T_Stmts,T_Scope](t_Stmts,t_Scope,"stmts_scope") {
    override def createEvaluation(anchor : T_Stmts) : Evaluation[T_Stmts,T_Scope] = new E_stmts_scope(anchor);
  }
  val v_stmts_scope : T_Stmts => T_Scope = a_stmts_scope.get _;

  private class E_stmt_scope(anchor : T_Stmt) extends Evaluation[T_Stmt,T_Scope](anchor,anchor.toString()+"."+"stmt_scope") {
  }
  private object a_stmt_scope extends Attribute[T_Stmt,T_Scope](t_Stmt,t_Scope,"stmt_scope") {
    override def createEvaluation(anchor : T_Stmt) : Evaluation[T_Stmt,T_Scope] = new E_stmt_scope(anchor);
  }
  val v_stmt_scope : T_Stmt => T_Scope = a_stmt_scope.get _;

  private class E_expr_scope(anchor : T_Expr) extends Evaluation[T_Expr,T_Scope](anchor,anchor.toString()+"."+"expr_scope") {
  }
  private object a_expr_scope extends Attribute[T_Expr,T_Scope](t_Expr,t_Scope,"expr_scope") {
    override def createEvaluation(anchor : T_Expr) : Evaluation[T_Expr,T_Scope] = new E_expr_scope(anchor);
  }
  val v_expr_scope : T_Expr => T_Scope = a_expr_scope.get _;

  private class E_type_shape(anchor : T_Type) extends Evaluation[T_Type,T_Shape](anchor,anchor.toString()+"."+"type_shape") {
  }
  private object a_type_shape extends Attribute[T_Type,T_Shape](t_Type,t_Shape,"type_shape") {
    override def createEvaluation(anchor : T_Type) : Evaluation[T_Type,T_Shape] = new E_type_shape(anchor);
  }
  val v_type_shape : T_Type => T_Shape = a_type_shape.get _;

  private class E_expr_shape(anchor : T_Expr) extends Evaluation[T_Expr,T_Shape](anchor,anchor.toString()+"."+"expr_shape") {
  }
  private object a_expr_shape extends Attribute[T_Expr,T_Shape](t_Expr,t_Shape,"expr_shape") {
    override def createEvaluation(anchor : T_Expr) : Evaluation[T_Expr,T_Shape] = new E_expr_shape(anchor);
  }
  val v_expr_shape : T_Expr => T_Shape = a_expr_shape.get _;

  private class E1_c(anchor : t_Result.T_Block) extends Evaluation[t_Result.T_Block,T_Contour](anchor,anchor.toString()+"."+"c") {
  }
  private object a1_c extends Attribute[t_Result.T_Block,T_Contour](t_Result.t_Block,t_Contour,"c") {
    override def createEvaluation(anchor : t_Result.T_Block) : Evaluation[t_Result.T_Block,T_Contour] = new E1_c(anchor);
  }
  private class E2_e(anchor : t_Result.T_Decl) extends Evaluation[t_Result.T_Decl,T_Entity](anchor,anchor.toString()+"."+"e") {
  }
  private object a2_e extends Attribute[t_Result.T_Decl,T_Entity](t_Result.t_Decl,t_Entity,"e") {
    override def createEvaluation(anchor : t_Result.T_Decl) : Evaluation[t_Result.T_Decl,T_Entity] = new E2_e(anchor);
  }
  private class E3_decl(anchor : t_Result.T_Expr) extends Evaluation[t_Result.T_Expr,T_EntityRef](anchor,anchor.toString()+"."+"decl") {
  }
  private object a3_decl extends Attribute[t_Result.T_Expr,T_EntityRef](t_Result.t_Expr,t_EntityRef,"decl") {
    override def createEvaluation(anchor : t_Result.T_Expr) : Evaluation[t_Result.T_Expr,T_EntityRef] = new E3_decl(anchor);
  }
  val v_find = f_find _;
  def f_find(v_name : T_String, v_es : T_Entities):T_EntityRef = {
    var  v1_result : T_EntityRef = null.asInstanceOf[T_EntityRef];
    var  v2_e1 : T_Entity = null.asInstanceOf[T_Entity];
    // find.G[find]'shared_info is ready now.
    // find.es is ready now.
    val node = v_es;
    node match {
    case t_Entities.p_none(_) => {
      // find.es$entity_name is ready now.
      // find.es$entity_shape is ready now.
      // find.name is ready now.
      v1_result = new M__basic_8[ T_EntityRef](t_EntityRef).v_nil;
      // find.result$entity_shape
