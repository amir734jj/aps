// Generated by aps2scala version 0.3.6
import basic_implicit._;
object cool_dynamic_semant_implicit {
  val cool_dynamic_semant_loaded = true;
import cool_symbol_implicit._;
import cool_tree_implicit._;
import table_implicit._;
type T_COOL_SEMANT[T_T] = T_T;
}
import cool_dynamic_semant_implicit._;

import cool_symbol_implicit._;
import cool_tree_implicit._;
import table_implicit._;
trait C_COOL_SEMANT[T_Result, T_T] extends C_TYPE[T_Result] with C_COOL[T_Result] {
  def v_Any : T_Symbol;
  def v_Int : T_Symbol;
  def v_Bool : T_Symbol;
  def v_Str : T_Symbol;
  def v_This : T_Symbol;
  def v_Native : T_Symbol;
  def v_Main : T_Symbol;
  def v_Unit : T_Symbol;
  def v_Nothing : T_Symbol;
  def v_Null : T_Symbol;
  def v_null : T_Symbol;
  def v_empty : T_Symbol;
  def v_errorType : T_Symbol;
  type T_ClassReference;
  val t_ClassReference : C_TYPE[T_ClassReference];
  type T_ClassReferences;
  val t_ClassReferences : C_TYPE[T_ClassReferences]with C_BAG[T_ClassReferences,T_ClassReference];
  type T_ClassTable;
  val t_ClassTable : C_TYPE[T_ClassTable]with C_TABLE[T_ClassTable,T_Symbol,T_ClassReferences];
  def v_class_table : T_ClassTable;
  val v_find_class : (T_Symbol) => T_ClassReference;
  val v_class_parent : (T_Symbol) => T_Symbol;
  type T_Messages;
  val t_Messages : C_TYPE[T_Messages]with C_BAG[T_Messages,T_String];
  def v_messages : T_Messages;
  val v_class_is_circular : (T_Class) => T_AndLattice;
  val v_features_class : (T_Features) => T_ClassReference;
  val v_feature_class : (T_Feature) => T_ClassReference;
  type T_FeatureRemote;
  val t_FeatureRemote : C_TYPE[T_FeatureRemote];
  type T_FeatureReferences;
  val t_FeatureReferences : C_TYPE[T_FeatureReferences]with C_BAG[T_FeatureReferences,T_FeatureRemote];
  type T_AttrTable;
  val t_AttrTable : C_TYPE[T_AttrTable]with C_TABLE[T_AttrTable,T_Symbol,T_FeatureReferences];
  val v_class_attr_table : (T_Class) => T_AttrTable;
  type T_MethodTable;
  val t_MethodTable : C_TYPE[T_MethodTable]with C_TABLE[T_MethodTable,T_Symbol,T_FeatureReferences];
  val v_class_meth_table : (T_Class) => T_MethodTable;
  type T_CoolType = T_Symbol;
  val t_CoolType : C_TYPE[T_CoolType]with C_SYMBOL[T_CoolType];
  type T_CoolTypes;
  val t_CoolTypes : C_TYPE[T_CoolTypes]with C_MULTISET[T_CoolTypes,T_CoolType];
  type T_Contour;
  val t_Contour : C_TYPE[T_Contour]with C_TABLE[T_Contour,T_Symbol,T_CoolTypes];
  type T_ScopeObject <: Node;
  val t_ScopeObject : C_PHYLUM[T_ScopeObject];
  type T_ScopeObjectRemote;
  val t_ScopeObjectRemote : C_TYPE[T_ScopeObjectRemote];
  val p_scope : PatternFunction[(T_ScopeObject,T_String,T_ScopeObjectRemote)];
  def v_scope : (T_String,T_ScopeObjectRemote) => T_ScopeObject;
  type T_Scope;
  val t_Scope : C_TYPE[T_Scope];
  val v_table : (T_ScopeObject) => T_Contour;
  type T_Environment = T_Scope;
  val t_Environment : C_TYPE[T_Environment];
  val v_env_filename : (T_Environment) => T_String;
  val v_make_scope : (T_Environment) => T_Scope;
  val v_message : (T_Environment,T_Integer,T_String) => T_Messages;
  val v_class_env : (T_Class) => T_Environment;
  val v_formals_env : (T_Formals) => T_Environment;
  val v_formal_env : (T_Formal) => T_Environment;
  val v_exprs_env : (T_Expressions) => T_Environment;
  val v_expr_env : (T_Expression) => T_Environment;
  type T_CoolTypeList;
  val t_CoolTypeList : C_TYPE[T_CoolTypeList]with C_LIST[T_CoolTypeList,T_CoolType];
  val v_expr_type : (T_Expression) => T_CoolType;
  val v_exprs_type : (T_Expressions) => T_CoolTypeList;
  val v_formal_type : (T_Formal) => T_CoolType;
  val v_formals_types : (T_Formals) => T_CoolTypeList;
  val v_case_env : (T_Case) => T_Environment;
  val v_cases_env : (T_Cases) => T_Environment;
  val v_case_cases : (T_Case) => T_CoolTypes;
  val v_cases_cases : (T_Cases) => T_CoolTypes;
  val v_cases_type : (T_Cases) => T_CoolType;
  val v_case_type : (T_Case) => T_CoolType;
  val v_not_inheritable : (T_Class) => T_Boolean;
  val v_check_int_arguments : (T_Environment,T_Integer,T_String,T_CoolType,T_CoolType) => T_Messages;
  val v_check_arguments : (T_Environment,T_String,T_Integer,T_CoolTypeList,T_CoolTypeList) => T_Messages;
  val v_type_lub : (T_CoolType,T_CoolType) => T_CoolType;
  val v_type_leq : (T_CoolType,T_CoolType) => T_Boolean;
  val v_type_equal : (T_CoolType,T_CoolType) => T_Boolean;
  val v_meth_lookup : (T_Symbol,T_Symbol) => T_Feature;
  val v_env_lookup : (T_Symbol,T_Environment) => T_CoolType;
  val v_methods_match : (T_Feature,T_Feature) => T_Boolean;
}

class M_COOL_SEMANT[T_T](name : String,val t_T : C_TYPE[T_T] with C_COOL[T_T])
  extends Module(name)
  with C_COOL_SEMANT[T_T,T_T]
{
  type T_Result = T_T;
  val v_equal = t_T.v_equal;
  val v_string = t_T.v_string;
  val v_assert = t_T.v_assert;
  val v_node_equivalent = t_T.v_node_equivalent;
  type T_Program = t_T.T_Program;
  val t_Program = t_T.t_Program;
  type T_Class = t_T.T_Class;
  val t_Class = t_T.t_Class;
  type T_Classes = t_T.T_Classes;
  val t_Classes = t_T.t_Classes;
  type T_Feature = t_T.T_Feature;
  val t_Feature = t_T.t_Feature;
  type T_Features = t_T.T_Features;
  val t_Features = t_T.t_Features;
  type T_Formal = t_T.T_Formal;
  val t_Formal = t_T.t_Formal;
  type T_Formals = t_T.T_Formals;
  val t_Formals = t_T.t_Formals;
  type T_Expression = t_T.T_Expression;
  val t_Expression = t_T.t_Expression;
  type T_Expressions = t_T.T_Expressions;
  val t_Expressions = t_T.t_Expressions;
  type T_Case = t_T.T_Case;
  val t_Case = t_T.t_Case;
  type T_Cases = t_T.T_Cases;
  val t_Cases = t_T.t_Cases;
  val p_program = t_T.p_program;
  val v_program = t_T.v_program;
  val p_class_decl = t_T.p_class_decl;
  val v_class_decl = t_T.v_class_decl;
  val p_method = t_T.p_method;
  val v_method = t_T.v_method;
  val p_attr = t_T.p_attr;
  val v_attr = t_T.v_attr;
  val p_formal = t_T.p_formal;
  val v_formal = t_T.v_formal;
  val p_branch = t_T.p_branch;
  val v_branch = t_T.v_branch;
  val p_assign = t_T.p_assign;
  val v_assign = t_T.v_assign;
  val p_static_dispatch = t_T.p_static_dispatch;
  val v_static_dispatch = t_T.v_static_dispatch;
  val p_dispatch = t_T.p_dispatch;
  val v_dispatch = t_T.v_dispatch;
  val p_cond = t_T.p_cond;
  val v_cond = t_T.v_cond;
  val p_loop = t_T.p_loop;
  val v_loop = t_T.v_loop;
  val p_typecase = t_T.p_typecase;
  val v_typecase = t_T.v_typecase;
  val p_block = t_T.p_block;
  val v_block = t_T.v_block;
  val p_let = t_T.p_let;
  val v_let = t_T.v_let;
  val p_add = t_T.p_add;
  val v_add = t_T.v_add;
  val p_sub = t_T.p_sub;
  val v_sub = t_T.v_sub;
  val p_mul = t_T.p_mul;
  val v_mul = t_T.v_mul;
  val p_div = t_T.p_div;
  val v_div = t_T.v_div;
  val p_neg = t_T.p_neg;
  val v_neg = t_T.v_neg;
  val p_lt = t_T.p_lt;
  val v_lt = t_T.v_lt;
  val p_leq = t_T.p_leq;
  val v_leq = t_T.v_leq;
  val p_comp = t_T.p_comp;
  val v_comp = t_T.v_comp;
  val p_int_lit = t_T.p_int_lit;
  val v_int_lit = t_T.v_int_lit;
  val p_bool_lit = t_T.p_bool_lit;
  val v_bool_lit = t_T.v_bool_lit;
  val p_string_lit = t_T.p_string_lit;
  val v_string_lit = t_T.v_string_lit;
  val p_alloc = t_T.p_alloc;
  val v_alloc = t_T.v_alloc;
  val p_nil = t_T.p_nil;
  val v_nil = t_T.v_nil;
  val p_unit = t_T.p_unit;
  val v_unit = t_T.v_unit;
  val p_no_expr = t_T.p_no_expr;
  val v_no_expr = t_T.v_no_expr;
  val p_variable = t_T.p_variable;
  val v_variable = t_T.v_variable;
  val v_inheritablep = t_T.v_inheritablep;

  val t_Result : this.type = this;
  val v_Any:T_Symbol = v_make_symbol("Any");
  val v_Int:T_Symbol = v_make_symbol("Int");
  val v_Bool:T_Symbol = v_make_symbol("Boolean");
  val v_Str:T_Symbol = v_make_symbol("String");
  val v_This:T_Symbol = v_make_symbol("this");
  val v_Native:T_Symbol = v_make_symbol("native");
  val v_Main:T_Symbol = v_make_symbol("Main");
  val v_Unit:T_Symbol = v_make_symbol("Unit");
  val v_Nothing:T_Symbol = v_make_symbol("Nothing");
  val v_Null:T_Symbol = v_make_symbol("Null");
  val v_null:T_Symbol = v_make_symbol("null");
  val v_empty:T_Symbol = v_make_symbol("");
  val v_errorType:T_Symbol = v_empty;
  type T_ClassReference = T_Class;
  val t_ClassReference = t_Class;
  val t_ClassReferences = new M_BAG[T_ClassReference]("ClassReferences",t_ClassReference)

  type T_ClassReferences = /*TI*/T_BAG[T_ClassReference];
  val t_ClassTable = new M_TABLE[T_Symbol,T_ClassReferences]("ClassTable",t_Symbol,t_ClassReferences)

  type T_ClassTable = /*TI*/T_TABLE[T_Symbol,T_ClassReferences];
  private class E_class_table(anchor : Null) extends Evaluation[Null,T_ClassTable](anchor,"class_table") with CollectionEvaluation[Null,T_ClassTable] {
    override def initial : T_ClassTable = t_ClassTable.v_initial;
    override def combine(v1 : T_ClassTable, v2 : T_ClassTable) = t_ClassTable.v_combine(v1,v2);
    override def compute : ValueType = c_class_table();
  }
  private object a_class_table extends E_class_table(null) {}
  def v_class_table:T_ClassTable = a_class_table.get;

  val v_find_class = f_find_class _;
  def f_find_class(v_name : T_Symbol):T_ClassReference = {
    try {
      Debug.begin("find_class("+v_name+")");

      t_ClassTable.v_select(v_class_table,v_name) match {
        case t_ClassTable.p_table_entry(_,v_0,t_ClassReferences.p__op_AC(_,v_cl,_*)) => {
          return v_cl;
        }
        case _ => {
          return t_Class.v_nil;
        }
      }
      throw Evaluation.UndefinedAttributeException("local find_class");
    } finally { Debug.end(); }
  }

  val v_class_parent = f_class_parent _;
  def f_class_parent(v_name : T_Symbol):T_Symbol = {
    try {
      Debug.begin("class_parent("+v_name+")");

      var v_cl : T_ClassReference = v_find_class(v_name);
      { val cond = new M__basic_2[ T_ClassReference](t_ClassReference).v__op_0(v_cl,t_Class.v_nil);
        if (cond) {
          return v_empty;
        }
        if (!cond) {
          v_cl match {
            case p_class_decl(_,v_0,v_parent,v_2,v_3) => {
              return v_parent;
            }
          }
        }
      }
      throw Evaluation.UndefinedAttributeException("local class_parent");
    } finally { Debug.end(); }
  }

  val t_Messages = new M_BAG[T_String]("Messages",t_String)

  type T_Messages = /*TI*/T_BAG[T_String];
  private class E_messages(anchor : Null) extends Evaluation[Null,T_Messages](anchor,"messages") with CollectionEvaluation[Null,T_Messages] {
    override def initial : T_Messages = t_Messages.v_initial;
    override def combine(v1 : T_Messages, v2 : T_Messages) = t_Messages.v_combine(v1,v2);
    override def compute : ValueType = c_messages();
  }
  private object a_messages extends E_messages(null) {}
  def v_messages:T_Messages = a_messages.get;

  private class E_class_is_circular(anchor : T_Class) extends Evaluation[T_Class,T_AndLattice](anchor,anchor.toString()+"."+"class_is_circular") with CircularEvaluation[T_Class,T_AndLattice] {
    def lattice() : C_LATTICE[T_AndLattice] = t_AndLattice;

    override def compute : ValueType = c_class_is_circular(anchor);
  }
  private object a_class_is_circular extends Attribute[T_Class,T_AndLattice](t_Class,t_AndLattice,"class_is_circular") {
    override def createEvaluation(anchor : T_Class) : Evaluation[T_Class,T_AndLattice] = new E_class_is_circular(anchor);
  }
  val v_class_is_circular : T_Class => T_AndLattice = a_class_is_circular.get _;

  private class E_features_class(anchor : T_Features) extends Evaluation[T_Features,T_ClassReference](anchor,anchor.toString()+"."+"features_class") {
    override def getDefault = t_Class.v_nil;
    override def compute : ValueType = c_features_class(anchor);
  }
  private object a_features_class extends Attribute[T_Features,T_ClassReference](t_Features,t_ClassReference,"features_class") {
    override def createEvaluation(anchor : T_Features) : Evaluation[T_Features,T_ClassReference] = new E_features_class(anchor);
  }
  val v_features_class : T_Features => T_ClassReference = a_features_class.get _;

  private class E_feature_class(anchor : T_Feature) extends Evaluation[T_Feature,T_ClassReference](anchor,anchor.toString()+"."+"feature_class") {
    override def compute : ValueType = c_feature_class(anchor);
  }
  private object a_feature_class extends Attribute[T_Feature,T_ClassReference](t_Feature,t_ClassReference,"feature_class") {
    override def createEvaluation(anchor : T_Feature) : Evaluation[T_Feature,T_ClassReference] = new E_feature_class(anchor);
  }
  val v_feature_class : T_Feature => T_ClassReference = a_feature_class.get _;

  type T_FeatureRemote = T_Feature;
  val t_FeatureRemote = t_Feature;
  val t_FeatureReferences = new M_BAG[T_FeatureRemote]("FeatureReferences",t_FeatureRemote)

  type T_FeatureReferences = /*TI*/T_BAG[T_FeatureRemote];
  val t_AttrTable = new M_TABLE[T_Symbol,T_FeatureReferences]("AttrTable",t_Symbol,t_FeatureReferences)

  type T_AttrTable = /*TI*/T_TABLE[T_Symbol,T_FeatureReferences];
  private class E_class_attr_table(anchor : T_Class) extends Evaluation[T_Class,T_AttrTable](anchor,anchor.toString()+"."+"class_attr_table") with CollectionEvaluation[T_Class,T_AttrTable] {
    override def initial : T_AttrTable = t_AttrTable.v_initial;
    override def combine(v1 : T_AttrTable, v2 : T_AttrTable) = t_AttrTable.v_combine(v1,v2);
    override def compute : ValueType = c_class_attr_table(anchor);
  }
  private object a_class_attr_table extends Attribute[T_Class,T_AttrTable](t_Class,t_AttrTable,"class_attr_table") {
    override def createEvaluation(anchor : T_Class) : Evaluation[T_Class,T_AttrTable] = new E_class_attr_table(anchor);
  }
  val v_class_attr_table : T_Class => T_AttrTable = a_class_attr_table.get _;

  val t_MethodTable = new M_TABLE[T_Symbol,T_FeatureReferences]("MethodTable",t_Symbol,t_FeatureReferences)

  type T_MethodTable = /*TI*/T_TABLE[T_Symbol,T_FeatureReferences];
  private class E_class_meth_table(anchor : T_Class) extends Evaluation[T_Class,T_MethodTable](anchor,anchor.toString()+"."+"class_meth_table") with CollectionEvaluation[T_Class,T_MethodTable] {
    override def initial : T_MethodTable = t_MethodTable.v_initial;
    override def combine(v1 : T_MethodTable, v2 : T_MethodTable) = t_MethodTable.v_combine(v1,v2);
    override def compute : ValueType = c_class_meth_table(anchor);
  }
  private object a_class_meth_table extends Attribute[T_Class,T_MethodTable](t_Class,t_MethodTable,"class_meth_table") {
    override def createEvaluation(anchor : T_Class) : Evaluation[T_Class,T_MethodTable] = new E_class_meth_table(anchor);
  }
  val v_class_meth_table : T_Class => T_MethodTable = a_class_meth_table.get _;

  val t_CoolType = t_Symbol;
  val t_CoolTypes = new M_MULTISET[T_CoolType]("CoolTypes",t_CoolType)

  type T_CoolTypes = /*TI*/T_MULTISET[T_CoolType];
  val t_Contour = new M_TABLE[T_Symbol,T_CoolTypes]("Contour",t_Symbol,t_CoolTypes)

  type T_Contour = /*TI*/T_TABLE[T_Symbol,T_CoolTypes];
  abstract class T_ScopeObject(t : I_PHYLUM[T_ScopeObject]) extends Node(t) {}
  val t_ScopeObject = new I_PHYLUM[T_ScopeObject]("ScopeObject");

  type T_ScopeObjectRemote = T_ScopeObject;
  val t_ScopeObjectRemote = t_ScopeObject;
  case class c_scope(v_filename : T_String,v_enclosing : T_ScopeObjectRemote) extends T_ScopeObject(t_ScopeObject) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "scope("+ v_filename + ","+ v_enclosing+ ")";
    }
  }
  def u_scope(x:Any) : Option[(T_ScopeObject,T_String,T_ScopeObjectRemote)] = x match {
    case x@c_scope(v_filename,v_enclosing) => Some((x,v_filename,v_enclosing));
    case _ => None };
  val v_scope = f_scope _;
  def f_scope(v_filename : T_String, v_enclosing : T_ScopeObjectRemote):T_ScopeObject = c_scope(v_filename,v_enclosing).register;
  val p_scope = new PatternFunction[(T_ScopeObject,T_String,T_ScopeObjectRemote)](u_scope);

  type T_Scope = T_ScopeObject;
  val t_Scope = t_ScopeObject;
  private class E_table(anchor : T_ScopeObject) extends Evaluation[T_ScopeObject,T_Contour](anchor,anchor.toString()+"."+"table") with CollectionEvaluation[T_ScopeObject,T_Contour] {
    override def initial : T_Contour = t_Contour.v_initial;
    override def combine(v1 : T_Contour, v2 : T_Contour) = t_Contour.v_combine(v1,v2);
    override def compute : ValueType = c_table(anchor);
  }
  private object a_table extends Attribute[T_ScopeObject,T_Contour](t_ScopeObject,t_Contour,"table") {
    override def createEvaluation(anchor : T_ScopeObject) : Evaluation[T_ScopeObject,T_Contour] = new E_table(anchor);
  }
  val v_table : T_ScopeObject => T_Contour = a_table.get _;

  val t_Environment = t_Scope;
  val v_env_filename = f_env_filename _;
  def f_env_filename(v_e : T_Environment):T_String = {
    try {
      Debug.begin("env_filename("+v_e+")");

      v_e match {
        case p_scope(_,v_fn,v_1) => {
          return v_fn;
        }
        case _ => {
          return "<none>";
        }
      }
      throw Evaluation.UndefinedAttributeException("local env_filename");
    } finally { Debug.end(); }
  }

  val v_make_scope = f_make_scope _;
  def f_make_scope(v_encl : T_Environment):T_Scope = {
    try {
      Debug.begin("make_scope("+v_encl+")");

      return v_scope(v_env_filename(v_encl),v_encl);
      throw Evaluation.UndefinedAttributeException("local make_scope");
    } finally { Debug.end(); }
  }

  val v_message = f_message _;
  def f_message(v_env : T_Environment, v_n : T_Integer, v_s : T_String):T_Messages = {
    try {
      Debug.begin("message("+v_env+","+v_n+","+v_s+")");
      return t_Messages.v_single(new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(v_env_filename(v_env),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(":",new M__basic_21[ T_Integer,T_String](t_Integer,t_String).v__op_BB(v_n,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(": ",v_s)))));
    } finally { Debug.end(); }
  };
  private class E_class_env(anchor : T_Class) extends Evaluation[T_Class,T_Environment](anchor,anchor.toString()+"."+"class_env") {
    override def compute : ValueType = c_class_env(anchor);
  }
  private object a_class_env extends Attribute[T_Class,T_Environment](t_Class,t_Environment,"class_env") {
    override def createEvaluation(anchor : T_Class) : Evaluation[T_Class,T_Environment] = new E_class_env(anchor);
  }
  val v_class_env : T_Class => T_Environment = a_class_env.get _;

  private class E_formals_env(anchor : T_Formals) extends Evaluation[T_Formals,T_Environment](anchor,anchor.toString()+"."+"formals_env") {
    override def compute : ValueType = c_formals_env(anchor);
  }
  private object a_formals_env extends Attribute[T_Formals,T_Environment](t_Formals,t_Environment,"formals_env") {
    override def createEvaluation(anchor : T_Formals) : Evaluation[T_Formals,T_Environment] = new E_formals_env(anchor);
  }
  val v_formals_env : T_Formals => T_Environment = a_formals_env.get _;

  private class E_formal_env(anchor : T_Formal) extends Evaluation[T_Formal,T_Environment](anchor,anchor.toString()+"."+"formal_env") {
    override def compute : ValueType = c_formal_env(anchor);
  }
  private object a_formal_env extends Attribute[T_Formal,T_Environment](t_Formal,t_Environment,"formal_env") {
    override def createEvaluation(anchor : T_Formal) : Evaluation[T_Formal,T_Environment] = new E_formal_env(anchor);
  }
  val v_formal_env : T_Formal => T_Environment = a_formal_env.get _;

  private class E_exprs_env(anchor : T_Expressions) extends Evaluation[T_Expressions,T_Environment](anchor,anchor.toString()+"."+"exprs_env") {
    override def getDefault = t_Scope.v_nil;
    override def compute : ValueType = c_exprs_env(anchor);
  }
  private object a_exprs_env extends Attribute[T_Expressions,T_Environment](t_Expressions,t_Environment,"exprs_env") {
    override def createEvaluation(anchor : T_Expressions) : Evaluation[T_Expressions,T_Environment] = new E_exprs_env(anchor);
  }
  val v_exprs_env : T_Expressions => T_Environment = a_exprs_env.get _;

  private class E_expr_env(anchor : T_Expression) extends Evaluation[T_Expression,T_Environment](anchor,anchor.toString()+"."+"expr_env") {
    override def compute : ValueType = c_expr_env(anchor);
  }
  private object a_expr_env extends Attribute[T_Expression,T_Environment](t_Expression,t_Environment,"expr_env") {
    override def createEvaluation(anchor : T_Expression) : Evaluation[T_Expression,T_Environment] = new E_expr_env(anchor);
  }
  val v_expr_env : T_Expression => T_Environment = a_expr_env.get _;

  val t_CoolTypeList = new M_LIST[T_CoolType]("CoolTypeList",t_CoolType)

  type T_CoolTypeList = /*TI*/T_LIST[T_CoolType];
  private class E_expr_type(anchor : T_Expression) extends Evaluation[T_Expression,T_CoolType](anchor,anchor.toString()+"."+"expr_type") {
    override def compute : ValueType = c_expr_type(anchor);
  }
  private object a_expr_type extends Attribute[T_Expression,T_CoolType](t_Expression,t_CoolType,"expr_type") {
    override def createEvaluation(anchor : T_Expression) : Evaluation[T_Expression,T_CoolType] = new E_expr_type(anchor);
  }
  val v_expr_type : T_Expression => T_CoolType = a_expr_type.get _;

  private class E_exprs_type(anchor : T_Expressions) extends Evaluation[T_Expressions,T_CoolTypeList](anchor,anchor.toString()+"."+"exprs_type") {
    override def compute : ValueType = c_exprs_type(anchor);
  }
  private object a_exprs_type extends Attribute[T_Expressions,T_CoolTypeList](t_Expressions,t_CoolTypeList,"exprs_type") {
    override def createEvaluation(anchor : T_Expressions) : Evaluation[T_Expressions,T_CoolTypeList] = new E_exprs_type(anchor);
  }
  val v_exprs_type : T_Expressions => T_CoolTypeList = a_exprs_type.get _;

  private class E_formal_type(anchor : T_Formal) extends Evaluation[T_Formal,T_CoolType](anchor,anchor.toString()+"."+"formal_type") {
    override def compute : ValueType = c_formal_type(anchor);
  }
  private object a_formal_type extends Attribute[T_Formal,T_CoolType](t_Formal,t_CoolType,"formal_type") {
    override def createEvaluation(anchor : T_Formal) : Evaluation[T_Formal,T_CoolType] = new E_formal_type(anchor);
  }
  val v_formal_type : T_Formal => T_CoolType = a_formal_type.get _;

  private class E_formals_types(anchor : T_Formals) extends Evaluation[T_Formals,T_CoolTypeList](anchor,anchor.toString()+"."+"formals_types") {
    override def compute : ValueType = c_formals_types(anchor);
  }
  private object a_formals_types extends Attribute[T_Formals,T_CoolTypeList](t_Formals,t_CoolTypeList,"formals_types") {
    override def createEvaluation(anchor : T_Formals) : Evaluation[T_Formals,T_CoolTypeList] = new E_formals_types(anchor);
  }
  val v_formals_types : T_Formals => T_CoolTypeList = a_formals_types.get _;

  private class E_case_env(anchor : T_Case) extends Evaluation[T_Case,T_Environment](anchor,anchor.toString()+"."+"case_env") {
    override def compute : ValueType = c_case_env(anchor);
  }
  private object a_case_env extends Attribute[T_Case,T_Environment](t_Case,t_Environment,"case_env") {
    override def createEvaluation(anchor : T_Case) : Evaluation[T_Case,T_Environment] = new E_case_env(anchor);
  }
  val v_case_env : T_Case => T_Environment = a_case_env.get _;

  private class E_cases_env(anchor : T_Cases) extends Evaluation[T_Cases,T_Environment](anchor,anchor.toString()+"."+"cases_env") {
    override def compute : ValueType = c_cases_env(anchor);
  }
  private object a_cases_env extends Attribute[T_Cases,T_Environment](t_Cases,t_Environment,"cases_env") {
    override def createEvaluation(anchor : T_Cases) : Evaluation[T_Cases,T_Environment] = new E_cases_env(anchor);
  }
  val v_cases_env : T_Cases => T_Environment = a_cases_env.get _;

  private class E_case_cases(anchor : T_Case) extends Evaluation[T_Case,T_CoolTypes](anchor,anchor.toString()+"."+"case_cases") {
    override def compute : ValueType = c_case_cases(anchor);
  }
  private object a_case_cases extends Attribute[T_Case,T_CoolTypes](t_Case,t_CoolTypes,"case_cases") {
    override def createEvaluation(anchor : T_Case) : Evaluation[T_Case,T_CoolTypes] = new E_case_cases(anchor);
  }
  val v_case_cases : T_Case => T_CoolTypes = a_case_cases.get _;

  private class E_cases_cases(anchor : T_Cases) extends Evaluation[T_Cases,T_CoolTypes](anchor,anchor.toString()+"."+"cases_cases") {
    override def compute : ValueType = c_cases_cases(anchor);
  }
  private object a_cases_cases extends Attribute[T_Cases,T_CoolTypes](t_Cases,t_CoolTypes,"cases_cases") {
    override def createEvaluation(anchor : T_Cases) : Evaluation[T_Cases,T_CoolTypes] = new E_cases_cases(anchor);
  }
  val v_cases_cases : T_Cases => T_CoolTypes = a_cases_cases.get _;

  private class E_cases_type(anchor : T_Cases) extends Evaluation[T_Cases,T_CoolType](anchor,anchor.toString()+"."+"cases_type") {
    override def compute : ValueType = c_cases_type(anchor);
  }
  private object a_cases_type extends Attribute[T_Cases,T_CoolType](t_Cases,t_CoolType,"cases_type") {
    override def createEvaluation(anchor : T_Cases) : Evaluation[T_Cases,T_CoolType] = new E_cases_type(anchor);
  }
  val v_cases_type : T_Cases => T_CoolType = a_cases_type.get _;

  private class E_case_type(anchor : T_Case) extends Evaluation[T_Case,T_CoolType](anchor,anchor.toString()+"."+"case_type") {
    override def compute : ValueType = c_case_type(anchor);
  }
  private object a_case_type extends Attribute[T_Case,T_CoolType](t_Case,t_CoolType,"case_type") {
    override def createEvaluation(anchor : T_Case) : Evaluation[T_Case,T_CoolType] = new E_case_type(anchor);
  }
  val v_case_type : T_Case => T_CoolType = a_case_type.get _;

  private class E1_main_class(anchor : t_Result.T_Program) extends Evaluation[t_Result.T_Program,T_ClassReference](anchor,anchor.toString()+"."+"main_class") {
    override def compute : ValueType = c1_main_class(anchor);
  }
  private object a1_main_class extends Attribute[t_Result.T_Program,T_ClassReference](t_Result.t_Program,t_ClassReference,"main_class") {
    override def createEvaluation(anchor : t_Result.T_Program) : Evaluation[t_Result.T_Program,T_ClassReference] = new E1_main_class(anchor);
  }
  private class E2_main_constructor(anchor : t_Result.T_Program) extends Evaluation[t_Result.T_Program,T_Feature](anchor,anchor.toString()+"."+"main_constructor") {
    override def compute : ValueType = c2_main_constructor(anchor);
  }
  private object a2_main_constructor extends Attribute[t_Result.T_Program,T_Feature](t_Result.t_Program,t_Feature,"main_constructor") {
    override def createEvaluation(anchor : t_Result.T_Program) : Evaluation[t_Result.T_Program,T_Feature] = new E2_main_constructor(anchor);
  }
  val v_not_inheritable = f_not_inheritable _;
  def f_not_inheritable(v_pcl : T_Class):T_Boolean = {
    try {
      Debug.begin("not_inheritable("+v_pcl+")");

      { val cond = new M__basic_2[ T_Class](t_Class).v__op_w0(v_pcl,t_Class.v_nil);
        if (cond) {
          { val cond = v_not(v_inheritablep(v_pcl));
            if (cond) {
              return v_true;
            }
          }
        }
      }
      return v_false;
    } finally { Debug.end(); }
  }

  private class E3_pcl(anchor : t_Result.T_Class) extends Evaluation[t_Result.T_Class,T_ClassReference](anchor,anchor.toString()+"."+"pcl") {
    override def compute : ValueType = c3_pcl(anchor);
  }
  private object a3_pcl extends Attribute[t_Result.T_Class,T_ClassReference](t_Result.t_Class,t_ClassReference,"pcl") {
    override def createEvaluation(anchor : t_Result.T_Class) : Evaluation[t_Result.T_Class,T_ClassReference] = new E3_pcl(anchor);
  }
  private class E4_cl(anchor : t_Result.T_Feature) extends Evaluation[t_Result.T_Feature,T_ClassReference](anchor,anchor.toString()+"."+"cl") {
    override def compute : ValueType = c4_cl(anchor);
  }
  private object a4_cl extends Attribute[t_Result.T_Feature,T_ClassReference](t_Result.t_Feature,t_ClassReference,"cl") {
    override def createEvaluation(anchor : t_Result.T_Feature) : Evaluation[t_Result.T_Feature,T_ClassReference] = new E4_cl(anchor);
  }
  private class E5_pcl(anchor : t_Result.T_Feature) extends Evaluation[t_Result.T_Feature,T_ClassReference](anchor,anchor.toString()+"."+"pcl") {
    override def compute : ValueType = c5_pcl(anchor);
  }
  private object a5_pcl extends Attribute[t_Result.T_Feature,T_ClassReference](t_Result.t_Feature,t_ClassReference,"pcl") {
    override def createEvaluation(anchor : t_Result.T_Feature) : Evaluation[t_Result.T_Feature,T_ClassReference] = new E5_pcl(anchor);
  }
  private class E6_cl(anchor : t_Result.T_Feature) extends Evaluation[t_Result.T_Feature,T_ClassReference](anchor,anchor.toString()+"."+"cl") {
    override def compute : ValueType = c6_cl(anchor);
  }
  private object a6_cl extends Attribute[t_Result.T_Feature,T_ClassReference](t_Result.t_Feature,t_ClassReference,"cl") {
    override def createEvaluation(anchor : t_Result.T_Feature) : Evaluation[t_Result.T_Feature,T_ClassReference] = new E6_cl(anchor);
  }
  private class E7_superm(anchor : t_Result.T_Feature) extends Evaluation[t_Result.T_Feature,T_Feature](anchor,anchor.toString()+"."+"superm") {
    override def compute : ValueType = c7_superm(anchor);
  }
  private object a7_superm extends Attribute[t_Result.T_Feature,T_Feature](t_Result.t_Feature,t_Feature,"superm") {
    override def createEvaluation(anchor : t_Result.T_Feature) : Evaluation[t_Result.T_Feature,T_Feature] = new E7_superm(anchor);
  }
  private class E8_c(anchor : t_Result.T_Feature) extends Evaluation[t_Result.T_Feature,T_Scope](anchor,anchor.toString()+"."+"c") {
    override def compute : ValueType = c8_c(anchor);
  }
  private object a8_c extends Attribute[t_Result.T_Feature,T_Scope](t_Result.t_Feature,t_Scope,"c") {
    override def createEvaluation(anchor : t_Result.T_Feature) : Evaluation[t_Result.T_Feature,T_Scope] = new E8_c(anchor);
  }
  private class E9_sh(anchor : t_Result.T_Expression) extends Evaluation[t_Result.T_Expression,T_CoolType](anchor,anchor.toString()+"."+"sh") {
    override def compute : ValueType = c9_sh(anchor);
  }
  private object a9_sh extends Attribute[t_Result.T_Expression,T_CoolType](t_Result.t_Expression,t_CoolType,"sh") {
    override def createEvaluation(anchor : t_Result.T_Expression) : Evaluation[t_Result.T_Expression,T_CoolType] = new E9_sh(anchor);
  }
  private class E10_c(anchor : t_Result.T_Expression) extends Evaluation[t_Result.T_Expression,T_Scope](anchor,anchor.toString()+"."+"c") {
    override def compute : ValueType = c10_c(anchor);
  }
  private object a10_c extends Attribute[t_Result.T_Expression,T_Scope](t_Result.t_Expression,t_Scope,"c") {
    override def createEvaluation(anchor : t_Result.T_Expression) : Evaluation[t_Result.T_Expression,T_Scope] = new E10_c(anchor);
  }
  val v_check_int_arguments = f_check_int_arguments _;
  def f_check_int_arguments(v_env : T_Environment, v_lno : T_Integer, v_op : T_String, v_t1 : T_CoolType, v_t2 : T_CoolType):T_Messages = {
    try {
      Debug.begin("check_int_arguments("+v_env+","+v_lno+","+v_op+","+v_t1+","+v_t2+")");

      { val cond = v_or(v_not(v_type_equal(v_t1,v_Int)),v_not(v_type_equal(v_t2,v_Int)));
        if (cond) {
          return v_message(v_env,v_lno,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("non-Integer arguments: ",new M__basic_21[ T_CoolType,T_String](t_CoolType,t_String).v__op_BB(v_t1,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" ",new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(v_op,new M__basic_21[ T_String,T_CoolType](t_String,t_CoolType).v__op_BB(" ",v_t2))))));
        }
        if (!cond) {
          return t_Messages.v_none();
        }
      }
      throw Evaluation.UndefinedAttributeException("local check_int_arguments");
    } finally { Debug.end(); }
  }

  private class E11_sh(anchor : t_Result.T_Expression) extends Evaluation[t_Result.T_Expression,T_CoolType](anchor,anchor.toString()+"."+"sh") {
    override def compute : ValueType = c11_sh(anchor);
  }
  private object a11_sh extends Attribute[t_Result.T_Expression,T_CoolType](t_Result.t_Expression,t_CoolType,"sh") {
    override def createEvaluation(anchor : t_Result.T_Expression) : Evaluation[t_Result.T_Expression,T_CoolType] = new E11_sh(anchor);
  }
  private class E12_c(anchor : t_Result.T_Case) extends Evaluation[t_Result.T_Case,T_Scope](anchor,anchor.toString()+"."+"c") {
    override def compute : ValueType = c12_c(anchor);
  }
  private object a12_c extends Attribute[t_Result.T_Case,T_Scope](t_Result.t_Case,t_Scope,"c") {
    override def createEvaluation(anchor : t_Result.T_Case) : Evaluation[t_Result.T_Case,T_Scope] = new E12_c(anchor);
  }
  private class E13_overlaps(anchor : t_Result.T_Cases) extends Evaluation[t_Result.T_Cases,T_CoolTypes](anchor,anchor.toString()+"."+"overlaps") {
    override def compute : ValueType = c13_overlaps(anchor);
  }
  private object a13_overlaps extends Attribute[t_Result.T_Cases,T_CoolTypes](t_Result.t_Cases,t_CoolTypes,"overlaps") {
    override def createEvaluation(anchor : t_Result.T_Cases) : Evaluation[t_Result.T_Cases,T_CoolTypes] = new E13_overlaps(anchor);
  }
  private class E14_method_binding(anchor : t_Result.T_Expression) extends Evaluation[t_Result.T_Expression,T_Feature](anchor,anchor.toString()+"."+"method_binding") {
    override def compute : ValueType = c14_method_binding(anchor);
  }
  private object a14_method_binding extends Attribute[t_Result.T_Expression,T_Feature](t_Result.t_Expression,t_Feature,"method_binding") {
    override def createEvaluation(anchor : t_Result.T_Expression) : Evaluation[t_Result.T_Expression,T_Feature] = new E14_method_binding(anchor);
  }
  val v_check_arguments = f_check_arguments _;
  def f_check_arguments(v_env : T_Environment, v_meth_name : T_String, v_lno : T_Integer, v_arg_types : T_CoolTypeList, v_formal_types : T_CoolTypeList):T_Messages = {
    try {
      Debug.begin("check_arguments("+v_env+","+v_meth_name+","+v_lno+","+v_arg_types+","+v_formal_types+")");

      { val cond = new M__basic_2[ T_CoolTypeList](t_CoolTypeList).v__op_0(v_arg_types,v_formal_types);
        if (cond) {
          return t_Messages.v_none();
        }
        if (!cond) {
          { val cond = new M__basic_2[ T_CoolTypeList](t_CoolTypeList).v__op_0(v_arg_types,t_CoolTypeList.v_none());
            if (cond) {
              return v_message(v_env,v_lno,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Method ",new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(v_meth_name," called with too few actual parameters.")));
            }
            if (!cond) {
              { val cond = new M__basic_2[ T_CoolTypeList](t_CoolTypeList).v__op_0(v_formal_types,t_CoolTypeList.v_none());
                if (cond) {
                  return v_message(v_env,v_lno,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Method ",new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(v_meth_name," called with too many actual parameters.")));
                }
                if (!cond) {
                  { val cond = v_not(v_type_leq(new M__basic_16[ T_CoolType,T_CoolTypeList](t_CoolType,t_CoolTypeList).v_first(v_arg_types),new M__basic_16[ T_CoolType,T_CoolTypeList](t_CoolType,t_CoolTypeList).v_first(v_formal_types)));
                    if (cond) {
                      return v_message(v_env,v_lno,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("In call of method ",new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(v_meth_name,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(", type ",new M__basic_21[ T_CoolType,T_String](t_CoolType,t_String).v__op_BB(new M__basic_16[ T_CoolType,T_CoolTypeList](t_CoolType,t_CoolTypeList).v_first(v_arg_types),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" of parameter does not conform to declared",new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" type ",new M__basic_21[ T_CoolType,T_String](t_CoolType,t_String).v__op_BB(new M__basic_16[ T_CoolType,T_CoolTypeList](t_CoolType,t_CoolTypeList).v_first(v_formal_types),"."))))))));
                    }
                    if (!cond) {
                      return v_check_arguments(v_env,v_meth_name,v_lno,new M__basic_17[ T_CoolType,T_CoolTypeList](t_CoolType,t_CoolTypeList).v_butfirst(v_arg_types),new M__basic_17[ T_CoolType,T_CoolTypeList](t_CoolType,t_CoolTypeList).v_butfirst(v_formal_types));
                    }
                  }
                }
              }
            }
          }
        }
      }
      throw Evaluation.UndefinedAttributeException("local check_arguments");
    } finally { Debug.end(); }
  }

  private class E15_method_binding(anchor : t_Result.T_Expression) extends Evaluation[t_Result.T_Expression,T_Feature](anchor,anchor.toString()+"."+"method_binding") {
    override def compute : ValueType = c15_method_binding(anchor);
  }
  private object a15_method_binding extends Attribute[t_Result.T_Expression,T_Feature](t_Result.t_Expression,t_Feature,"method_binding") {
    override def createEvaluation(anchor : t_Result.T_Expression) : Evaluation[t_Result.T_Expression,T_Feature] = new E15_method_binding(anchor);
  }
  val v_type_lub = f_type_lub _;
  def f_type_lub(v_s1 : T_CoolType, v_s2 : T_CoolType):T_CoolType = {
    try {
      Debug.begin("type_lub("+v_s1+","+v_s2+")");

      { val cond = v_type_equal(v_s1,v_errorType);
        if (cond) {
          return v_s2;
        }
        if (!cond) {
          { val cond = v_type_equal(v_s2,v_errorType);
            if (cond) {
              return v_s1;
            }
            if (!cond) {
              { val cond = v_type_leq(v_s1,v_s2);
                if (cond) {
                  return v_s2;
                }
                if (!cond) {
                  { val cond = v_type_leq(v_s2,v_s1);
                    if (cond) {
                      return v_s1;
                    }
                    if (!cond) {
                      { val cond = v_or(new M__basic_2[ T_CoolType](t_CoolType).v__op_0(v_s1,v_Null),new M__basic_2[ T_CoolType](t_CoolType).v__op_0(v_s2,v_Null));
                        if (cond) {
                          return v_Any;
                        }
                        if (!cond) {
                          return v_type_lub(v_class_parent(v_s1),v_class_parent(v_s2));
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      throw Evaluation.UndefinedAttributeException("local type_lub");
    } finally { Debug.end(); }
  }

  val v_type_leq = f_type_leq _;
  def f_type_leq(v_s1 : T_CoolType, v_s2 : T_CoolType):T_Boolean = {
    try {
      Debug.begin("type_leq("+v_s1+","+v_s2+")");

      { val cond = v_or(v_type_equal(v_s1,v_errorType),v_type_equal(v_s2,v_errorType));
        if (cond) {
          return v_true;
        }
        if (!cond) {
          { val cond = v_type_equal(v_s1,v_Nothing);
            if (cond) {
              return v_true;
            }
            if (!cond) {
              { val cond = v_or(v_type_equal(v_s2,v_Any),v_type_equal(v_s1,v_s2));
                if (cond) {
                  return v_true;
                }
                if (!cond) {
                  { val cond = v_type_equal(v_s2,v_Nothing);
                    if (cond) {
                      return v_false;
                    }
                    if (!cond) {
                      { val cond = new M__basic_2[ T_CoolType](t_CoolType).v__op_0(v_s1,v_Null);
                        if (cond) {
                          return v_not(new M__basic_14[ T_CoolType,T_CoolTypes](t_CoolType,t_CoolTypes).v_in(v_s2,t_CoolTypes.v_append(t_CoolTypes.v_append(t_CoolTypes.v_single(v_Int),t_CoolTypes.v_single(v_Bool)),t_CoolTypes.v_single(v_Unit))));
                        }
                        if (!cond) {
                          { val cond = v_or(new M__basic_2[ T_CoolType](t_CoolType).v__op_0(v_s1,v_Any),new M__basic_2[ T_CoolType](t_CoolType).v__op_0(v_s2,v_Null));
                            if (cond) {
                              return v_false;
                            }
                            if (!cond) {
                              return v_type_leq(v_class_parent(v_s1),v_s2);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      throw Evaluation.UndefinedAttributeException("local type_leq");
    } finally { Debug.end(); }
  }

  val v_type_equal = f_type_equal _;
  def f_type_equal(v_s1 : T_CoolType, v_s2 : T_CoolType):T_Boolean = {
    try {
      Debug.begin("type_equal("+v_s1+","+v_s2+")");
      return v_or(new M__basic_2[ T_CoolType](t_CoolType).v__op_0(v_s1,v_s2),new M__basic_2[ T_CoolType](t_CoolType).v__op_0(v_s1,v_errorType));
    } finally { Debug.end(); }
  };
  val v_meth_lookup = f_meth_lookup _;
  def f_meth_lookup(v_meth_name : T_Symbol, v_class_name : T_Symbol):T_Feature = {
    try {
      Debug.begin("meth_lookup("+v_meth_name+","+v_class_name+")");

      var v_cl : T_ClassReference = v_find_class(v_class_name);
      { val cond = new M__basic_2[ T_ClassReference](t_ClassReference).v__op_0(v_cl,t_Class.v_nil);
        if (cond) {
          return t_Feature.v_nil;
        }
        if (!cond) {
          t_MethodTable.v_select(v_class_meth_table(v_cl),v_meth_name) match {
            case t_MethodTable.p_table_entry(_,v_0,t_FeatureReferences.p__op_AC(_,v_me,_*)) => {
              return v_me;
            }
            case _ => {
              { val cond = v_or(v_class_is_circular(v_cl),new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_class_name,v_Any));
                if (cond) {
                  return t_Feature.v_nil;
                }
                if (!cond) {
                  return v_meth_lookup(v_meth_name,v_class_parent(v_class_name));
                }
              }
            }
          }
        }
      }
      throw Evaluation.UndefinedAttributeException("local meth_lookup");
    } finally { Debug.end(); }
  }

  val v_env_lookup = f_env_lookup _;
  def f_env_lookup(v_n : T_Symbol, v_env : T_Environment):T_CoolType = {
    try {
      Debug.begin("env_lookup("+v_n+","+v_env+")");

      { val cond = new M__basic_2[ T_Environment](t_Environment).v__op_0(v_env,t_Environment.v_nil);
        if (cond) {
          return v_errorType;
        }
        if (!cond) {
          t_Contour.v_select(v_table(v_env),v_n) match {
            case t_Contour.p_table_entry(_,v_0,t_CoolTypes.p__op_AC(_,v_s,_*)) => {
              return v_s;
            }
            case _ => {
              v_env match {
                case p_scope(_,v_0,v_enclosing) => {
                  return v_env_lookup(v_n,v_enclosing);
                }
                case _ => {
                  return v_errorType;
                }
              }
            }
          }
        }
      }
      throw Evaluation.UndefinedAttributeException("local env_lookup");
    } finally { Debug.end(); }
  }

  val v_methods_match = f_methods_match _;
  def f_methods_match(v_old : T_Feature, v_new : T_Feature):T_Boolean = {
    try {
      Debug.begin("methods_match("+v_old+","+v_new+")");

      v_old match {
        case p_method(_,v_0,v_1,v_oldfs,v_oldrt,v_4) => {
          v_new match {
            case p_method(_,v_0,v_1,v_newfs,v_newrt,v_4) => {
              return v_and(v_type_leq(v_newrt,v_oldrt),new M__basic_2[ T_CoolTypeList](t_CoolTypeList).v__op_0(v_formals_types(v_oldfs),v_formals_types(v_newfs)));
            }
          }
        }
      }
      throw Evaluation.UndefinedAttributeException("local methods_match");
    } finally { Debug.end(); }
  }

  def c1_main_class(anchor : Any) : T_ClassReference = {
    anchor match {
      case p_program(v_p,v_0) => {
        return v_find_class(v_Main);
      }
    }
  }
  def c2_main_constructor(anchor : Any) : T_Feature = {
    anchor match {
      case p_program(v_p,v_0) => {
        return v_meth_lookup(v_Main,v_Main);
      }
    }
  }
  def c3_pcl(anchor : Any) : T_ClassReference = {
    anchor match {
      case p_class_decl(v_cl,v_name,v_parent,v_features,v_filename) => {
        { val cond = new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_name,v_Any);
          if (!cond) {
            { val cond = v_or(new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_name,v_Nothing),new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_name,v_Null));
              if (!cond) {
                return v_find_class(v_parent);
              }
            }
          }
        }
        return t_Class.v_nil;
      }
    }
  }
  def c4_cl(anchor : Any) : T_ClassReference = {
    anchor match {
      case p_attr(v_f,v_name,v_of_type) => {
        return v_feature_class(v_f);
        throw Evaluation.UndefinedAttributeException("local cl");
      }
    }
  }
  def c5_pcl(anchor : Any) : T_ClassReference = {
    anchor match {
      case p_attr(v_f,v_name,v_of_type) => {
        a4_cl.get(anchor) match {
          case p_class_decl(_,v_0,v_parent,v_2,v_3) => {
            return v_find_class(v_parent);
          }
        }
      }
    }
  }
  def c6_cl(anchor : Any) : T_ClassReference = {
    anchor match {
      case p_method(v_f,v_override,v_name,v_formals,v_ret_type,v_expr) => {
        return v_feature_class(v_f);
        throw Evaluation.UndefinedAttributeException("local cl");
      }
    }
  }
  def c7_superm(anchor : Any) : T_Feature = {
    anchor match {
      case p_method(v_f,v_override,v_name,v_formals,v_ret_type,v_expr) => {
        a6_cl.get(anchor) match {
          case p_class_decl(_,v_cn,v_parent,v_2,v_3) => {
            return v_meth_lookup(v_name,v_parent);
          }
        }
      }
    }
  }
  def c8_c(anchor : Any) : T_Scope = {
    anchor match {
      case p_method(v_f,v_override,v_name,v_formals,v_ret_type,v_expr) => {
        return v_make_scope(v_class_env(a6_cl.get(anchor)));
      }
    }
  }
  def c9_sh(anchor : Any) : T_CoolType = {
    anchor match {
      case p_assign(v_asgn,v_name,v_expr) => {
        return v_env_lookup(v_name,v_expr_env(v_asgn));
      }
    }
  }
  def c10_c(anchor : Any) : T_Scope = {
    anchor match {
      case p_let(v_let_exp,v_id,v_of_type,v_init,v_body) => {
        return v_make_scope(v_expr_env(v_let_exp));
      }
    }
  }
  def c11_sh(anchor : Any) : T_CoolType = {
    anchor match {
      case p_variable(v_obj,v_name) => {
        return v_env_lookup(v_name,v_expr_env(v_obj));
      }
    }
  }
  def c12_c(anchor : Any) : T_Scope = {
    anchor match {
      case p_branch(v_br,v_name,v_of_type,v_expr) => {
        return v_make_scope(v_case_env(v_br));
      }
    }
  }
  def c13_overlaps(anchor : Any) : T_CoolTypes = {
    anchor match {
      case t_Cases.p_append(v_cs,v_c1,v_c2) => {
        return new M__basic_19[ T_CoolType,T_CoolTypes](t_CoolType,t_CoolTypes).v__op_w5(v_cases_cases(v_c1),v_cases_cases(v_c2));
      }
    }
  }
  def c14_method_binding(anchor : Any) : T_Feature = {
    anchor match {
      case p_dispatch(v_d,v_expr,v_name,v_actuals) => {
        { val cond = v_type_equal(v_expr_type(v_expr),v_Null);
          if (!cond) {
            { val cond = v_and(new M__basic_2[ T_CoolType](t_CoolType).v__op_w0(v_expr_type(v_expr),v_Null),v_not(v_type_equal(v_expr_type(v_expr),v_errorType)));
              if (cond) {
                return v_meth_lookup(v_name,v_expr_type(v_expr));
              }
            }
          }
        }
        return t_Feature.v_nil;
      }
    }
  }
  def c15_method_binding(anchor : Any) : T_Feature = {
    anchor match {
      case p_static_dispatch(v_d,v_expr,v_type_name,v_name,v_actuals) => {
        { val cond = new M__basic_2[ T_ClassReference](t_ClassReference).v__op_w0(v_find_class(v_type_name),t_Class.v_nil);
          if (cond) {
            return v_meth_lookup(v_name,v_type_name);
          }
        }
        return t_Feature.v_nil;
      }
    }
  }
  def c_class_is_circular(anode : T_Class) : T_AndLattice = {
    val anchor = anode;
    anchor match {
      case p_class_decl(v_cl,v_name,v_parent,v_features,v_filename) => {
        { val cond = new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_name,v_Any);
          if (cond) {
            if (anode eq v_cl) return v_false;
          }
          if (!cond) {
            { val cond = v_or(new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_name,v_Nothing),new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_name,v_Null));
              if (cond) {
                if (anode eq v_cl) return v_false;
              }
              if (!cond) {
                { val cond = new M__basic_2[ T_ClassReference](t_ClassReference).v__op_0(a3_pcl.get(anchor),t_Class.v_nil);
                  if (cond) {
                    if (anode eq v_cl) return v_false;
                  }
                  if (!cond) {
                    if (anode eq v_cl) return v_class_is_circular(a3_pcl.get(anchor));
                  }
                }
              }
            }
          }
        }
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".class_is_circular");
  }
  def c_features_class(anode : T_Features) : T_ClassReference = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Class.nodes) anchor match {
        case p_class_decl(v_cl,v_name,v_parent,v_features,v_filename) => {
          if (anode eq v_features) return v_cl;
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Features.nodes) anchor match {
        case t_Features.p_append(v_feas,v_fs1,v_fs2) => {
          if (anode eq v_fs1) return v_features_class(v_feas);
          if (anode eq v_fs2) return v_features_class(v_feas);
        }
        case _ => {}
      }
    }
    return t_Class.v_nil;
  }
  def c_feature_class(anode : T_Feature) : T_ClassReference = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Features.nodes) anchor match {
        case t_Features.p_single(v_feas,v_f) => {
          if (anode eq v_f) return v_features_class(v_feas);
        }
        case _ => {}
      }
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".feature_class");
  }
  def c_class_attr_table(anode : T_Class) : T_AttrTable = {
    var collection : T_AttrTable = t_AttrTable.v_initial;
    for (anchor <- t_Result.t_Feature.nodes) anchor match {
      case p_attr(v_f,v_name,v_of_type) => {
        if (anode eq a4_cl.get(anchor)) collection = t_AttrTable.v_combine(collection,t_AttrTable.v_table_entry(v_name,t_FeatureReferences.v_single(v_f)));
      }
      case _ => {}
    }
    return collection;
  }
  def c_class_meth_table(anode : T_Class) : T_MethodTable = {
    var collection : T_MethodTable = t_MethodTable.v_initial;
    for (anchor <- t_Result.t_Feature.nodes) anchor match {
      case p_method(v_f,v_override,v_name,v_formals,v_ret_type,v_expr) => {
        if (anode eq a6_cl.get(anchor)) collection = t_MethodTable.v_combine(collection,t_MethodTable.v_table_entry(v_name,t_FeatureReferences.v_single(v_f)));
      }
      case _ => {}
    }
    return collection;
  }
  def c_table(anode : T_ScopeObject) : T_Contour = {
    var collection : T_Contour = t_Contour.v_initial;
    for (anchor <- t_Result.t_Class.nodes) anchor match {
      case p_class_decl(v_cl,v_name,v_parent,v_features,v_filename) => {
        { val cond = v_and(v_not(v_class_is_circular(v_cl)),new M__basic_2[ T_ClassReference](t_ClassReference).v__op_w0(a3_pcl.get(anchor),t_Class.v_nil));
          if (cond) {
            if (anode eq v_class_env(v_cl)) collection = t_Contour.v_combine(collection,v_table(v_class_env(a3_pcl.get(anchor))));
          }
        }
      }
      case _ => {}
    }
    for (anchor <- t_Result.t_Feature.nodes) anchor match {
      case p_attr(v_f,v_name,v_of_type) => {
        if (anode eq v_class_env(a4_cl.get(anchor))) collection = t_Contour.v_combine(collection,t_Contour.v_table_entry(v_name,t_CoolTypes.v_single(v_of_type)));
      }
      case _ => {}
    }
    for (anchor <- t_Result.t_Feature.nodes) anchor match {
      case p_method(v_f,v_override,v_name,v_formals,v_ret_type,v_expr) => {
        a6_cl.get(anchor) match {
          case p_class_decl(_,v_cn,v_parent,v_2,v_3) => {
            if (anode eq a8_c.get(anchor)) collection = t_Contour.v_combine(collection,t_Contour.v_table_entry(v_This,t_CoolTypes.v_single(v_cn)));
          }
        }
      }
      case _ => {}
    }
    for (anchor <- t_Result.t_Formal.nodes) anchor match {
      case p_formal(v_f,v_n,v_of_type) => {
        if (anode eq v_formal_env(v_f)) collection = t_Contour.v_combine(collection,t_Contour.v_table_entry(v_n,t_CoolTypes.v_single(v_of_type)));
      }
      case _ => {}
    }
    for (anchor <- t_Result.t_Expression.nodes) anchor match {
      case p_let(v_let_exp,v_id,v_of_type,v_init,v_body) => {
        if (anode eq a10_c.get(anchor)) collection = t_Contour.v_combine(collection,t_Contour.v_table_entry(v_id,t_CoolTypes.v_single(v_of_type)));
      }
      case _ => {}
    }
    for (anchor <- t_Result.t_Case.nodes) anchor match {
      case p_branch(v_br,v_name,v_of_type,v_expr) => {
        if (anode eq a12_c.get(anchor)) collection = t_Contour.v_combine(collection,t_Contour.v_table_entry(v_name,t_CoolTypes.v_single(v_of_type)));
      }
      case _ => {}
    }
    return collection;
  }
  def c_class_env(anode : T_Class) : T_Environment = {
    val anchor = anode;
    anchor match {
      case p_class_decl(v_cl,v_name,v_parent,v_features,v_filename) => {
        if (anode eq v_cl) return v_scope(t_Symbol.v_name(v_filename),t_Environment.v_nil);
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".class_env");
  }
  def c_formals_env(anode : T_Formals) : T_Environment = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Feature.nodes) anchor match {
        case p_method(v_f,v_override,v_name,v_formals,v_ret_type,v_expr) => {
          if (anode eq v_formals) return a8_c.get(anchor);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Formals.nodes) anchor match {
        case t_Formals.p_append(v_fmls,v_fmls1,v_fmls2) => {
          if (anode eq v_fmls1) return v_formals_env(v_fmls);
          if (anode eq v_fmls2) return v_formals_env(v_fmls);
        }
        case _ => {}
      }
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".formals_env");
  }
  def c_formal_env(anode : T_Formal) : T_Environment = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Formals.nodes) anchor match {
        case t_Formals.p_single(v_fmls,v_f) => {
          if (anode eq v_f) return v_formals_env(v_fmls);
        }
        case _ => {}
      }
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".formal_env");
  }
  def c_exprs_env(anode : T_Expressions) : T_Environment = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_block(v_bl,v_body) => {
          if (anode eq v_body) return v_expr_env(v_bl);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expressions.nodes) anchor match {
        case t_Expressions.p_append(v_exprs,v_es1,v_es2) => {
          if (anode eq v_es1) return v_exprs_env(v_exprs);
          if (anode eq v_es2) return v_exprs_env(v_exprs);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_dispatch(v_d,v_expr,v_name,v_actuals) => {
          if (anode eq v_actuals) return v_expr_env(v_d);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_static_dispatch(v_d,v_expr,v_type_name,v_name,v_actuals) => {
          if (anode eq v_actuals) return v_expr_env(v_d);
        }
        case _ => {}
      }
    }
    return t_Scope.v_nil;
  }
  def c_expr_env(anode : T_Expression) : T_Environment = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Feature.nodes) anchor match {
        case p_method(v_f,v_override,v_name,v_formals,v_ret_type,v_expr) => {
          if (anode eq v_expr) return a8_c.get(anchor);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_assign(v_asgn,v_name,v_expr) => {
          if (anode eq v_expr) return v_expr_env(v_asgn);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_cond(v_cond_expr,v_pred,v_then_exp,v_else_exp) => {
          if (anode eq v_pred) return v_expr_env(v_cond_expr);
          if (anode eq v_then_exp) return v_expr_env(v_cond_expr);
          if (anode eq v_else_exp) return v_expr_env(v_cond_expr);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_loop(v_l,v_pred,v_body) => {
          if (anode eq v_pred) return v_expr_env(v_l);
          if (anode eq v_body) return v_expr_env(v_l);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expressions.nodes) anchor match {
        case t_Expressions.p_single(v_exprs,v_e) => {
          if (anode eq v_e) return v_exprs_env(v_exprs);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_let(v_let_exp,v_id,v_of_type,v_init,v_body) => {
          if (anode eq v_init) return v_expr_env(v_let_exp);
          if (anode eq v_body) return a10_c.get(anchor);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_add(v_p,v_e1,v_e2) => {
          if (anode eq v_e1) return v_expr_env(v_p);
          if (anode eq v_e2) return v_expr_env(v_p);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_sub(v_p,v_e1,v_e2) => {
          if (anode eq v_e1) return v_expr_env(v_p);
          if (anode eq v_e2) return v_expr_env(v_p);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_mul(v_p,v_e1,v_e2) => {
          if (anode eq v_e1) return v_expr_env(v_p);
          if (anode eq v_e2) return v_expr_env(v_p);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_div(v_p,v_e1,v_e2) => {
          if (anode eq v_e1) return v_expr_env(v_p);
          if (anode eq v_e2) return v_expr_env(v_p);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_neg(v_p,v_e) => {
          if (anode eq v_e) return v_expr_env(v_p);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_lt(v_p,v_e1,v_e2) => {
          if (anode eq v_e1) return v_expr_env(v_p);
          if (anode eq v_e2) return v_expr_env(v_p);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_leq(v_p,v_e1,v_e2) => {
          if (anode eq v_e1) return v_expr_env(v_p);
          if (anode eq v_e2) return v_expr_env(v_p);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_comp(v_p,v_e) => {
          if (anode eq v_e) return v_expr_env(v_p);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Case.nodes) anchor match {
        case p_branch(v_br,v_name,v_of_type,v_expr) => {
          if (anode eq v_expr) return a12_c.get(anchor);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_typecase(v_ty,v_expr,v_cases) => {
          if (anode eq v_expr) return v_expr_env(v_ty);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_dispatch(v_d,v_expr,v_name,v_actuals) => {
          if (anode eq v_expr) return v_expr_env(v_d);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_static_dispatch(v_d,v_expr,v_type_name,v_name,v_actuals) => {
          if (anode eq v_expr) return v_expr_env(v_d);
        }
        case _ => {}
      }
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".expr_env");
  }
  def c_expr_type(anode : T_Expression) : T_CoolType = {
    val anchor = anode;
    anchor match {
      case p_assign(v_asgn,v_name,v_expr) => {
        if (anode eq v_asgn) return v_Unit;
      }
      case _ => {}
    }
    anchor match {
      case p_cond(v_cond_expr,v_pred,v_then_exp,v_else_exp) => {
        if (anode eq v_cond_expr) return v_type_lub(v_expr_type(v_then_exp),v_expr_type(v_else_exp));
      }
      case _ => {}
    }
    anchor match {
      case p_loop(v_l,v_pred,v_body) => {
        if (anode eq v_l) return v_Unit;
      }
      case _ => {}
    }
    anchor match {
      case p_block(v_bl,v_body) => {
        { val cond = new M__basic_2[ T_Integer](t_Integer).v__op_0(new M__basic_22[ t_Result.T_Expression,T_Expressions](t_Result.t_Expression,t_Expressions).v_length(v_body),0);
          if (cond) {
            if (anode eq v_bl) return v_Unit;
          }
          if (!cond) {
            if (anode eq v_bl) return new M__basic_16[ T_CoolType,T_CoolTypeList](t_CoolType,t_CoolTypeList).v_last(v_exprs_type(v_body));
          }
        }
      }
      case _ => {}
    }
    anchor match {
      case p_let(v_let_exp,v_id,v_of_type,v_init,v_body) => {
        if (anode eq v_let_exp) return v_expr_type(v_body);
      }
      case _ => {}
    }
    anchor match {
      case p_add(v_p,v_e1,v_e2) => {
        if (anode eq v_p) return v_Int;
      }
      case _ => {}
    }
    anchor match {
      case p_sub(v_p,v_e1,v_e2) => {
        if (anode eq v_p) return v_Int;
      }
      case _ => {}
    }
    anchor match {
      case p_mul(v_p,v_e1,v_e2) => {
        if (anode eq v_p) return v_Int;
      }
      case _ => {}
    }
    anchor match {
      case p_div(v_p,v_e1,v_e2) => {
        if (anode eq v_p) return v_Int;
      }
      case _ => {}
    }
    anchor match {
      case p_neg(v_p,v_e) => {
        if (anode eq v_p) return v_Int;
      }
      case _ => {}
    }
    anchor match {
      case p_lt(v_p,v_e1,v_e2) => {
        if (anode eq v_p) return v_Bool;
      }
      case _ => {}
    }
    anchor match {
      case p_leq(v_p,v_e1,v_e2) => {
        if (anode eq v_p) return v_Bool;
      }
      case _ => {}
    }
    anchor match {
      case p_comp(v_p,v_e) => {
        if (anode eq v_p) return v_Bool;
      }
      case _ => {}
    }
    anchor match {
      case p_int_lit(v_e,v_token) => {
        if (anode eq v_e) return v_Int;
      }
      case _ => {}
    }
    anchor match {
      case p_string_lit(v_e,v_token) => {
        if (anode eq v_e) return v_Str;
      }
      case _ => {}
    }
    anchor match {
      case p_bool_lit(v_e,v_val) => {
        if (anode eq v_e) return v_Bool;
      }
      case _ => {}
    }
    anchor match {
      case p_alloc(v_new_exp,v_type_name) => {
        if (anode eq v_new_exp) return v_type_name;
      }
      case _ => {}
    }
    anchor match {
      case p_variable(v_obj,v_name) => {
        if (anode eq v_obj) return a11_sh.get(anchor);
      }
      case _ => {}
    }
    anchor match {
      case p_typecase(v_ty,v_expr,v_cases) => {
        if (anode eq v_ty) return v_cases_type(v_cases);
      }
      case _ => {}
    }
    anchor match {
      case p_dispatch(v_d,v_expr,v_name,v_actuals) => {
        { val cond = new M__basic_2[ T_Feature](t_Feature).v__op_0(a14_method_binding.get(anchor),t_Feature.v_nil);
          if (cond) {
            if (anode eq v_d) return v_errorType;
          }
          if (!cond) {
            a14_method_binding.get(anchor) match {
              case p_method(_,v_0,v_1,v_fs,v_rt,v_4) => {
                if (anode eq v_d) return v_rt;
              }
            }
          }
        }
      }
      case _ => {}
    }
    anchor match {
      case p_static_dispatch(v_d,v_expr,v_type_name,v_name,v_actuals) => {
        { val cond = new M__basic_2[ T_Feature](t_Feature).v__op_0(a15_method_binding.get(anchor),t_Feature.v_nil);
          if (cond) {
            if (anode eq v_d) return v_errorType;
          }
          if (!cond) {
            a15_method_binding.get(anchor) match {
              case p_method(_,v_0,v_1,v_fs,v_rt,v_4) => {
                if (anode eq v_d) return v_rt;
              }
            }
          }
        }
      }
      case _ => {}
    }
    anchor match {
      case p_no_expr(v_e) => {
        if (anode eq v_e) return v_errorType;
      }
      case _ => {}
    }
    anchor match {
      case p_nil(v_e) => {
        if (anode eq v_e) return v_Null;
      }
      case _ => {}
    }
    anchor match {
      case p_unit(v_e) => {
        if (anode eq v_e) return v_Unit;
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".expr_type");
  }
  def c_exprs_type(anode : T_Expressions) : T_CoolTypeList = {
    val anchor = anode;
    anchor match {
      case t_Expressions.p_single(v_exprs,v_e) => {
        if (anode eq v_exprs) return t_CoolTypeList.v_single(v_expr_type(v_e));
      }
      case _ => {}
    }
    anchor match {
      case t_Expressions.p_append(v_exprs,v_es1,v_es2) => {
        if (anode eq v_exprs) return t_CoolTypeList.v_append(v_exprs_type(v_es1),v_exprs_type(v_es2));
      }
      case _ => {}
    }
    anchor match {
      case t_Expressions.p_none(v_exprs) => {
        if (anode eq v_exprs) return t_CoolTypeList.v_none();
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".exprs_type");
  }
  def c_formal_type(anode : T_Formal) : T_CoolType = {
    val anchor = anode;
    anchor match {
      case p_formal(v_f,v_n,v_of_type) => {
        if (anode eq v_f) return v_of_type;
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".formal_type");
  }
  def c_formals_types(anode : T_Formals) : T_CoolTypeList = {
    val anchor = anode;
    anchor match {
      case t_Formals.p_none(v_fmls) => {
        if (anode eq v_fmls) return t_CoolTypeList.v_none();
      }
      case _ => {}
    }
    anchor match {
      case t_Formals.p_single(v_fmls,v_f) => {
        if (anode eq v_fmls) return t_CoolTypeList.v_single(v_formal_type(v_f));
      }
      case _ => {}
    }
    anchor match {
      case t_Formals.p_append(v_fmls,v_fmls1,v_fmls2) => {
        if (anode eq v_fmls) return new M__basic_18[ T_CoolTypeList](t_CoolTypeList).v__op_ss(v_formals_types(v_fmls1),v_formals_types(v_fmls2));
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".formals_types");
  }
  def c_case_env(anode : T_Case) : T_Environment = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Cases.nodes) anchor match {
        case t_Cases.p_single(v_cs,v_c) => {
          if (anode eq v_c) return v_cases_env(v_cs);
        }
        case _ => {}
      }
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".case_env");
  }
  def c_cases_env(anode : T_Cases) : T_Environment = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Expression.nodes) anchor match {
        case p_typecase(v_ty,v_expr,v_cases) => {
          if (anode eq v_cases) return v_expr_env(v_ty);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Cases.nodes) anchor match {
        case t_Cases.p_append(v_cs,v_c1,v_c2) => {
          if (anode eq v_c1) return v_cases_env(v_cs);
          if (anode eq v_c2) return v_cases_env(v_cs);
        }
        case _ => {}
      }
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".cases_env");
  }
  def c_case_cases(anode : T_Case) : T_CoolTypes = {
    val anchor = anode;
    anchor match {
      case p_branch(v_br,v_name,v_of_type,v_expr) => {
        if (anode eq v_br) return t_CoolTypes.v_single(v_of_type);
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".case_cases");
  }
  def c_cases_cases(anode : T_Cases) : T_CoolTypes = {
    val anchor = anode;
    anchor match {
      case t_Cases.p_single(v_cs,v_c) => {
        if (anode eq v_cs) return v_case_cases(v_c);
      }
      case _ => {}
    }
    anchor match {
      case t_Cases.p_append(v_cs,v_c1,v_c2) => {
        if (anode eq v_cs) return new M__basic_19[ T_CoolType,T_CoolTypes](t_CoolType,t_CoolTypes).v__op_5w(v_cases_cases(v_c1),v_cases_cases(v_c2));
      }
      case _ => {}
    }
    anchor match {
      case t_Cases.p_none(v_cs) => {
        if (anode eq v_cs) return t_CoolTypes.v_none();
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".cases_cases");
  }
  def c_cases_type(anode : T_Cases) : T_CoolType = {
    val anchor = anode;
    anchor match {
      case t_Cases.p_single(v_cs,v_c) => {
        if (anode eq v_cs) return v_case_type(v_c);
      }
      case _ => {}
    }
    anchor match {
      case t_Cases.p_append(v_cs,v_c1,v_c2) => {
        if (anode eq v_cs) return v_type_lub(v_cases_type(v_c1),v_cases_type(v_c2));
      }
      case _ => {}
    }
    anchor match {
      case t_Cases.p_none(v_cs) => {
        if (anode eq v_cs) return v_errorType;
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".cases_type");
  }
  def c_case_type(anode : T_Case) : T_CoolType = {
    val anchor = anode;
    anchor match {
      case p_branch(v_br,v_name,v_of_type,v_expr) => {
        if (anode eq v_br) return v_expr_type(v_expr);
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".case_type");
  }
  def c_class_table() : T_ClassTable = {
    Debug.begin("class_table");
    try {
      var collection : T_ClassTable = t_ClassTable.v_initial;
      for (anchor <- t_Result.t_Class.nodes) anchor match {
        case p_class_decl(v_cl,v_name,v_parent,v_features,v_filename) => {
          collection = t_ClassTable.v_combine(collection,t_ClassTable.v_table_entry(v_name,t_ClassReferences.v_single(v_cl)));
        }
        case _ => {}
      }
      Debug.returns(collection.toString());
      return collection;
    } finally { Debug.end(); }
  }
  def c_messages() : T_Messages = {
    Debug.begin("messages");
    try {
      var collection : T_Messages = t_Messages.v_initial;
      for (anchor <- t_Result.t_Program.nodes) anchor match {
        case p_program(v_p,v_0) => {
          { val cond = new M__basic_2[ T_ClassReference](t_ClassReference).v__op_0(a1_main_class.get(anchor),t_Class.v_nil);
            if (cond) {
              collection = t_Messages.v_combine(collection,t_Messages.v_single("No Main class defined"));
            }
            if (!cond) {
              { val cond = new M__basic_2[ T_Feature](t_Feature).v__op_0(a2_main_constructor.get(anchor),t_Feature.v_nil);
                if (cond) {
                  collection = t_Messages.v_combine(collection,v_message(v_class_env(a1_main_class.get(anchor)),new M__basic_24[ T_ClassReference](t_ClassReference).v_lineno(a1_main_class.get(anchor)),"class Main does not have a constructor"));
                }
                if (!cond) {
                  a2_main_constructor.get(anchor) match {
                    case p_method(_,v_0,v_1,v_fs,v_3,v_4) => {
                      { val cond = new M__basic_3[ T_Integer](t_Integer).v__op_1(new M__basic_22[ t_Result.T_Formal,t_Result.T_Formals](t_Result.t_Formal,t_Result.t_Formals).v_length(v_fs),0);
                        if (cond) {
                          collection = t_Messages.v_combine(collection,v_message(v_class_env(a1_main_class.get(anchor)),new M__basic_24[ t_Result.T_Formals](t_Result.t_Formals).v_lineno(v_fs),"Main constructor incorrectly has parameters"));
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Class.nodes) anchor match {
        case p_class_decl(v_cl,v_name,v_parent,v_features,v_filename) => {
          { val cond = new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_name,v_Any);
            if (!cond) {
              { val cond = v_or(new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_name,v_Nothing),new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_name,v_Null));
                if (cond) {
                  collection = t_Messages.v_combine(collection,v_message(v_class_env(v_cl),new M__basic_24[ T_Class](t_Class).v_lineno(v_cl),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("class ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_name," may not be defined"))));
                }
                if (!cond) {
                  { val cond = new M__basic_2[ T_ClassReference](t_ClassReference).v__op_0(a3_pcl.get(anchor),t_Class.v_nil);
                    if (cond) {
                      collection = t_Messages.v_combine(collection,v_message(v_class_env(v_cl),new M__basic_24[ T_Class](t_Class).v_lineno(v_cl),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB("superclass not defined: ",v_parent)));
                    }
                  }
                }
              }
            }
          }
          { val cond = new M__basic_2[ T_ClassReference](t_ClassReference).v__op_w0(v_find_class(v_name),v_cl);
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_class_env(v_cl),new M__basic_24[ T_Class](t_Class).v_lineno(v_cl),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("class ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_name," is multiply defined"))));
            }
          }
          { val cond = v_class_is_circular(v_cl);
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_class_env(v_cl),new M__basic_24[ T_Class](t_Class).v_lineno(v_cl),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("class ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_name," is involved in circular inheritance"))));
            }
          }
          { val cond = v_or(v_or(new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_parent,v_Nothing),new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_parent,v_Null)),v_not_inheritable(a3_pcl.get(anchor)));
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_class_env(v_cl),new M__basic_24[ T_Class](t_Class).v_lineno(v_cl),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB("cannot inherit from ",v_parent)));
            }
          }
          { val cond = new M__basic_2[ T_Feature](t_Feature).v__op_0(v_meth_lookup(v_name,v_name),t_Feature.v_nil);
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_class_env(v_cl),new M__basic_24[ T_Class](t_Class).v_lineno(v_cl),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB("Warning: No constructor defined for class ",v_name)));
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Feature.nodes) anchor match {
        case p_attr(v_f,v_name,v_of_type) => {
          { val cond = new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_name,v_This);
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_class_env(a4_cl.get(anchor)),new M__basic_24[ T_Feature](t_Feature).v_lineno(v_f),"'this' cannot be the name of an attribute."));
            }
          }
          { val cond = new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_of_type,v_Nothing);
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_class_env(a4_cl.get(anchor)),new M__basic_24[ T_Feature](t_Feature).v_lineno(v_f),"Fields may not be given 'Nothing' type."));
            }
            if (!cond) {
              { val cond = v_and(v_and(new M__basic_2[ T_Symbol](t_Symbol).v__op_w0(v_of_type,v_Native),new M__basic_2[ T_Symbol](t_Symbol).v__op_w0(v_of_type,v_Null)),new M__basic_2[ T_ClassReference](t_ClassReference).v__op_0(v_find_class(v_of_type),t_Class.v_nil));
                if (cond) {
                  collection = t_Messages.v_combine(collection,v_message(v_class_env(a4_cl.get(anchor)),new M__basic_24[ T_Feature](t_Feature).v_lineno(v_f),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Class ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_of_type,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" of attribute ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_name," is undefined."))))));
                }
              }
            }
          }
          a4_cl.get(anchor) match {
            case p_class_decl(_,v_0,v_parent,v_2,v_3) => {
              { val cond = v_and(new M__basic_2[ T_ClassReference](t_ClassReference).v__op_w0(a5_pcl.get(anchor),t_Class.v_nil),new M__basic_2[ T_CoolType](t_CoolType).v__op_w0(v_env_lookup(v_name,v_class_env(a5_pcl.get(anchor))),v_errorType));
                if (cond) {
                  collection = t_Messages.v_combine(collection,v_message(v_class_env(a4_cl.get(anchor)),new M__basic_24[ T_Feature](t_Feature).v_lineno(v_f),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB("overriding feature ",v_name)));
                }
              }
            }
          }
          t_AttrTable.v_select(v_class_attr_table(a4_cl.get(anchor)),v_name) match {
            case t_AttrTable.p_table_entry(_,v_0,t_FeatureReferences.p__op_AC(_,v_ff,_*)) => {
              { val cond = new M__basic_2[ T_FeatureRemote](t_FeatureRemote).v__op_w0(v_ff,v_f);
                if (cond) {
                  collection = t_Messages.v_combine(collection,v_message(v_class_env(a4_cl.get(anchor)),new M__basic_24[ T_Feature](t_Feature).v_lineno(v_f),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB("duplicate feature ",v_name)));
                }
              }
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Feature.nodes) anchor match {
        case p_method(v_f,v_override,v_name,v_formals,v_ret_type,v_expr) => {
          { val cond = v_and(v_and(new M__basic_2[ T_Symbol](t_Symbol).v__op_w0(v_ret_type,v_Null),new M__basic_2[ T_Symbol](t_Symbol).v__op_w0(v_ret_type,v_Nothing)),new M__basic_2[ T_ClassReference](t_ClassReference).v__op_0(v_find_class(v_ret_type),t_Class.v_nil));
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_class_env(a6_cl.get(anchor)),new M__basic_24[ T_Feature](t_Feature).v_lineno(v_f),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Undefined return type ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_ret_type,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" in method ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_name,"."))))));
            }
          }
          a6_cl.get(anchor) match {
            case p_class_decl(_,v_cn,v_parent,v_2,v_3) => {
              { val cond = new M__basic_2[ T_Symbol](t_Symbol).v__op_w0(v_cn,v_Any);
                if (cond) {
                  { val cond = new M__basic_2[ T_Feature](t_Feature).v__op_w0(a7_superm.get(anchor),t_Feature.v_nil);
                    if (cond) {
                      { val cond = v_not(v_override);
                        if (cond) {
                          collection = t_Messages.v_combine(collection,v_message(a8_c.get(anchor),new M__basic_24[ T_Feature](t_Feature).v_lineno(v_f),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB("implicit overriding of ",v_name)));
                        }
                      }
                      { val cond = v_not(v_methods_match(a7_superm.get(anchor),v_f));
                        if (cond) {
                          collection = t_Messages.v_combine(collection,v_message(a8_c.get(anchor),new M__basic_24[ T_Feature](t_Feature).v_lineno(v_f),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB("error overriding method ",v_name)));
                        }
                      }
                    }
                    if (!cond) {
                      { val cond = v_override;
                        if (cond) {
                          collection = t_Messages.v_combine(collection,v_message(a8_c.get(anchor),new M__basic_24[ T_Feature](t_Feature).v_lineno(v_f),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB("nothing to override for ",v_name)));
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          t_MethodTable.v_select(v_class_meth_table(a6_cl.get(anchor)),v_name) match {
            case t_MethodTable.p_table_entry(_,v_0,t_FeatureReferences.p__op_AC(_,v_ff,_*)) => {
              { val cond = new M__basic_2[ T_Feature](t_Feature).v__op_w0(v_f,v_ff);
                if (cond) {
                  collection = t_Messages.v_combine(collection,v_message(a8_c.get(anchor),new M__basic_24[ T_Feature](t_Feature).v_lineno(v_f),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB("duplicate method definition ",v_name)));
                }
              }
            }
          }
          { val cond = v_not(v_type_leq(v_expr_type(v_expr),v_ret_type));
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(a8_c.get(anchor),new M__basic_24[ T_Feature](t_Feature).v_lineno(v_f),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Inferred return type ",new M__basic_21[ T_CoolType,T_String](t_CoolType,t_String).v__op_BB(v_expr_type(v_expr),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" of method ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_name,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" does not conform to declared return type ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_ret_type,"."))))))));
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Formal.nodes) anchor match {
        case p_formal(v_f,v_n,v_of_type) => {
          { val cond = new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_n,v_This);
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_formal_env(v_f),new M__basic_24[ T_Formal](t_Formal).v_lineno(v_f),"'self' cannot be the name of a formal parameter."));
            }
          }
          { val cond = v_and(new M__basic_2[ T_Symbol](t_Symbol).v__op_w0(v_of_type,v_Native),new M__basic_2[ T_ClassReference](t_ClassReference).v__op_0(v_find_class(v_of_type),t_Class.v_nil));
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_formal_env(v_f),new M__basic_24[ T_Formal](t_Formal).v_lineno(v_f),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Class ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_of_type,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" of formal parameter ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_n," is undefined."))))));
            }
          }
          t_Contour.v_select(v_table(v_formal_env(v_f)),v_n) match {
            case t_Contour.p_table_entry(_,v_0,v_fs) => {
              { val cond = new M__basic_3[ T_Integer](t_Integer).v__op_10(new M__basic_22[ T_CoolType,T_CoolTypes](t_CoolType,t_CoolTypes).v_length(v_fs),2);
                if (cond) {
                  collection = t_Messages.v_combine(collection,v_message(v_formal_env(v_f),new M__basic_24[ T_Formal](t_Formal).v_lineno(v_f),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB("duplicate formal ",v_n)));
                }
              }
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_assign(v_asgn,v_name,v_expr) => {
          { val cond = new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_name,v_This);
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_expr),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_asgn),"Cannot assign to 'this'."));
            }
          }
          { val cond = new M__basic_2[ T_Environment](t_Environment).v__op_w0(v_expr_env(v_asgn),t_Environment.v_nil);
            if (cond) {
              { val cond = v_type_equal(a9_sh.get(anchor),v_errorType);
                if (cond) {
                  collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_expr),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_asgn),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Assignment to undeclared variable ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_name,"."))));
                }
                if (!cond) {
                  { val cond = v_not(v_type_leq(v_expr_type(v_expr),a9_sh.get(anchor)));
                    if (cond) {
                      collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_expr),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_asgn),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Type ",new M__basic_21[ T_CoolType,T_String](t_CoolType,t_String).v__op_BB(v_expr_type(v_expr),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" of assigned expression does not conform",new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" to declared type ",new M__basic_21[ T_CoolType,T_String](t_CoolType,t_String).v__op_BB(a9_sh.get(anchor),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" of identifier ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_name,".")))))))));
                    }
                  }
                }
              }
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_cond(v_cond_expr,v_pred,v_then_exp,v_else_exp) => {
          { val cond = v_not(v_type_equal(v_expr_type(v_pred),v_Bool));
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_pred),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_pred),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Predicate for 'if' has type ",new M__basic_21[ T_CoolType,T_String](t_CoolType,t_String).v__op_BB(v_expr_type(v_pred)," instead of Boolean."))));
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_loop(v_l,v_pred,v_body) => {
          { val cond = v_not(v_type_equal(v_expr_type(v_pred),v_Bool));
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_pred),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_pred),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Predicate for 'while' is ",new M__basic_21[ T_CoolType,T_String](t_CoolType,t_String).v__op_BB(v_expr_type(v_pred)," instead of Boolean"))));
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_let(v_let_exp,v_id,v_of_type,v_init,v_body) => {
          { val cond = new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_id,v_This);
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_let_exp),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_let_exp),"'this' cannot be bound as a local variable."));
            }
          }
          { val cond = new M__basic_2[ T_CoolType](t_CoolType).v__op_w0(v_env_lookup(v_id,v_expr_env(v_let_exp)),v_errorType);
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_let_exp),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_let_exp),"cannot shadow with a local variable."));
            }
          }
          { val cond = v_and(v_and(new M__basic_2[ T_Symbol](t_Symbol).v__op_w0(v_of_type,v_Nothing),new M__basic_2[ T_Symbol](t_Symbol).v__op_w0(v_of_type,v_Null)),new M__basic_2[ T_ClassReference](t_ClassReference).v__op_0(v_find_class(v_of_type),t_Class.v_nil));
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_let_exp),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_let_exp),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Class ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_of_type,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" of local identifier ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_id," is undefined."))))));
            }
            if (!cond) {
              { val cond = v_not(v_type_leq(v_expr_type(v_init),v_of_type));
                if (cond) {
                  collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_let_exp),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_let_exp),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Inferred type ",new M__basic_21[ T_CoolType,T_String](t_CoolType,t_String).v__op_BB(v_expr_type(v_init),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" of initialization of ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_id,new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" does not conform to identifier's declared",new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB(" type ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_of_type,".")))))))));
                }
              }
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_add(v_p,v_e1,v_e2) => {
          collection = t_Messages.v_combine(collection,v_check_int_arguments(v_expr_env(v_p),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_e2),"+",v_expr_type(v_e1),v_expr_type(v_e2)));
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_sub(v_p,v_e1,v_e2) => {
          collection = t_Messages.v_combine(collection,v_check_int_arguments(v_expr_env(v_p),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_e2),"-",v_expr_type(v_e1),v_expr_type(v_e2)));
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_mul(v_p,v_e1,v_e2) => {
          collection = t_Messages.v_combine(collection,v_check_int_arguments(v_expr_env(v_p),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_e2),"*",v_expr_type(v_e1),v_expr_type(v_e2)));
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_div(v_p,v_e1,v_e2) => {
          collection = t_Messages.v_combine(collection,v_check_int_arguments(v_expr_env(v_p),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_e2),"/",v_expr_type(v_e1),v_expr_type(v_e2)));
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_neg(v_p,v_e) => {
          { val cond = v_not(v_type_equal(v_expr_type(v_e),v_Int));
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_p),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_e),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Argument of unary '-' has type ",new M__basic_21[ T_CoolType,T_String](t_CoolType,t_String).v__op_BB(v_expr_type(v_e)," instead of Integer."))));
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_lt(v_p,v_e1,v_e2) => {
          collection = t_Messages.v_combine(collection,v_check_int_arguments(v_expr_env(v_p),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_e2),"<",v_expr_type(v_e1),v_expr_type(v_e2)));
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_leq(v_p,v_e1,v_e2) => {
          collection = t_Messages.v_combine(collection,v_check_int_arguments(v_expr_env(v_p),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_e2),"<=",v_expr_type(v_e1),v_expr_type(v_e2)));
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_comp(v_p,v_e) => {
          { val cond = v_not(v_type_equal(v_expr_type(v_e),v_Bool));
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_p),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_e),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Argument of 'not' has type ",new M__basic_21[ T_CoolType,T_String](t_CoolType,t_String).v__op_BB(v_expr_type(v_e)," instead of Boolean."))));
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_alloc(v_new_exp,v_type_name) => {
          { val cond = new M__basic_2[ T_ClassReference](t_ClassReference).v__op_0(v_find_class(v_type_name),t_Class.v_nil);
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_new_exp),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_new_exp),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("'new' used with undefined class ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_type_name,"."))));
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_variable(v_obj,v_name) => {
          { val cond = v_and(new M__basic_2[ T_Environment](t_Environment).v__op_w0(v_expr_env(v_obj),t_Environment.v_nil),v_type_equal(a11_sh.get(anchor),v_errorType));
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_obj),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_obj),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Undeclared identifier ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_name,"."))));
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Case.nodes) anchor match {
        case p_branch(v_br,v_name,v_of_type,v_expr) => {
          { val cond = v_and(new M__basic_2[ T_Symbol](t_Symbol).v__op_w0(v_of_type,v_Null),new M__basic_2[ T_ClassReference](t_ClassReference).v__op_0(v_find_class(v_of_type),t_Class.v_nil));
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_case_env(v_br),new M__basic_24[ T_Case](t_Case).v_lineno(v_br),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Class ",new M__basic_21[ T_Symbol,T_String](t_Symbol,t_String).v__op_BB(v_of_type," of case branch is undefined."))));
            }
          }
          { val cond = new M__basic_2[ T_Symbol](t_Symbol).v__op_0(v_name,v_This);
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_case_env(v_br),new M__basic_24[ T_Case](t_Case).v_lineno(v_br),"'this' cannot be the name of a case variable."));
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Cases.nodes) anchor match {
        case t_Cases.p_append(v_cs,v_c1,v_c2) => {
          { val cond = new M__basic_2[ T_CoolTypes](t_CoolTypes).v__op_w0(a13_overlaps.get(anchor),t_CoolTypes.v_none());
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_cases_env(v_cs),new M__basic_24[ T_Cases](t_Cases).v_lineno(v_cs),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Duplicate when branches on ",new M__basic_21[ T_CoolTypes,T_String](t_CoolTypes,t_String).v__op_BB(a13_overlaps.get(anchor)," in case statement."))));
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_dispatch(v_d,v_expr,v_name,v_actuals) => {
          { val cond = v_type_equal(v_expr_type(v_expr),v_Null);
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_expr),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_d),"Dispatch on null"));
            }
            if (!cond) {
              { val cond = v_and(new M__basic_2[ T_CoolType](t_CoolType).v__op_w0(v_expr_type(v_expr),v_Null),v_not(v_type_equal(v_expr_type(v_expr),v_errorType)));
                if (cond) {
                  { val cond = new M__basic_2[ T_Feature](t_Feature).v__op_0(a14_method_binding.get(anchor),t_Feature.v_nil);
                    if (cond) {
                      collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_d),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_d),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB("Dispatch on undefined method ",v_name)));
                    }
                  }
                }
              }
            }
          }
          { val cond = new M__basic_2[ T_Feature](t_Feature).v__op_0(a14_method_binding.get(anchor),t_Feature.v_nil);
            if (!cond) {
              a14_method_binding.get(anchor) match {
                case p_method(_,v_0,v_1,v_fs,v_rt,v_4) => {
                  collection = t_Messages.v_combine(collection,v_check_arguments(v_expr_env(v_d),t_Symbol.v_string(v_name),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_d),v_exprs_type(v_actuals),v_formals_types(v_fs)));
                }
              }
            }
          }
        }
        case _ => {}
      }
      for (anchor <- t_Result.t_Expression.nodes) anchor match {
        case p_static_dispatch(v_d,v_expr,v_type_name,v_name,v_actuals) => {
          { val cond = v_not(v_type_leq(v_expr_type(v_expr),v_type_name));
            if (cond) {
              collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_d),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_d),new M__basic_21[ T_String,T_String](t_String,t_String).v__op_BB("Type mismatch on static dispatch: ",new M__basic_21[ T_CoolType,T_String](t_CoolType,t_String).v__op_BB(v_expr_type(v_expr),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB(" /<= ",v_type_name)))));
            }
          }
          { val cond = new M__basic_2[ T_ClassReference](t_ClassReference).v__op_w0(v_find_class(v_type_name),t_Class.v_nil);
            if (cond) {
              { val cond = new M__basic_2[ T_Feature](t_Feature).v__op_0(a15_method_binding.get(anchor),t_Feature.v_nil);
                if (cond) {
                  collection = t_Messages.v_combine(collection,v_message(v_expr_env(v_d),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_d),new M__basic_21[ T_String,T_Symbol](t_String,t_Symbol).v__op_BB("Dispatch on undefined method ",v_name)));
                }
              }
            }
          }
          { val cond = new M__basic_2[ T_Feature](t_Feature).v__op_0(a15_method_binding.get(anchor),t_Feature.v_nil);
            if (!cond) {
              a15_method_binding.get(anchor) match {
                case p_method(_,v_0,v_1,v_fs,v_rt,v_4) => {
                  collection = t_Messages.v_combine(collection,v_check_arguments(v_expr_env(v_d),t_Symbol.v_string(v_name),new M__basic_24[ T_Expression](t_Expression).v_lineno(v_d),v_exprs_type(v_actuals),v_formals_types(v_fs)));
                }
              }
            }
          }
        }
        case _ => {}
      }
      Debug.returns(collection.toString());
      return collection;
    } finally { Debug.end(); }
  }
  override def finish() : Unit = {
    a_class_table.get;
    a_messages.get;
    a_class_is_circular.finish;
    a_features_class.finish;
    a_feature_class.finish;
    a_class_attr_table.finish;
    a_class_meth_table.finish;
    a_table.finish;
    a_class_env.finish;
    a_formals_env.finish;
    a_formal_env.finish;
    a_exprs_env.finish;
    a_expr_env.finish;
    a_expr_type.finish;
    a_exprs_type.finish;
    a_formal_type.finish;
    a_formals_types.finish;
    a_case_env.finish;
    a_cases_env.finish;
    a_case_cases.finish;
    a_cases_cases.finish;
    a_cases_type.finish;
    a_case_type.finish;
    super.finish();
  }

}

