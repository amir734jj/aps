// Generated by aps2scala version 0.3.6
import basic_implicit._;
object first_impl_implicit {
  val first_impl_loaded = true;
import symbol_implicit._;
import table_implicit._;
import first_implicit._;
type T_FIRST_IMPL[T_T] = T_T;
}
import first_impl_implicit._;

import symbol_implicit._;
import table_implicit._;
import first_implicit._;
trait C_FIRST_IMPL[T_Result, T_T] extends C_TYPE[T_Result] with C_FIRST[T_Result] {
  type T_S <: Node;
  val t_S : C_PHYLUM[T_S];
  type T_Symbols;
  val t_Symbols : C_TYPE[T_Symbols]with C_SET[T_Symbols,T_Symbol];
  type T_SymbolTable;
  val t_SymbolTable : C_TYPE[T_SymbolTable]with C_TABLE[T_SymbolTable,T_Symbol,T_Symbols];
  type T_SymbolLattice;
  val t_SymbolLattice : C_TYPE[T_SymbolLattice]with C_UNION_LATTICE[T_SymbolLattice,T_Symbol,T_Symbols];
  type T_RemoteS;
  val t_RemoteS : C_TYPE[T_RemoteS];
  type T_RemoteSSet;
  val t_RemoteSSet : C_TYPE[T_RemoteSSet]with C_SET[T_RemoteSSet,T_RemoteS];
  val v_s_first : (T_S) => T_SymbolLattice;
  type T_DeclarationTable;
  val t_DeclarationTable : C_TYPE[T_DeclarationTable]with C_TABLE[T_DeclarationTable,T_Symbol,T_RemoteSSet];
  def v_declarationTable : T_DeclarationTable;
  val v_item_is_terminal : (T_Item) => T_Boolean;
  val v_item_symbol : (T_Item) => T_Symbol;
  val v_items_first : (T_Items) => T_SymbolLattice;
  val v_program_first : (T_Program) => T_DeclarationTable;
  val p_s_constructor : PatternFunction[(T_S)];
  def v_s_constructor : () => T_S;
  def v_epsilon : T_Symbol;
  val v_contains_epsilon : (T_Symbols) => T_Boolean;
  val v_black_dot : (T_Symbols,T_Symbols) => T_Symbols;
}

class M_FIRST_IMPL[T_T](name : String,val t_T : C_TYPE[T_T] with C_FIRST[T_T])
  extends Module(name)
  with C_FIRST_IMPL[T_T,T_T]
{
  type T_Result = T_T;
  val v_equal = t_T.v_equal;
  val v_string = t_T.v_string;
  val v_assert = t_T.v_assert;
  val v_node_equivalent = t_T.v_node_equivalent;
  type T_Program = t_T.T_Program;
  val t_Program = t_T.t_Program;
  type T_Item = t_T.T_Item;
  val t_Item = t_T.t_Item;
  type T_Items = t_T.T_Items;
  val t_Items = t_T.t_Items;
  type T_Stmt = t_T.T_Stmt;
  val t_Stmt = t_T.t_Stmt;
  type T_Stmts = t_T.T_Stmts;
  val t_Stmts = t_T.t_Stmts;
  val p_terminal = t_T.p_terminal;
  val v_terminal = t_T.v_terminal;
  val p_nonterminal = t_T.p_nonterminal;
  val v_nonterminal = t_T.v_nonterminal;
  val p_stmt = t_T.p_stmt;
  val v_stmt = t_T.v_stmt;
  val p_program = t_T.p_program;
  val v_program = t_T.v_program;

  val t_Result : this.type = this;
  abstract class T_S(t : I_PHYLUM[T_S]) extends Node(t) {}
  val t_S = new I_PHYLUM[T_S]("S");

  val t_Symbols = new M_SET[T_Symbol]("Symbols",t_Symbol)

  type T_Symbols = /*TI*/T_SET[T_Symbol];
  val t_SymbolTable = new M_TABLE[T_Symbol,T_Symbols]("SymbolTable",t_Symbol,t_Symbols)

  type T_SymbolTable = /*TI*/T_TABLE[T_Symbol,T_Symbols];
  val t_SymbolLattice = new M_UNION_LATTICE[T_Symbol,T_Symbols]("SymbolLattice",t_Symbol,t_Symbols)
    /* dumping traits */
    with C_TYPE[T_Symbols]
    with C_SET[T_Symbols, T_Symbol] {
      override val v_assert = t_Symbols.v_assert;
      override val v_equal = t_Symbols.v_equal;
      override val v_node_equivalent = t_Symbols.v_node_equivalent;
      override val v_string = t_Symbols.v_string;
      override val v_less = t_Symbols.v_less;
      override val v_less_equal = t_Symbols.v_less_equal;
      override val v_none = t_Symbols.v_none;
      override val v_single = t_Symbols.v_single;
      override val v_append = t_Symbols.v_append;
      override val v__op_AC = t_Symbols.v__op_AC;
      override val p__op_AC = t_Symbols.p__op_AC;
      override val v_member = t_Symbols.v_member;
      override val v_union = t_Symbols.v_union;
      override val v_intersect = t_Symbols.v_intersect;
      override val v_difference = t_Symbols.v_difference;
      override val v_combine = t_Symbols.v_combine;
    }

  type T_SymbolLattice = /*TI*/T_UNION_LATTICE[T_Symbol,T_Symbols];
  type T_RemoteS = T_S;
  val t_RemoteS = t_S;
  val t_RemoteSSet = new M_SET[T_RemoteS]("RemoteSSet",t_RemoteS)

  type T_RemoteSSet = /*TI*/T_SET[T_RemoteS];
  private class E_s_first(anchor : T_S) extends Evaluation[T_S,T_SymbolLattice](anchor,anchor.toString()+"."+"s_first") with CircularEvaluation[T_S,T_SymbolLattice] with CollectionEvaluation[T_S,T_SymbolLattice] {
    override def initial : T_SymbolLattice = t_SymbolLattice.v_initial;
    override def combine(v1 : T_SymbolLattice, v2 : T_SymbolLattice) = t_SymbolLattice.v_combine(v1,v2);
    def lattice() : C_LATTICE[T_SymbolLattice] = t_SymbolLattice;

  }
  private object a_s_first extends Attribute[T_S,T_SymbolLattice](t_S,t_SymbolLattice,"s_first") {
    override def createEvaluation(anchor : T_S) : Evaluation[T_S,T_SymbolLattice] = new E_s_first(anchor);
  }
  val v_s_first : T_S => T_SymbolLattice = a_s_first.get _;

  val t_DeclarationTable = new M_TABLE[T_Symbol,T_RemoteSSet]("DeclarationTable",t_Symbol,t_RemoteSSet)

  type T_DeclarationTable = /*TI*/T_TABLE[T_Symbol,T_RemoteSSet];
  private class E_declarationTable(anchor : Null) extends Evaluation[Null,T_DeclarationTable](anchor,"declarationTable") with CollectionEvaluation[Null,T_DeclarationTable] {
    override def initial : T_DeclarationTable = t_DeclarationTable.v_initial;
    override def combine(v1 : T_DeclarationTable, v2 : T_DeclarationTable) = t_DeclarationTable.v_combine(v1,v2);
  }
  private object a_declarationTable extends E_declarationTable(null) {}
  def v_declarationTable:T_DeclarationTable = a_declarationTable.get;

  private class E_item_is_terminal(anchor : T_Item) extends Evaluation[T_Item,T_Boolean](anchor,anchor.toString()+"."+"item_is_terminal") {
  }
  private object a_item_is_terminal extends Attribute[T_Item,T_Boolean](t_Item,t_Boolean,"item_is_terminal") {
    override def createEvaluation(anchor : T_Item) : Evaluation[T_Item,T_Boolean] = new E_item_is_terminal(anchor);
  }
  val v_item_is_terminal : T_Item => T_Boolean = a_item_is_terminal.get _;

  private class E_item_symbol(anchor : T_Item) extends Evaluation[T_Item,T_Symbol](anchor,anchor.toString()+"."+"item_symbol") {
  }
  private object a_item_symbol extends Attribute[T_Item,T_Symbol](t_Item,t_Symbol,"item_symbol") {
    override def createEvaluation(anchor : T_Item) : Evaluation[T_Item,T_Symbol] = new E_item_symbol(anchor);
  }
  val v_item_symbol : T_Item => T_Symbol = a_item_symbol.get _;

  private class E_items_first(anchor : T_Items) extends Evaluation[T_Items,T_SymbolLattice](anchor,anchor.toString()+"."+"items_first") with CircularEvaluation[T_Items,T_SymbolLattice] {
    def lattice() : C_LATTICE[T_SymbolLattice] = t_SymbolLattice;

  }
  private object a_items_first extends Attribute[T_Items,T_SymbolLattice](t_Items,t_SymbolLattice,"items_first") {
    override def createEvaluation(anchor : T_Items) : Evaluation[T_Items,T_SymbolLattice] = new E_items_first(anchor);
  }
  val v_items_first : T_Items => T_SymbolLattice = a_items_first.get _;

  private class E_program_first(anchor : T_Program) extends Evaluation[T_Program,T_DeclarationTable](anchor,anchor.toString()+"."+"program_first") {
  }
  private object a_program_first extends Attribute[T_Program,T_DeclarationTable](t_Program,t_DeclarationTable,"program_first") {
    override def createEvaluation(anchor : T_Program) : Evaluation[T_Program,T_DeclarationTable] = new E_program_first(anchor);
  }
  val v_program_first : T_Program => T_DeclarationTable = a_program_first.get _;

  case class c_s_constructor() extends T_S(t_S) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "s_constructor("+ ")";
    }
  }
  def u_s_constructor(x:Any) : Option[(T_S)] = x match {
    case x@c_s_constructor() => Some(x);
    case _ => None };
  val v_s_constructor = f_s_constructor _;
  def f_s_constructor():T_S = c_s_constructor().register;
  val p_s_constructor = new PatternFunction[(T_S)](u_s_constructor);

  val v_epsilon:T_Symbol = v_make_symbol("Nil");
  private class E1_temp(anchor : t_Result.T_Stmt) extends Evaluation[t_Result.T_Stmt,T_SymbolLattice](anchor,anchor.toString()+"."+"temp") with CircularEvaluation[t_Result.T_Stmt,T_SymbolLattice] with CollectionEvaluation[t_Result.T_Stmt,T_SymbolLattice] {
    override def combine(v1 : T_SymbolLattice, v2 : T_SymbolLattice) = t_SymbolLattice.v_combine(v1,v2);
    def lattice() : C_LATTICE[T_SymbolLattice] = t_SymbolLattice;

  }
  private object a1_temp extends Attribute[t_Result.T_Stmt,T_SymbolLattice](t_Result.t_Stmt,t_SymbolLattice,"temp") {
    override def createEvaluation(anchor : t_Result.T_Stmt) : Evaluation[t_Result.T_Stmt,T_SymbolLattice] = new E1_temp(anchor);
  }
  private class E2_s_obj(anchor : t_Result.T_Stmt) extends Evaluation[t_Result.T_Stmt,T_S](anchor,anchor.toString()+"."+"s_obj") {
  }
  private object a2_s_obj extends Attribute[t_Result.T_Stmt,T_S](t_Result.t_Stmt,t_S,"s_obj") {
    override def createEvaluation(anchor : t_Result.T_Stmt) : Evaluation[t_Result.T_Stmt,T_S] = new E2_s_obj(anchor);
  }
  val v_contains_epsilon = f_contains_epsilon _;
  def f_contains_epsilon(v_s_set : T_Symbols):T_Boolean = {
    try {
      Debug.begin("contains_epsilon("+v_s_set+")");
      var  v1_result : T_Boolean = null.asInstanceOf[T_Boolean];
      // contains_epsilon.G[contains_epsilon]'shared_info is ready now.
      // contains_epsilon.s_set is ready now.
      v1_result = t_Symbols.v_member(v_epsilon,v_s_set);
      return v1_result;
    } finally { Debug.end(); }
  }

  val v_black_dot = f_black_dot _;
  def f_black_dot(v_s1 : T_Symbols, v_s2 : T_Symbols):T_Symbols = {
    try {
      Debug.begin("black_dot("+v_s1+","+v_s2+")");
      var  v2_result : T_Symbols = null.asInstanceOf[T_Symbols];
      if (v_contains_epsilon(v_s1)) {
        // black_dot.G[black_dot]'shared_info is ready now.
        // black_dot.s2 is ready now.
        // black_dot.s1 is ready now.
        v2_result = new M__basic_19[ T_Symbol,T_Symbols](t_Symbol,t_Symbols).v__op_5w(new M__basic_19[ T_Symbol,T_Symbols](t_Symbol,t_Symbols).v__op_w5D(v_s1,t_Symbols.v_single(v_epsilon)),v_s2);
        // place holder for contains_epsilon(...):99.G[contains_epsilon]'shared_info
        // place holder for contains_epsilon(...):99.s_set
        // contains_epsilon(...):99.result is ready now.
      } else {
        // black_dot.G[black_dot]'shared_info is ready now.
        // black_dot.s2 is ready now.
        // black_dot.s1 is ready now.
        v2_result = v_s1;
        // place holder for contains_epsilon(...):99.G[contains_epsilon]'shared_info
        // place holder for contains_epsilon(...):99.s_set
        // contains_epsilon(...):99.result is ready now.
      }
      return v2_result;
    } finally { Debug.end(); }
  }

  def visit_0_1(node : T_Program) : Unit = node match {
    case p_program(_,_) => visit_0_1_0(node);
  };
  def visit_0_2(node : T_Program) : Unit = node match {
    case p_program(_,_) => visit_0_2_0(node);
  };
  def visit_0_3(node : T_Program) : Unit = node match {
    case p_program(_,_) => visit_0_3_0(node);
  };
  def visit_0_1_0(anchor : T_Program) : Unit = anchor match {
    case p_program(v_self,v_stmts) => {
      // self.G[Program]'shared_info is ready now.
      // self.G[Program]'shared_info$epsilon is ready now.
      // shared info for stmts is ready.
      // stmts.G[Stmts]'shared_info$epsilon
      visit_4_1(v_stmts);
      // stmts.G[Stmts]'shared_info$XdeclarationTable is ready now.
      // self.G[Program]'shared_info$XdeclarationTable
    }
  }

  def visit_0_2_0(anchor : T_Program) : Unit = anchor match {
    case p_program(v_self,v_stmts) => {
      // self.G[Program]'shared_info$declarationTable is ready now.
      a_program_first.assign(v_self,v_declarationTable);
      // stmts.G[Stmts]'shared_info$declarationTable
      visit_4_2(v_stmts);
      // stmts.UP[Stmts]-0 is ready now.
      // self.UP[Program]-0 implicit.
    }
  }

  def visit_0_3_0(anchor : T_Program) : Unit = anchor match {
    case p_program(v_self,v_stmts) => {
      // self.DOWN[Program]-0 is ready now.
      // stmts.DOWN[Stmts]-0 implicit.
    }
  }


  def visit_1_1(node : T_Item) : Unit = node match {
    case p_terminal(_,_) => visit_1_1_0(node);
    case p_nonterminal(_,_) => visit_1_1_1(node);
  };
  def visit_1_1_0(anchor : T_Item) : Unit = anchor match {
    case p_terminal(v_self,v_s) => {
      // self.G[Item]'shared_info is ready now.
      a_item_symbol.assign(v_self,v_s);
      a_item_is_terminal.assign(v_self,v_true);
    }
  }

  def visit_1_1_1(anchor : T_Item) : Unit = anchor match {
    case p_nonterminal(v_self,v_s) => {
      // self.G[Item]'shared_info is ready now.
      a_item_symbol.assign(v_self,v_s);
      a_item_is_terminal.assign(v_self,v_false);
    }
  }


  def visit_2_1(node : T_Items) : Unit = node match {
    case t_Items.p_none(_) => visit_2_1_2(node);
    case t_Items.p_single(_,_) => visit_2_1_1(node);
    case t_Items.p_append(_,_,_) => visit_2_1_0(node);
  };
  def visit_2_2(node : T_Items) : Unit = node match {
    case t_Items.p_none(_) => visit_2_2_2(node);
    case t_Items.p_single(_,_) => visit_2_2_1(node);
    case t_Items.p_append(_,_,_) => visit_2_2_0(node);
  };
  def visit_2_1_2(anchor : T_Items) : Unit = anchor match {
    case t_Items.p_none(v_self) => {
      // self.G[Items]'shared_info is ready now.
      // self.G[Items]'shared_info$declarationTable is ready now.
      // self.G[Items]'shared_info$epsilon is ready now.
      // self.UP[Items]-0 implicit.
    }
  }

  def visit_2_2_2(anchor : T_Items) : Unit = anchor match {
    case t_Items.p_none(v_self) => {
      // self.DOWN[Items]-0 is ready now.
    }
  }

  def visit_2_1_1(anchor : T_Items) : Unit = anchor match {
    case t_Items.p_single(v_self,v_item) => {
      // self.G[Items]'shared_info is ready now.
      // self.G[Items]'shared_info$declarationTable is ready now.
      // self.G[Items]'shared_info$epsilon is ready now.
      // shared info for item is ready.
      visit_1_1(v_item);
      // item.item_symbol is ready now.
      // item.item_is_terminal is ready now.
      if (a_item_is_terminal.get(v_item)) {
        // _ is ready now
        // item_first_objs is ready now
        // first is ready now
        // self.UP[Items]-0 implicit.
      } else {
        val node = t_DeclarationTable.v_select(v_declarationTable,a_item_symbol.get(v_item));
        node match {
        case t_DeclarationTable.p_table_entry(_,v_0,v_item_first_objs) => {
          // _ is ready now
          // item_first_objs is ready now
          val node = v_item_first_objs;
          node match {
          case t_RemoteSSet.p__op_AC(_,v_first,_*) => {
            // first is ready now
            // self.UP[Items]-0 implicit.
          }
          case _ => {
            // first is ready now
            // self.UP[Items]-0 implicit.
          }}
        }
        case _ => {
          // _ is ready now
          // item_first_objs is ready now
          // first is ready now
          // self.UP[Items]-0 implicit.
        }}
      }
    }
  }

  def visit_2_2_1(anchor : T_Items) : Unit = anchor match {
    case t_Items.p_single(v_self,v_item) => {
      if (a_item_is_terminal.get(v_item)) {
        // self.DOWN[Items]-0 is ready now.
      } else {
        val node = t_DeclarationTable.v_select(v_declarationTable,a_item_symbol.get(v_item));
        node match {
        case t_DeclarationTable.p_table_entry(_,v_0,v_item_first_objs) => {
          val node = v_item_first_objs;
          node match {
          case t_RemoteSSet.p__op_AC(_,v_first,_*) => {
            // self.DOWN[Items]-0 is ready now.
          }
          case _ => {
            // self.DOWN[Items]-0 is ready now.
          }}
        }
        case _ => {
          // self.DOWN[Items]-0 is ready now.
        }}
      }
    }
  }

  def visit_2_1_0(anchor : T_Items) : Unit = anchor match {
    case t_Items.p_append(v_self,v_items1,v_items2) => {
      // self.G[Items]'shared_info is ready now.
      // self.G[Items]'shared_info$declarationTable is ready now.
      // self.G[Items]'shared_info$epsilon is ready now.
      // shared info for items1 is ready.
      // items1.G[Items]'shared_info$declarationTable
      // items1.G[Items]'shared_info$epsilon
      visit_2_1(v_items1);
      // items1.UP[Items]-0 is ready now.
      // shared info for items2 is ready.
      // items2.G[Items]'shared_info$declarationTable
      // items2.G[Items]'shared_info$epsilon
      visit_2_1(v_items2);
      // items2.UP[Items]-0 is ready now.
      // self.UP[Items]-0 implicit.
    }
  }

  def visit_2_2_0(anchor : T_Items) : Unit = anchor match {
    case t_Items.p_append(v_self,v_items1,v_items2) => {
      // self.DOWN[Items]-0 is ready now.
      // items1.DOWN[Items]-0 implicit.
      // items2.DOWN[Items]-0 implicit.
      // place holder for black_dot(...):79.G[black_dot]'shared_info
      // place holder for black_dot(...):79.s2
      // place holder for black_dot(...):79.s1
      // black_dot(...):79.result is ready now.
    }
  }


  def visit_3_1(node : T_Stmt) : Unit = node match {
    case p_stmt(_,_,_) => visit_3_1_0(node);
  };
  def visit_3_2(node : T_Stmt) : Unit = node match {
    case p_stmt(_,_,_) => visit_3_2_0(node);
  };
  def visit_3_3(node : T_Stmt) : Unit = node match {
    case p_stmt(_,_,_) => visit_3_3_0(node);
  };
  def visit_3_1_0(anchor : T_Stmt) : Unit = anchor match {
    case p_stmt(v_self,v_nt,v_items) => {
      // self.G[Stmt]'shared_info is ready now.
      // self.G[Stmt]'shared_info$epsilon is ready now.
      // shared info for items is ready.
      // items.G[Items]'shared_info$epsilon
      a2_s_obj.assign(anchor,v_s_constructor());
      a_declarationTable.assign(t_DeclarationTable.v_table_entry(v_nt,t_RemoteSSet.v_single(a2_s_obj.get(anchor))));
    }
  }

  def visit_3_2_0(anchor : T_Stmt) : Unit = anchor match {
    case p_stmt(v_self,v_nt,v_items) => {
      // self.G[Stmt]'shared_info$declarationTable is ready now.
      // items.G[Items]'shared_info$declarationTable
      visit_2_1(v_items);
      // items.UP[Items]-0 is ready now.
      // self.UP[Stmt]-0 implicit.
    }
  }

  def visit_3_3_0(anchor : T_Stmt) : Unit = anchor match {
    case p_stmt(v_self,v_nt,v_items) => {
      // self.DOWN[Stmt]-0 is ready now.
      // items.DOWN[Items]-0 implicit.
    }
  }


  def visit_4_1(node : T_Stmts) : Unit = node match {
    case t_Stmts.p_none(_) => visit_4_1_2(node);
    case t_Stmts.p_single(_,_) => visit_4_1_1(node);
    case t_Stmts.p_append(_,_,_) => visit_4_1_0(node);
  };
  def visit_4_2(node : T_Stmts) : Unit = node match {
    case t_Stmts.p_none(_) => visit_4_2_2(node);
    case t_Stmts.p_single(_,_) => visit_4_2_1(node);
    case t_Stmts.p_append(_,_,_) => visit_4_2_0(node);
  };
  def visit_4_3(node : T_Stmts) : Unit = node match {
    case t_Stmts.p_none(_) => visit_4_3_2(node);
    case t_Stmts.p_single(_,_) => visit_4_3_1(node);
    case t_Stmts.p_append(_,_,_) => visit_4_3_0(node);
  };
  def visit_4_1_2(anchor : T_Stmts) : Unit = anchor match {
    case t_Stmts.p_none(v_self) => {
      // self.G[Stmts]'shared_info is ready now.
      // self.G[Stmts]'shared_info$epsilon is ready now.
      // self.G[Stmts]'shared_info$XdeclarationTable
    }
  }

  def visit_4_2_2(anchor : T_Stmts) : Unit = anchor match {
    case t_Stmts.p_none(v_self) => {
      // self.G[Stmts]'shared_info$declarationTable is ready now.
      // self.UP[Stmts]-0 implicit.
    }
  }

  def visit_4_3_2(anchor : T_Stmts) : Unit = anchor match {
    case t_Stmts.p_none(v_self) => {
      // self.DOWN[Stmts]-0 is ready now.
    }
  }

  def visit_4_1_1(anchor : T_Stmts) : Unit = anchor match {
    case t_Stmts.p_single(v_self,v_stmt) => {
      // self.G[Stmts]'shared_info is ready now.
      // self.G[Stmts]'shared_info$epsilon is ready now.
      // shared info for stmt is ready.
      // stmt.G[Stmt]'shared_info$epsilon
      visit_3_1(v_stmt);
      // stmt.G[Stmt]'shared_info$XdeclarationTable is ready now.
      // self.G[Stmts]'shared_info$XdeclarationTable
    }
  }

  def visit_4_2_1(anchor : T_Stmts) : Unit = anchor match {
    case t_Stmts.p_single(v_self,v_stmt) => {
      // self.G[Stmts]'shared_info$declarationTable is ready now.
      // stmt.G[Stmt]'shared_info$declarationTable
      visit_3_2(v_stmt);
      // stmt.UP[Stmt]-0 is ready now.
      // self.UP[Stmts]-0 implicit.
    }
  }

  def visit_4_3_1(anchor : T_Stmts) : Unit = anchor match {
    case t_Stmts.p_single(v_self,v_stmt) => {
      // self.DOWN[Stmts]-0 is ready now.
      // stmt.DOWN[Stmt]-0 implicit.
    }
  }

  def visit_4_1_0(anchor : T_Stmts) : Unit = anchor match {
    case t_Stmts.p_append(v_self,v_stmts1,v_stmts2) => {
      // self.G[Stmts]'shared_info is ready now.
      // self.G[Stmts]'shared_info$epsilon is ready now.
      // shared info for stmts1 is ready.
      // stmts1.G[Stmts]'shared_info$epsilon
      visit_4_1(v_stmts1);
      // stmts1.G[Stmts]'shared_info$XdeclarationTable is ready now.
      // shared info for stmts2 is ready.
      // stmts2.G[Stmts]'shared_info$epsilon
      visit_4_1(v_stmts2);
      // stmts2.G[Stmts]'shared_info$XdeclarationTable is ready now.
      // self.G[Stmts]'shared_info$XdeclarationTable
    }
  }

  def visit_4_2_0(anchor : T_Stmts) : Unit = anchor match {
    case t_Stmts.p_append(v_self,v_stmts1,v_stmts2) => {
      // self.G[Stmts]'shared_info$declarationTable is ready now.
      // stmts1.G[Stmts]'shared_info$declarationTable
      visit_4_2(v_stmts1);
      // stmts1.UP[Stmts]-0 is ready now.
      // stmts2.G[Stmts]'shared_info$declarationTable
      visit_4_2(v_stmts2);
      // stmts2.UP[Stmts]-0 is ready now.
      // self.UP[Stmts]-0 implicit.
    }
  }

  def visit_4_3_0(anchor : T_Stmts) : Unit = anchor match {
    case t_Stmts.p_append(v_self,v_stmts1,v_stmts2) => {
      // self.DOWN[Stmts]-0 is ready now.
      // stmts1.DOWN[Stmts]-0 implicit.
      // stmts2.DOWN[Stmts]-0 implicit.
    }
  }


  def visit() : Unit = {
    val roots = t_Program.nodes;
    // shared info for FIRST_IMPL is ready.
    // v_epsilon is initialized in module.
    // FIRST_IMPL.G[Program]'shared_info$epsilon
    for (root <- roots) {
      visit_0_1(root);
    }
    // FIRST_IMPL.G[Program]'shared_info$XdeclarationTable is ready now.
    // declarationTable is ready now
    // FIRST_IMPL.G[Program]'shared_info$declarationTable
    for (root <- roots) {
      visit_0_2(root);
    }
    // FIRST_IMPL.UP[Program]-0 is ready now.
    // FIRST_IMPL.program_first is ready now.
    // UP[global dependencies]-0 is ready now
    // FIRST_IMPL.DOWN[Program]-0 implicit.
  }

  override def finish() : Unit = {
    visit();
    t_S.finish();
    t_Symbols.finish();
    t_SymbolTable.finish();
    t_SymbolLattice.finish();
    t_RemoteSSet.finish();
    t_DeclarationTable.finish();
super.finish();
  }

}

