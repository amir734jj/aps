// Generated by aps2scala version 0.3.6
import basic_implicit._;
object tiny_circular_implicit {
  val tiny_circular_loaded = true;
import basic_implicit._;
import tiny_implicit._;
type T_TINY_CIRCULAR[T_T] = T_T;
}
import tiny_circular_implicit._;

import basic_implicit._;
import tiny_implicit._;
trait C_TINY_CIRCULAR[T_Result, T_T] extends C_TYPE[T_Result] with C_TINY[T_Result] {
  type T_S <: Node;
  val t_S : C_PHYLUM[T_S];
  type T_RemoteS;
  val t_RemoteS : C_TYPE[T_RemoteS];
  type T_Integers;
  val t_Integers : C_TYPE[T_Integers]with C_SET[T_Integers,T_Integer];
  type T_IntegerLattice;
  val t_IntegerLattice : C_TYPE[T_IntegerLattice]with C_UNION_LATTICE[T_IntegerLattice,T_Integer,T_Integers];
  val v_s_bag1 : (T_S) => T_IntegerLattice;
  val v_s_bag2 : (T_S) => T_IntegerLattice;
  val v_result : (T_Root) => T_Integers;
  val v_w_s : (T_Wood) => T_RemoteS;
  val p_s_constructor : PatternFunction[(T_S)];
  def v_s_constructor : () => T_S;
}

class M_TINY_CIRCULAR[T_T](name : String,val t_T : C_TYPE[T_T] with C_TINY[T_T])
  extends Module(name)
  with C_TINY_CIRCULAR[T_T,T_T]
{
  type T_Result = T_T;
  val v_equal = t_T.v_equal;
  val v_string = t_T.v_string;
  val v_assert = t_T.v_assert;
  val v_node_equivalent = t_T.v_node_equivalent;
  type T_Root = t_T.T_Root;
  val t_Root = t_T.t_Root;
  type T_Wood = t_T.T_Wood;
  val t_Wood = t_T.t_Wood;
  val p_root = t_T.p_root;
  val v_root = t_T.v_root;
  val p_branch = t_T.p_branch;
  val v_branch = t_T.v_branch;
  val p_leaf = t_T.p_leaf;
  val v_leaf = t_T.v_leaf;

  val t_Result : this.type = this;
  abstract class T_S(t : I_PHYLUM[T_S]) extends Node(t) {}
  val t_S = new I_PHYLUM[T_S]("S");

  type T_RemoteS = T_S;
  val t_RemoteS = t_S;
  val t_Integers = new M_SET[T_Integer]("Integers",t_Integer);
  type T_Integers = /*TI*/T_SET[T_Integer];
  val t_IntegerLattice = new M_UNION_LATTICE[T_Integer,T_Integers]("IntegerLattice",t_Integer,t_Integers);
  type T_IntegerLattice = /*TI*/T_UNION_LATTICE[T_Integer,T_Integers];
  private class E_s_bag1(anchor : T_S) extends Evaluation[T_S,T_IntegerLattice](anchor,anchor.toString()+"."+"s_bag1") with CircularEvaluation[T_S,T_IntegerLattice] with CollectionEvaluation[T_S,T_IntegerLattice] {
    override def getDefault = t_IntegerLattice.v_none();
    override def combine(v1 : T_IntegerLattice, v2 : T_IntegerLattice) = t_IntegerLattice.v_combine(v1,v2);
    def lattice() : C_LATTICE[T_IntegerLattice] = t_IntegerLattice;

    override def compute : ValueType = c_s_bag1(anchor);
  }
  private object a_s_bag1 extends Attribute[T_S,T_IntegerLattice](t_S,t_IntegerLattice,"s_bag1") {
    override def createEvaluation(anchor : T_S) : Evaluation[T_S,T_IntegerLattice] = new E_s_bag1(anchor);
  }
  val v_s_bag1 : T_S => T_IntegerLattice = a_s_bag1.get _;

  private class E_s_bag2(anchor : T_S) extends Evaluation[T_S,T_IntegerLattice](anchor,anchor.toString()+"."+"s_bag2") with CircularEvaluation[T_S,T_IntegerLattice] with CollectionEvaluation[T_S,T_IntegerLattice] {
    override def getDefault = t_IntegerLattice.v_none();
    override def combine(v1 : T_IntegerLattice, v2 : T_IntegerLattice) = t_IntegerLattice.v_combine(v1,v2);
    def lattice() : C_LATTICE[T_IntegerLattice] = t_IntegerLattice;

    override def compute : ValueType = c_s_bag2(anchor);
  }
  private object a_s_bag2 extends Attribute[T_S,T_IntegerLattice](t_S,t_IntegerLattice,"s_bag2") {
    override def createEvaluation(anchor : T_S) : Evaluation[T_S,T_IntegerLattice] = new E_s_bag2(anchor);
  }
  val v_s_bag2 : T_S => T_IntegerLattice = a_s_bag2.get _;

  private class E_result(anchor : T_Root) extends Evaluation[T_Root,T_Integers](anchor,anchor.toString()+"."+"result") {
    override def compute : ValueType = c_result(anchor);
  }
  private object a_result extends Attribute[T_Root,T_Integers](t_Root,t_Integers,"result") {
    override def createEvaluation(anchor : T_Root) : Evaluation[T_Root,T_Integers] = new E_result(anchor);
  }
  val v_result : T_Root => T_Integers = a_result.get _;

  private class E_w_s(anchor : T_Wood) extends Evaluation[T_Wood,T_RemoteS](anchor,anchor.toString()+"."+"w_s") {
    override def compute : ValueType = c_w_s(anchor);
  }
  private object a_w_s extends Attribute[T_Wood,T_RemoteS](t_Wood,t_RemoteS,"w_s") {
    override def createEvaluation(anchor : T_Wood) : Evaluation[T_Wood,T_RemoteS] = new E_w_s(anchor);
  }
  val v_w_s : T_Wood => T_RemoteS = a_w_s.get _;

  case class c_s_constructor() extends T_S(t_S) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "s_constructor("+ ")";
    }
  }
  def u_s_constructor(x:Any) : Option[(T_S)] = x match {
    case x@c_s_constructor() => Some(x);
    case _ => None };
  val v_s_constructor = f_s_constructor _;
  def f_s_constructor():T_S = c_s_constructor().register;
  val p_s_constructor = new PatternFunction[(T_S)](u_s_constructor);

  private class E1_t(anchor : t_Result.T_Wood) extends Evaluation[t_Result.T_Wood,T_S](anchor,anchor.toString()+"."+"t") {
    override def compute : ValueType = c1_t(anchor);
  }
  private object a1_t extends Attribute[t_Result.T_Wood,T_S](t_Result.t_Wood,t_S,"t") {
    override def createEvaluation(anchor : t_Result.T_Wood) : Evaluation[t_Result.T_Wood,T_S] = new E1_t(anchor);
  }
  private class E2_v(anchor : t_Result.T_Wood) extends Evaluation[t_Result.T_Wood,T_S](anchor,anchor.toString()+"."+"v") {
    override def compute : ValueType = c2_v(anchor);
  }
  private object a2_v extends Attribute[t_Result.T_Wood,T_S](t_Result.t_Wood,t_S,"v") {
    override def createEvaluation(anchor : t_Result.T_Wood) : Evaluation[t_Result.T_Wood,T_S] = new E2_v(anchor);
  }
  private class E3_i(anchor : t_Result.T_Wood) extends Evaluation[t_Result.T_Wood,T_IntegerLattice](anchor,anchor.toString()+"."+"i") with CircularEvaluation[t_Result.T_Wood,T_IntegerLattice] {
    def lattice() : C_LATTICE[T_IntegerLattice] = t_IntegerLattice;

    override def compute : ValueType = c3_i(anchor);
  }
  private object a3_i extends Attribute[t_Result.T_Wood,T_IntegerLattice](t_Result.t_Wood,t_IntegerLattice,"i") {
    override def createEvaluation(anchor : t_Result.T_Wood) : Evaluation[t_Result.T_Wood,T_IntegerLattice] = new E3_i(anchor);
  }
  private class E4_i(anchor : t_Result.T_Root) extends Evaluation[t_Result.T_Root,T_IntegerLattice](anchor,anchor.toString()+"."+"i") with CircularEvaluation[t_Result.T_Root,T_IntegerLattice] {
    def lattice() : C_LATTICE[T_IntegerLattice] = t_IntegerLattice;

    override def compute : ValueType = c4_i(anchor);
  }
  private object a4_i extends Attribute[t_Result.T_Root,T_IntegerLattice](t_Result.t_Root,t_IntegerLattice,"i") {
    override def createEvaluation(anchor : t_Result.T_Root) : Evaluation[t_Result.T_Root,T_IntegerLattice] = new E4_i(anchor);
  }
  def c1_t(anchor : Any) : T_S = {
    anchor match {
      case p_leaf(v_l,v_x) => {
        return v_s_constructor();
      }
    }
  }
  def c2_v(anchor : Any) : T_S = {
    anchor match {
      case p_branch(v_b,v_x,v_y) => {
        return v_s_constructor();
      }
    }
  }
  def c3_i(anchor : Any) : T_IntegerLattice = {
    anchor match {
      case p_branch(v_b,v_x,v_y) => {
        return v_s_bag2(a2_v.get(anchor));
      }
    }
  }
  def c4_i(anchor : Any) : T_IntegerLattice = {
    anchor match {
      case p_root(v_p,v_b) => {
        return v_s_bag1(v_w_s(v_b));
      }
    }
  }
  def c_s_bag1(anode : T_S) : T_IntegerLattice = {
    var collection : T_IntegerLattice = t_IntegerLattice.v_none();
    for (anchor <- t_Result.t_Wood.nodes) anchor match {
      case p_leaf(v_l,v_x) => {
        if (anode eq a1_t.get(anchor)) collection = t_IntegerLattice.v_combine(collection,t_IntegerLattice.v_single(v_x));
      }
      case _ => {}
    }
    for (anchor <- t_Result.t_Wood.nodes) anchor match {
      case p_branch(v_b,v_x,v_y) => {
        if (anode eq a2_v.get(anchor)) collection = t_IntegerLattice.v_combine(collection,a3_i.get(anchor));
      }
      case _ => {}
    }
    return collection;
  }
  def c_s_bag2(anode : T_S) : T_IntegerLattice = {
    var collection : T_IntegerLattice = t_IntegerLattice.v_none();
    for (anchor <- t_Result.t_Root.nodes) anchor match {
      case p_root(v_p,v_b) => {
        if (anode eq v_w_s(v_b)) collection = t_IntegerLattice.v_combine(collection,new M__basic_19[ T_Integer,T_IntegerLattice](t_Integer,t_IntegerLattice).v__op_5w(a4_i.get(anchor),t_IntegerLattice.v_append(t_IntegerLattice.v_append(t_IntegerLattice.v_single(1),t_IntegerLattice.v_single(2)),t_IntegerLattice.v_single(3))));
      }
      case _ => {}
    }
    return collection;
  }
  def c_result(anode : T_Root) : T_Integers = {
    val anchor = anode;
    anchor match {
      case p_root(v_p,v_b) => {
        if (anode eq v_p) return v_s_bag1(v_w_s(v_b));
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".result");
  }
  def c_w_s(anode : T_Wood) : T_RemoteS = {
    val anchor = anode;
    anchor match {
      case p_leaf(v_l,v_x) => {
        if (anode eq v_l) return a1_t.get(anchor);
      }
      case _ => {}
    }
    anchor match {
      case p_branch(v_b,v_x,v_y) => {
        if (anode eq v_b) return a2_v.get(anchor);
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".w_s");
  }
  override def finish() : Unit = {
    a_s_bag1.finish;
    a_s_bag2.finish;
    a_result.finish;
    a_w_s.finish;
    super.finish();
  }

}

