// Generated by aps2scala version 0.3.6
import basic_implicit._;
object use_global_implicit {
  val use_global_loaded = true;
import tiny_implicit._;
type T_USE_GLOBAL[T_T] = T_T;
}
import use_global_implicit._;

import tiny_implicit._;
trait C_USE_GLOBAL[T_Result, T_T] extends C_TYPE[T_Result] with C_TINY[T_Result] {
  def v_max_value : T_Integer;
  val v_result : (T_Wood) => T_Integer;
  val v_done : (T_Root) => T_Integer;
}

class M_USE_GLOBAL[T_T](name : String,val t_T : C_TYPE[T_T] with C_TINY[T_T])
  extends Module(name)
  with C_USE_GLOBAL[T_T,T_T]
{
  type T_Result = T_T;
  val v_equal = t_T.v_equal;
  val v_string = t_T.v_string;
  val v_assert = t_T.v_assert;
  val v_node_equivalent = t_T.v_node_equivalent;
  type T_Root = t_T.T_Root;
  val t_Root = t_T.t_Root;
  type T_Wood = t_T.T_Wood;
  val t_Wood = t_T.t_Wood;
  val p_root = t_T.p_root;
  val v_root = t_T.v_root;
  val p_branch = t_T.p_branch;
  val v_branch = t_T.v_branch;
  val p_leaf = t_T.p_leaf;
  val v_leaf = t_T.v_leaf;

  val t_Result : this.type = this;
  private class E_max_value(anchor : Null) extends Evaluation[Null,T_Integer](anchor,"max_value") with CollectionEvaluation[Null,T_Integer] {
    override def initial : T_Integer = 0;
    override def combine(v1 : T_Integer, v2 : T_Integer) = new M__basic_13[ T_Integer](t_Integer).v_max(v1,v2);
    override def compute : ValueType = c_max_value();
  }
  private object a_max_value extends E_max_value(null) {}
  def v_max_value:T_Integer = a_max_value.get;

  private class E_result(anchor : T_Wood) extends Evaluation[T_Wood,T_Integer](anchor,anchor.toString()+"."+"result") {
    override def getDefault = 0;
    override def compute : ValueType = c_result(anchor);
  }
  private object a_result extends Attribute[T_Wood,T_Integer](t_Wood,t_Integer,"result") {
    override def createEvaluation(anchor : T_Wood) : Evaluation[T_Wood,T_Integer] = new E_result(anchor);
  }
  val v_result : T_Wood => T_Integer = a_result.get _;

  private class E_done(anchor : T_Root) extends Evaluation[T_Root,T_Integer](anchor,anchor.toString()+"."+"done") {
    override def compute : ValueType = c_done(anchor);
  }
  private object a_done extends Attribute[T_Root,T_Integer](t_Root,t_Integer,"done") {
    override def createEvaluation(anchor : T_Root) : Evaluation[T_Root,T_Integer] = new E_done(anchor);
  }
  val v_done : T_Root => T_Integer = a_done.get _;

  def c_result(anode : T_Wood) : T_Integer = {
    val anchor = anode;
    anchor match {
      case p_branch(v_b,v_w1,v_w2) => {
        if (anode eq v_b) return new M__basic_4[ T_Integer](t_Integer).v__op_s(v_result(v_w1),v_result(v_w2));
      }
      case _ => {}
    }
    anchor match {
      case p_leaf(v_l,v_v) => {
        if (anode eq v_l) return v_max_value;
      }
      case _ => {}
    }
    return 0;
  }
  def c_done(anode : T_Root) : T_Integer = {
    val anchor = anode;
    anchor match {
      case p_root(v_r,v_w) => {
        if (anode eq v_r) return v_result(v_w);
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".done");
  }
  def c_max_value() : T_Integer = {
    Debug.begin("max_value");
    try {
      var collection : T_Integer = 0;
      for (anchor <- t_Result.t_Wood.nodes) anchor match {
        case p_leaf(v_l,v_v) => {
          collection = new M__basic_13[ T_Integer](t_Integer).v_max(collection,v_v);
        }
        case _ => {}
      }
      Debug.returns(collection.toString());
      return collection;
    } finally { Debug.end(); }
  }
  override def finish() : Unit = {
    a_max_value.get;
    a_result.finish;
    a_done.finish;
    super.finish();
  }

}

