// Generated by aps2scala version 0.3.6
import basic_implicit._;
object test_use_coll_implicit {
  val test_use_coll_loaded = true;
import tiny_implicit._;
type T_TEST_USE_COLL[T_T] = T_T;
}
import test_use_coll_implicit._;

import tiny_implicit._;
trait C_TEST_USE_COLL[T_Result, T_T] extends C_TYPE[T_Result] with C_TINY[T_Result] {
  type T_Integers;
  val t_Integers : C_TYPE[T_Integers]with C_SET[T_Integers,T_Integer];
  def v_sum : T_Integer;
  def v_leaves : T_Integers;
  val v_sumsum : (T_Wood) => T_Integer;
  val v_result : (T_Root) => T_Integer;
  val v_result2 : (T_Root) => T_Integers;
  val v_f1 : () => T_Integer;
  val v_f2 : () => T_Integer;
}

class M_TEST_USE_COLL[T_T](name : String,val t_T : C_TYPE[T_T] with C_TINY[T_T])
  extends Module(name)
  with C_TEST_USE_COLL[T_T,T_T]
{
  type T_Result = T_T;
  val v_equal = t_T.v_equal;
  val v_string = t_T.v_string;
  val v_assert = t_T.v_assert;
  val v_node_equivalent = t_T.v_node_equivalent;
  type T_Root = t_T.T_Root;
  val t_Root = t_T.t_Root;
  type T_Wood = t_T.T_Wood;
  val t_Wood = t_T.t_Wood;
  val p_root = t_T.p_root;
  val v_root = t_T.v_root;
  val p_branch = t_T.p_branch;
  val v_branch = t_T.v_branch;
  val p_leaf = t_T.p_leaf;
  val v_leaf = t_T.v_leaf;

  val t_Result : this.type = this;
  val t_Integers = new M_SET[T_Integer]("Integers",t_Integer);
  type T_Integers = /*TI*/T_SET[T_Integer];
  private class E_sum(anchor : Null) extends Evaluation[Null,T_Integer](anchor,"sum") with CollectionEvaluation[Null,T_Integer] {
    override def initial : T_Integer = 0;
    override def combine(v1 : T_Integer, v2 : T_Integer) = new M__basic_4[ T_Integer](t_Integer).v__op_s(v1,v2);
    override def compute : ValueType = c_sum();
  }
  private object a_sum extends E_sum(null) {}
  def v_sum:T_Integer = a_sum.get;

  private class E_leaves(anchor : Null) extends Evaluation[Null,T_Integers](anchor,"leaves") with CollectionEvaluation[Null,T_Integers] {
    override def initial : T_Integers = t_Integers.v_initial;
    override def combine(v1 : T_Integers, v2 : T_Integers) = t_Integers.v_combine(v1,v2);
    override def compute : ValueType = c_leaves();
  }
  private object a_leaves extends E_leaves(null) {}
  def v_leaves:T_Integers = a_leaves.get;

  private class E_sumsum(anchor : T_Wood) extends Evaluation[T_Wood,T_Integer](anchor,anchor.toString()+"."+"sumsum") {
    override def compute : ValueType = c_sumsum(anchor);
  }
  private object a_sumsum extends Attribute[T_Wood,T_Integer](t_Wood,t_Integer,"sumsum") {
    override def createEvaluation(anchor : T_Wood) : Evaluation[T_Wood,T_Integer] = new E_sumsum(anchor);
  }
  val v_sumsum : T_Wood => T_Integer = a_sumsum.get _;

  private class E_result(anchor : T_Root) extends Evaluation[T_Root,T_Integer](anchor,anchor.toString()+"."+"result") {
    override def compute : ValueType = c_result(anchor);
  }
  private object a_result extends Attribute[T_Root,T_Integer](t_Root,t_Integer,"result") {
    override def createEvaluation(anchor : T_Root) : Evaluation[T_Root,T_Integer] = new E_result(anchor);
  }
  val v_result : T_Root => T_Integer = a_result.get _;

  private class E_result2(anchor : T_Root) extends Evaluation[T_Root,T_Integers](anchor,anchor.toString()+"."+"result2") {
    override def getDefault = v_leaves;
    override def compute : ValueType = c_result2(anchor);
  }
  private object a_result2 extends Attribute[T_Root,T_Integers](t_Root,t_Integers,"result2") {
    override def createEvaluation(anchor : T_Root) : Evaluation[T_Root,T_Integers] = new E_result2(anchor);
  }
  val v_result2 : T_Root => T_Integers = a_result2.get _;

  val v_f1 = f_f1 _;
  def f_f1():T_Integer = {
    try {
      Debug.begin("f1("+")");
      return v_sum;
    } finally { Debug.end(); }
  };
  val v_f2 = f_f2 _;
  def f_f2():T_Integer = {
    try {
      Debug.begin("f2("+")");
      return v_f1();
    } finally { Debug.end(); }
  };
  def c_sumsum(anode : T_Wood) : T_Integer = {
    val anchor = anode;
    anchor match {
      case p_leaf(v_l,v_x) => {
        if (anode eq v_l) return v_f2();
      }
      case _ => {}
    }
    anchor match {
      case p_branch(v_b,v_x,v_y) => {
        if (anode eq v_b) return new M__basic_4[ T_Integer](t_Integer).v__op_s(v_sumsum(v_x),v_sumsum(v_y));
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".sumsum");
  }
  def c_result(anode : T_Root) : T_Integer = {
    val anchor = anode;
    anchor match {
      case p_root(v_p,v_b) => {
        if (anode eq v_p) return v_sumsum(v_b);
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".result");
  }
  def c_result2(anode : T_Root) : T_Integers = {
    val anchor = anode;
    return v_leaves;
  }
  def c_sum() : T_Integer = {
    Debug.begin("sum");
    try {
      var collection : T_Integer = 0;
      for (anchor <- t_Result.t_Wood.nodes) anchor match {
        case p_leaf(v_l,v_x) => {
          collection = new M__basic_4[ T_Integer](t_Integer).v__op_s(collection,v_x);
        }
        case _ => {}
      }
      Debug.returns(collection.toString());
      return collection;
    } finally { Debug.end(); }
  }
  def c_leaves() : T_Integers = {
    Debug.begin("leaves");
    try {
      var collection : T_Integers = t_Integers.v_initial;
      for (anchor <- t_Result.t_Wood.nodes) anchor match {
        case p_leaf(v_l,v_x) => {
          collection = t_Integers.v_combine(collection,t_Integers.v_single(v_x));
        }
        case _ => {}
      }
      Debug.returns(collection.toString());
      return collection;
    } finally { Debug.end(); }
  }
  override def finish() : Unit = {
    a_sum.get;
    a_leaves.get;
    a_sumsum.finish;
    a_result.finish;
    a_result2.finish;
    super.finish();
  }

}

