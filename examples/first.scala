// Generated by aps2scala version 0.3.6
import basic_implicit._;
object first_implicit {
  val first_loaded = true;
import symbol_implicit._;
import table_implicit._;
import grammar_implicit._;
type T_FIRST[T_T] = T_T;
}
import first_implicit._;

import symbol_implicit._;
import table_implicit._;
import grammar_implicit._;
trait C_FIRST[T_Result, T_T] extends C_TYPE[T_Result] with C_GRAMMAR[T_Result] {
  type T_Symbols;
  val t_Symbols : C_TYPE[T_Symbols]with C_SET[T_Symbols,T_Symbol];
  type T_SymbolLattice;
  val t_SymbolLattice : C_TYPE[T_SymbolLattice]with C_UNION_LATTICE[T_SymbolLattice,T_Symbol,T_Symbols];
  type T_DeclarationTable;
  val t_DeclarationTable : C_TYPE[T_DeclarationTable]with C_TABLE_LATTICE[T_DeclarationTable,T_Symbol,T_SymbolLattice];
  def v_firstTable : T_DeclarationTable;
  val v_item_first : (T_Item) => T_SymbolLattice;
  val v_items_first : (T_Items) => T_SymbolLattice;
  val v_grammar_first : (T_Grammar) => T_DeclarationTable;
  def v_epsilon : T_Symbol;
  val v_contains_epsilon : (T_Symbols) => T_Boolean;
  val v_black_dot : (T_Symbols,T_Symbols) => T_Symbols;
}

class M_FIRST[T_T](name : String,val t_T : C_TYPE[T_T] with C_GRAMMAR[T_T])
  extends Module(name)
  with C_FIRST[T_T,T_T]
{
  type T_Result = T_T;
  val v_equal = t_T.v_equal;
  val v_string = t_T.v_string;
  val v_assert = t_T.v_assert;
  val v_node_equivalent = t_T.v_node_equivalent;
  type T_Grammar = t_T.T_Grammar;
  val t_Grammar = t_T.t_Grammar;
  type T_Item = t_T.T_Item;
  val t_Item = t_T.t_Item;
  type T_Items = t_T.T_Items;
  val t_Items = t_T.t_Items;
  type T_Production = t_T.T_Production;
  val t_Production = t_T.t_Production;
  type T_Productions = t_T.T_Productions;
  val t_Productions = t_T.t_Productions;
  val p_terminal = t_T.p_terminal;
  val v_terminal = t_T.v_terminal;
  val p_nonterminal = t_T.p_nonterminal;
  val v_nonterminal = t_T.v_nonterminal;
  val p_prod = t_T.p_prod;
  val v_prod = t_T.v_prod;
  val p_grammar = t_T.p_grammar;
  val v_grammar = t_T.v_grammar;

  val t_Result : this.type = this;
  val t_Symbols = new M_SET[T_Symbol]("Symbols",t_Symbol)

  type T_Symbols = /*TI*/T_SET[T_Symbol];
  val t_SymbolLattice = new M_UNION_LATTICE[T_Symbol,T_Symbols]("SymbolLattice",t_Symbol,t_Symbols)
    /* dumping traits */
    with C_TYPE[T_Symbols]
    with C_SET[T_Symbols, T_Symbol] {
      override val v_assert = t_Symbols.v_assert;
      override val v_equal = t_Symbols.v_equal;
      override val v_node_equivalent = t_Symbols.v_node_equivalent;
      override val v_string = t_Symbols.v_string;
      override val v_less = t_Symbols.v_less;
      override val v_less_equal = t_Symbols.v_less_equal;
      override val v_none = t_Symbols.v_none;
      override val v_single = t_Symbols.v_single;
      override val v_append = t_Symbols.v_append;
      override val v__op_AC = t_Symbols.v__op_AC;
      override val p__op_AC = t_Symbols.p__op_AC;
      override val v_member = t_Symbols.v_member;
      override val v_union = t_Symbols.v_union;
      override val v_intersect = t_Symbols.v_intersect;
      override val v_difference = t_Symbols.v_difference;
      override val v_combine = t_Symbols.v_combine;
    }

  type T_SymbolLattice = /*TI*/T_UNION_LATTICE[T_Symbol,T_Symbols];
  val t_DeclarationTable = new M_TABLE_LATTICE[T_Symbol,T_SymbolLattice]("DeclarationTable",t_Symbol,t_SymbolLattice)

  type T_DeclarationTable = /*TI*/T_TABLE_LATTICE[T_Symbol,T_SymbolLattice];
  private class E_firstTable(anchor : Null) extends Evaluation[Null,T_DeclarationTable](anchor,"firstTable") with CircularEvaluation[Null,T_DeclarationTable] with CollectionEvaluation[Null,T_DeclarationTable] {
    override def initial : T_DeclarationTable = t_DeclarationTable.v_initial;
    override def combine(v1 : T_DeclarationTable, v2 : T_DeclarationTable) = t_DeclarationTable.v_combine(v1,v2);
    def lattice() : C_LATTICE[T_DeclarationTable] = t_DeclarationTable;

    override def compute : ValueType = c_firstTable();
  }
  private object a_firstTable extends E_firstTable(null) {}
  def v_firstTable:T_DeclarationTable = a_firstTable.get;

  private class E_item_first(anchor : T_Item) extends Evaluation[T_Item,T_SymbolLattice](anchor,anchor.toString()+"."+"item_first") with CircularEvaluation[T_Item,T_SymbolLattice] {
    def lattice() : C_LATTICE[T_SymbolLattice] = t_SymbolLattice;

    override def compute : ValueType = c_item_first(anchor);
  }
  private object a_item_first extends Attribute[T_Item,T_SymbolLattice](t_Item,t_SymbolLattice,"item_first") {
    override def createEvaluation(anchor : T_Item) : Evaluation[T_Item,T_SymbolLattice] = new E_item_first(anchor);
  }
  val v_item_first : T_Item => T_SymbolLattice = a_item_first.get _;

  private class E_items_first(anchor : T_Items) extends Evaluation[T_Items,T_SymbolLattice](anchor,anchor.toString()+"."+"items_first") with CircularEvaluation[T_Items,T_SymbolLattice] {
    def lattice() : C_LATTICE[T_SymbolLattice] = t_SymbolLattice;

    override def compute : ValueType = c_items_first(anchor);
  }
  private object a_items_first extends Attribute[T_Items,T_SymbolLattice](t_Items,t_SymbolLattice,"items_first") {
    override def createEvaluation(anchor : T_Items) : Evaluation[T_Items,T_SymbolLattice] = new E_items_first(anchor);
  }
  val v_items_first : T_Items => T_SymbolLattice = a_items_first.get _;

  private class E_grammar_first(anchor : T_Grammar) extends Evaluation[T_Grammar,T_DeclarationTable](anchor,anchor.toString()+"."+"grammar_first") {
    override def compute : ValueType = c_grammar_first(anchor);
  }
  private object a_grammar_first extends Attribute[T_Grammar,T_DeclarationTable](t_Grammar,t_DeclarationTable,"grammar_first") {
    override def createEvaluation(anchor : T_Grammar) : Evaluation[T_Grammar,T_DeclarationTable] = new E_grammar_first(anchor);
  }
  val v_grammar_first : T_Grammar => T_DeclarationTable = a_grammar_first.get _;

  val v_epsilon:T_Symbol = v_make_symbol("epsilon");
  private class E1_temp(anchor : t_Result.T_Production) extends Evaluation[t_Result.T_Production,T_SymbolLattice](anchor,anchor.toString()+"."+"temp") with CircularEvaluation[t_Result.T_Production,T_SymbolLattice] with CollectionEvaluation[t_Result.T_Production,T_SymbolLattice] {
    override def combine(v1 : T_SymbolLattice, v2 : T_SymbolLattice) = t_SymbolLattice.v_combine(v1,v2);
    def lattice() : C_LATTICE[T_SymbolLattice] = t_SymbolLattice;

    override def compute : ValueType = c1_temp(anchor);
  }
  private object a1_temp extends Attribute[t_Result.T_Production,T_SymbolLattice](t_Result.t_Production,t_SymbolLattice,"temp") {
    override def createEvaluation(anchor : t_Result.T_Production) : Evaluation[t_Result.T_Production,T_SymbolLattice] = new E1_temp(anchor);
  }
  val v_contains_epsilon = f_contains_epsilon _;
  def f_contains_epsilon(v_s_set : T_Symbols):T_Boolean = {

    return t_Symbols.v_member(v_epsilon,v_s_set);
    throw Evaluation.UndefinedAttributeException("local contains_epsilon");
  }

  val v_black_dot = f_black_dot _;
  def f_black_dot(v_s1 : T_Symbols, v_s2 : T_Symbols):T_Symbols = {

    { val cond = v_contains_epsilon(v_s1);
      if (cond) {
        return new M__basic_19[ T_Symbol,T_Symbols](t_Symbol,t_Symbols).v__op_5w(new M__basic_19[ T_Symbol,T_Symbols](t_Symbol,t_Symbols).v__op_w5D(v_s1,t_Symbols.v_single(v_epsilon)),v_s2);
      }
      if (!cond) {
        return v_s1;
      }
    }
    throw Evaluation.UndefinedAttributeException("local black_dot");
  }

  def c1_temp(anchor : Any) : T_SymbolLattice = {
    anchor match {
      case p_prod(v_self,v_nt,v_items) => {
        var collection : T_SymbolLattice = v_items_first(v_items);
        return collection;
      }
    }
  }
  def c_item_first(anode : T_Item) : T_SymbolLattice = {
    val anchor = anode;
    anchor match {
      case p_terminal(v_self,v_s) => {
        if (anode eq v_self) return t_SymbolLattice.v_single(v_s);
      }
      case _ => {}
    }
    anchor match {
      case p_nonterminal(v_self,v_s) => {
        t_DeclarationTable.v_select(v_firstTable,v_s) match {
          case t_DeclarationTable.p_table_entry(_,v_0,v_item_first_objs) => {
            if (anode eq v_self) return v_item_first_objs;
          }
        }
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".item_first");
  }
  def c_items_first(anode : T_Items) : T_SymbolLattice = {
    val anchor = anode;
    anchor match {
      case t_Items.p_none(v_self) => {
        if (anode eq v_self) return t_SymbolLattice.v_single(v_epsilon);
      }
      case _ => {}
    }
    anchor match {
      case t_Items.p_single(v_self,v_item) => {
        if (anode eq v_self) return v_item_first(v_item);
      }
      case _ => {}
    }
    anchor match {
      case t_Items.p_append(v_self,v_items1,v_items2) => {
        if (anode eq v_self) return v_black_dot(v_items_first(v_items1),v_items_first(v_items2));
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".items_first");
  }
  def c_grammar_first(anode : T_Grammar) : T_DeclarationTable = {
    val anchor = anode;
    anchor match {
      case p_grammar(v_self,v_prods) => {
        if (anode eq v_self) return v_firstTable;
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".grammar_first");
  }
  def c_firstTable() : T_DeclarationTable = {
    var collection : T_DeclarationTable = t_DeclarationTable.v_initial;
    for (anchor <- t_Result.t_Production.nodes) anchor match {
      case p_prod(v_self,v_nt,v_items) => {
        collection = t_DeclarationTable.v_combine(collection,t_DeclarationTable.v_table_entry(v_nt,a1_temp.get(anchor)));
      }
      case _ => {}
    }
    return collection;
  }
  override def finish() : Unit = {
    a_firstTable.get;
    a_item_first.finish;
    a_items_first.finish;
    a_grammar_first.finish;
    super.finish();
  }

}

